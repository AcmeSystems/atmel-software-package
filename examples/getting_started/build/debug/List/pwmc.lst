###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:04
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\pwmc.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\pwmc.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\pwmc.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\pwmc.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\core\pwmc.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2011, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup pwm_module Working with PWM
     31           * \section Purpose
     32           * The PWM driver provides the interface to configure and use the PWM
     33           * peripheral.
     34           *
     35           * The PWM macrocell controls square output waveforms of 4 channels.
     36           * Characteristics of output waveforms such as period, duty-cycle can be configured.\n
     37           *
     38           * Before enabling the channels, they must have been configured first.
     39           * The main settings include:
     40           * <ul>
     41           * <li>Configuration of the clock generator.</li>
     42           * <li>Selection of the clock for each channel.</li>
     43           * <li>Configuration of output waveform characteristics, such as period, duty-cycle etc.</li>
     44           * </ul>
     45           *
     46           * After the channels is enabled, the user must use respective update registers
     47           * to change the wave characteristics to prevent unexpected output waveform.
     48           * i.e. PWM_CUPDx register should be used if user want to change duty-cycle
     49           * when the channel is enabled.
     50           *
     51           * \section Usage
     52           * <ul>
     53           * <li>  Configure PWM clock using PWMC_ConfigureClocks().
     54           * <li>  Enable & disable given PWM channel using PWMC_EnableChannel() and PWMC_DisableChannel().
     55           * <li>  Enable & disable interrupt of given PWM channel using PWMC_EnableChannelIt()
     56           * and PWMC_DisableChannelIt().
     57           * <li>  Set feature of the given PWM channel's output signal using PWMC_SetPeriod()
     58           * and PWMC_SetDutyCycle().
     59           * </li>
     60           * </ul>
     61           *
     62           * For more accurate information, please look at the PWM section of the
     63           * Datasheet.
     64           *
     65           * Related files :\n
     66           * \ref pwmc.c\n
     67           * \ref pwmc.h.\n
     68           */
     69          /*@{*/
     70          /*@}*/
     71          
     72          /**
     73           * \file
     74           *
     75           * Implementation of the Pulse Width Modulation Controller (PWM) peripheral.
     76           *
     77           */
     78          
     79          /*----------------------------------------------------------------------------
     80           *        Headers
     81           *----------------------------------------------------------------------------*/
     82          
     83          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     84          #include "core/pwmc.h"
     85          
     86          #include <stdint.h>
     87          #include <assert.h>
     88          
     89          /*----------------------------------------------------------------------------
     90           *        Exported functions
     91           *----------------------------------------------------------------------------*/
     92          
     93          /**
     94           * \brief Configures PWM clocks
     95           * \param pPwm  Pointer to a Pwm instance
     96           * \param mode  PWM clock source selection and divide factor.
     97           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     98          void
     99          PWMC_ConfigureClocks(Pwm * pPwm, uint32_t mode)
    100          {
    101          	pPwm->PWM_CLK = mode;
   \                     PWMC_ConfigureClocks:
   \   00000000   0xE5801000         STR      R1,[R0, #+0]
    102          }
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    103          
    104          /**
    105           * \brief Enables the given PWM channel.
    106           *
    107           * This does NOT enable the corresponding pin;this must be done in the user code.
    108           *
    109           * \param pPwm  Pointer to a Pwm instance
    110           * \param channel  Channel number.
    111           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    112          void
    113          PWMC_EnableChannel(Pwm * pPwm, uint8_t channel)
    114          {
    115          	pPwm->PWM_ENA = 0x1ul << channel;
   \                     PWMC_EnableChannel:
   \   00000000   0xE3A02001         MOV      R2,#+1
   \   00000004   0xE1B02112         LSLS     R2,R2,R1
   \   00000008   0xE5802004         STR      R2,[R0, #+4]
    116          }
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    117          
    118          /**
    119           * \brief Disables the given PWM channel.
    120           *
    121           * Beware, channel will be effectively disabled at the end of the current period.
    122           * Application can check channel is disabled using the following wait loop:
    123           * while ((PWM->PWM_SR & (1 << channel)) != 0);
    124           *
    125           * \param pPwm  Pointer to a Pwm instance
    126           * \param channel  Channel number.
    127           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    128          void
    129          PWMC_DisableChannel(Pwm * pPwm, uint8_t channel)
    130          {
    131          	pPwm->PWM_DIS = 0x1ul << channel;
   \                     PWMC_DisableChannel:
   \   00000000   0xE3A02001         MOV      R2,#+1
   \   00000004   0xE1B02112         LSLS     R2,R2,R1
   \   00000008   0xE5802008         STR      R2,[R0, #+8]
    132          }
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    133          
    134          /**
    135           * \brief Enables the selected interrupts sources on a PWMC peripheral.
    136           * \param pPwm  Pointer to a Pwm instance
    137           * \param channel  Channel number.
    138           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    139          void
    140          PWMC_EnableChannelIt(Pwm * pPwm, uint8_t channel)
    141          {
    142          	pPwm->PWM_IER1 = 0x1ul << channel;
   \                     PWMC_EnableChannelIt:
   \   00000000   0xE3A02001         MOV      R2,#+1
   \   00000004   0xE1B02112         LSLS     R2,R2,R1
   \   00000008   0xE5802010         STR      R2,[R0, #+16]
    143          }
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    144          
    145          /**
    146           * \brief Disables the selected interrupts sources on a PWMC peripheral.
    147           * \param pPwm  Pointer to a Pwm instance
    148           * \param channel  Channel number.
    149           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    150          void
    151          PWMC_DisableChannelIt(Pwm * pPwm, uint8_t channel)
    152          {
    153          	pPwm->PWM_IDR1 = 0x1ul << channel;
   \                     PWMC_DisableChannelIt:
   \   00000000   0xE3A02001         MOV      R2,#+1
   \   00000004   0xE1B02112         LSLS     R2,R2,R1
   \   00000008   0xE5802014         STR      R2,[R0, #+20]
    154          }
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    155          
    156          /**
    157           * \brief Configures PWM a channel with the given parameters, basic configure function.
    158           *
    159           * The PWM controller must have been clocked in the PMC prior to calling this
    160           * function.
    161           * Beware: this function disables the channel. It waits until disable is effective.
    162           *
    163           * \param pPwm  Pointer to a Pwm instance
    164           * \param channel  Channel number.
    165           * \param mode  Channel mode.
    166           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    167          void
    168          PWMC_ConfigureChannel(Pwm * pPwm, uint8_t channel, uint32_t mode)
    169          {
    170          	pPwm->PWM_CH_NUM[channel].PWM_CMR = mode;
   \                     PWMC_ConfigureChannel:
   \   00000000   0xE1B03001         MOVS     R3,R1
   \   00000004   0xE6EF3073         UXTB     R3,R3
   \   00000008   0xE1B03283         LSLS     R3,R3,#+5
   \   0000000C   0xE0933000         ADDS     R3,R3,R0
   \   00000010   0xE5832200         STR      R2,[R3, #+512]
    171          }
   \   00000014   0xE12FFF1E         BX       LR               ;; return
    172          
    173          /**
    174           * \brief Sets the period value used by a PWM channel.
    175           *
    176           * This function writes directly to the CPRD register if the channel is disabled;
    177           * otherwise, it uses the update register CPRDUPD.
    178           *
    179           * \param pPwm  Pointer to a Pwm instance
    180           * \param channel Channel number.
    181           * \param period  Period value.
    182           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    183          void
    184          PWMC_SetPeriod(Pwm * pPwm, uint8_t channel, uint16_t period)
    185          {
    186          	/* If channel is disabled, write to CPRD */
    187          	if ((pPwm->PWM_SR & (1 << channel)) == 0) {
   \                     PWMC_SetPeriod:
   \   00000000   0xE590300C         LDR      R3,[R0, #+12]
   \   00000004   0xE3A0C001         MOV      R12,#+1
   \   00000008   0xE11C0133         TST      R12,R3, LSR R1
   \   0000000C   0x1A000007         BNE      ??PWMC_SetPeriod_0
    188          		pPwm->PWM_CH_NUM[channel].PWM_CPRD = period;
   \   00000010   0xE1B03002         MOVS     R3,R2
   \   00000014   0xE6FF3073         UXTH     R3,R3
   \   00000018   0xE1B0C001         MOVS     R12,R1
   \   0000001C   0xE6EFC07C         UXTB     R12,R12
   \   00000020   0xE1B0C28C         LSLS     R12,R12,#+5
   \   00000024   0xE09CC000         ADDS     R12,R12,R0
   \   00000028   0xE58C320C         STR      R3,[R12, #+524]
   \   0000002C   0xEA000006         B        ??PWMC_SetPeriod_1
    189          	}
    190          	/* Otherwise use update register */
    191          	else {
    192          		pPwm->PWM_CH_NUM[channel].PWM_CPRDUPD = period;
   \                     ??PWMC_SetPeriod_0:
   \   00000030   0xE1B03002         MOVS     R3,R2
   \   00000034   0xE6FF3073         UXTH     R3,R3
   \   00000038   0xE1B0C001         MOVS     R12,R1
   \   0000003C   0xE6EFC07C         UXTB     R12,R12
   \   00000040   0xE1B0C28C         LSLS     R12,R12,#+5
   \   00000044   0xE09CC000         ADDS     R12,R12,R0
   \   00000048   0xE58C3210         STR      R3,[R12, #+528]
    193          	}
    194          }
   \                     ??PWMC_SetPeriod_1:
   \   0000004C   0xE12FFF1E         BX       LR               ;; return
    195          
    196          /**
    197           * \brief Sets the duty cycle used by a PWM channel.
    198           * This function writes directly to the CDTY register if the channel is disabled;
    199           * otherwise it uses the update register CDTYUPD.
    200           * Note that the duty cycle must always be inferior or equal to the channel
    201           * period.
    202           *
    203           * \param pPwm  Pointer to a Pwm instance
    204           * \param channel  Channel number.
    205           * \param duty     Duty cycle value.
    206           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    207          void
    208          PWMC_SetDutyCycle(Pwm * pPwm, uint8_t channel, uint16_t duty)
    209          {
   \                     PWMC_SetDutyCycle:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    210          	assert(duty <= pPwm->PWM_CH_NUM[channel].PWM_CPRD);
   \   00000010   0xE1B00005         MOVS     R0,R5
   \   00000014   0xE6EF0070         UXTB     R0,R0
   \   00000018   0xE1B00280         LSLS     R0,R0,#+5
   \   0000001C   0xE0900004         ADDS     R0,R0,R4
   \   00000020   0xE590020C         LDR      R0,[R0, #+524]
   \   00000024   0xE1B01006         MOVS     R1,R6
   \   00000028   0xE6FF1071         UXTH     R1,R1
   \   0000002C   0xE1500001         CMP      R0,R1
   \   00000030   0x2A000004         BCS      ??PWMC_SetDutyCycle_0
   \   00000034   0xE3A020D2         MOV      R2,#+210
   \   00000038   0x........         LDR      R1,??DataTable0
   \   0000003C   0x........         LDR      R0,??DataTable0_1
   \   00000040   0x........         BL       __aeabi_assert
   \   00000044   0x........         BL       __iar_EmptyStepPoint
    211          
    212          	/* If channel is disabled, write to CDTY */
    213          	if ((pPwm->PWM_SR & (1 << channel)) == 0) {
   \                     ??PWMC_SetDutyCycle_0:
   \   00000048   0xE594000C         LDR      R0,[R4, #+12]
   \   0000004C   0xE3A01001         MOV      R1,#+1
   \   00000050   0xE1110530         TST      R1,R0, LSR R5
   \   00000054   0x1A000007         BNE      ??PWMC_SetDutyCycle_1
    214          		pPwm->PWM_CH_NUM[channel].PWM_CDTY = duty;
   \   00000058   0xE1B00006         MOVS     R0,R6
   \   0000005C   0xE6FF0070         UXTH     R0,R0
   \   00000060   0xE1B01005         MOVS     R1,R5
   \   00000064   0xE6EF1071         UXTB     R1,R1
   \   00000068   0xE1B01281         LSLS     R1,R1,#+5
   \   0000006C   0xE0911004         ADDS     R1,R1,R4
   \   00000070   0xE5810204         STR      R0,[R1, #+516]
   \   00000074   0xEA000006         B        ??PWMC_SetDutyCycle_2
    215          	}
    216          	/* Otherwise use update register */
    217          	else {
    218          		pPwm->PWM_CH_NUM[channel].PWM_CDTYUPD = duty;
   \                     ??PWMC_SetDutyCycle_1:
   \   00000078   0xE1B00006         MOVS     R0,R6
   \   0000007C   0xE6FF0070         UXTH     R0,R0
   \   00000080   0xE1B01005         MOVS     R1,R5
   \   00000084   0xE6EF1071         UXTB     R1,R1
   \   00000088   0xE1B01281         LSLS     R1,R1,#+5
   \   0000008C   0xE0911004         ADDS     R1,R1,R4
   \   00000090   0xE5810208         STR      R0,[R1, #+520]
    219          	}
    220          }
   \                     ??PWMC_SetDutyCycle_2:
   \   00000094   0xE8BD8070         POP      {R4-R6,PC}       ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x64 0x75          DC8 "duty <= pPwm->PWM_CH_NUM[channel].PWM_CPRD"
   \              0x74 0x79    
   \              0x20 0x3C    
   \              0x3D 0x20    
   \              0x70 0x50    
   \              0x77 0x6D    
   \              0x2D 0x3E    
   \              0x50 0x57    
   \              0x4D 0x5F    
   \              0x43 0x48    
   \              0x5F 0x4E    
   \              0x55 0x4D    
   \              0x5B 0x63    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x5D 0x2E    
   \              0x50 0x57    
   \              0x4D 0x5F    
   \              0x43 0x50    
   \              0x52 0x44    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 63H, 6FH, 72H, 65H
   \              0x73 0x5C    
   \              0x63 0x6F    
   \              0x72 0x65    
   \   00000038   0x5C 0x70          DC8 5CH, 70H, 77H, 6DH, 63H, 2EH, 63H, 0
   \              0x77 0x6D    
   \              0x63 0x2E    
   \              0x63 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   PWMC_ConfigureChannel
       0   PWMC_ConfigureClocks
       0   PWMC_DisableChannel
       0   PWMC_DisableChannelIt
       0   PWMC_EnableChannel
       0   PWMC_EnableChannelIt
      16   PWMC_SetDutyCycle
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   PWMC_SetPeriod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
      44  ?_0
      64  ?_1
      24  PWMC_ConfigureChannel
       8  PWMC_ConfigureClocks
      16  PWMC_DisableChannel
      16  PWMC_DisableChannelIt
      16  PWMC_EnableChannel
      16  PWMC_EnableChannelIt
     152  PWMC_SetDutyCycle
      80  PWMC_SetPeriod
      56  _id_h64_matrix

 
 164 bytes in section .rodata
 336 bytes in section SOFTPACK
 
 336 bytes of CODE  memory
 164 bytes of CONST memory

Errors: none
Warnings: 1
