###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        19/May/2015  10:18:20
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\xdmac.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\xdmac.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D21
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\xdmac.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\xdmac.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\bus\xdmac.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2014, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /**
     31           * \file
     32           *
     33           * Implementation of xDMA controller (XDMAC).
     34           *
     35           */
     36          
     37          /*----------------------------------------------------------------------------
     38           *        Headers
     39           *----------------------------------------------------------------------------*/
     40          
     41          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned char const _id_h64_matrix[13]
   \                     _id_h64_matrix:
   \   00000000   0x02 0x06          DC8 2, 6, 7, 9, 12, 13, 15, 31, 45, 46, 52, 53, 63, 0, 0, 0
   \              0x07 0x09    
   \              0x0C 0x0D    
   \              0x0F 0x1F    
   \              0x2D 0x2E    
   \              0x34 0x35    
   \              0x3F 0x00    
   \              0x00 0x00    
     42          #include "bus/xdmac.h"
     43          
     44          #include <stdint.h>
     45          #include <assert.h>
     46          /** \addtogroup dmac_functions XDMAC Functions
     47           *@{
     48           */
     49          
     50          /*----------------------------------------------------------------------------
     51           *        Exported functions
     52           *----------------------------------------------------------------------------*/
     53          
     54          /**
     55           * \brief Get XDMAC global type.
     56           *
     57           * \param pXdmac Pointer to the XDMAC peripheral.
     58           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     59          uint32_t
     60          XDMAC_GetType(Xdmac * pXdmac)
     61          {
   \                     XDMAC_GetType:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     62          	assert(pXdmac);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??XDMAC_GetType_0
   \   00000010   0xE3A0203E         MOV      R2,#+62
   \   00000014   0x........         LDR      R1,??DataTable36
   \   00000018   0x........         LDR      R0,??DataTable36_1
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
     63          	return pXdmac->XDMAC_GTYPE;
   \                     ??XDMAC_GetType_0:
   \   00000024   0xE5940000         LDR      R0,[R4, #+0]
   \   00000028   0xE8BD8010         POP      {R4,PC}          ;; return
     64          }
     65          
     66          /**
     67           * \brief Get XDMAC global configuration.
     68           *
     69           * \param pXdmac Pointer to the XDMAC peripheral.
     70           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     71          uint32_t
     72          XDMAC_GetConfig(Xdmac * pXdmac)
     73          {
   \                     XDMAC_GetConfig:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     74          	assert(pXdmac);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??XDMAC_GetConfig_0
   \   00000010   0xE3A0204A         MOV      R2,#+74
   \   00000014   0x........         LDR      R1,??DataTable36
   \   00000018   0x........         LDR      R0,??DataTable36_1
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
     75          	return pXdmac->XDMAC_GCFG;
   \                     ??XDMAC_GetConfig_0:
   \   00000024   0xE5940004         LDR      R0,[R4, #+4]
   \   00000028   0xE8BD8010         POP      {R4,PC}          ;; return
     76          }
     77          
     78          /**
     79           * \brief Get XDMAC global weighted arbiter configuration.
     80           *
     81           * \param pXdmac Pointer to the XDMAC peripheral.
     82           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     83          uint32_t
     84          XDMAC_GetArbiter(Xdmac * pXdmac)
     85          {
   \                     XDMAC_GetArbiter:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     86          	assert(pXdmac);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??XDMAC_GetArbiter_0
   \   00000010   0xE3A02056         MOV      R2,#+86
   \   00000014   0x........         LDR      R1,??DataTable36
   \   00000018   0x........         LDR      R0,??DataTable36_1
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
     87          	return pXdmac->XDMAC_GWAC;
   \                     ??XDMAC_GetArbiter_0:
   \   00000024   0xE5940008         LDR      R0,[R4, #+8]
   \   00000028   0xE8BD8010         POP      {R4,PC}          ;; return
     88          }
     89          
     90          /**
     91           * \brief Enables XDMAC global interrupt.
     92           *
     93           * \param pXdmac Pointer to the XDMAC peripheral.
     94           * \param dwInteruptMask IT to be enabled.
     95           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     96          void
     97          XDMAC_EnableGIt(Xdmac * pXdmac, uint32_t dwInteruptMask)
     98          {
   \                     XDMAC_EnableGIt:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
     99          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_EnableGIt_0
   \   00000014   0xE3A02063         MOV      R2,#+99
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    100          	pXdmac->XDMAC_GIE = dwInteruptMask;
   \                     ??XDMAC_EnableGIt_0:
   \   00000028   0xE584500C         STR      R5,[R4, #+12]
    101          }
   \   0000002C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    102          
    103          /**
    104           * \brief Disables XDMAC global interrupt
    105           *
    106           * \param pXdmac Pointer to the XDMAC peripheral.
    107           * \param dwInteruptMask IT to be enabled
    108           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    109          void
    110          XDMAC_DisableGIt(Xdmac * pXdmac, uint32_t dwInteruptMask)
    111          {
   \                     XDMAC_DisableGIt:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    112          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_DisableGIt_0
   \   00000014   0xE3A02070         MOV      R2,#+112
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    113          	pXdmac->XDMAC_GID = dwInteruptMask;
   \                     ??XDMAC_DisableGIt_0:
   \   00000028   0xE5845010         STR      R5,[R4, #+16]
    114          }
   \   0000002C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    115          
    116          /**
    117           * \brief Get XDMAC global interrupt mask.
    118           *
    119           * \param pXdmac Pointer to the XDMAC peripheral.
    120           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    121          uint32_t
    122          XDMAC_GetGItMask(Xdmac * pXdmac)
    123          {
   \                     XDMAC_GetGItMask:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    124          	assert(pXdmac);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??XDMAC_GetGItMask_0
   \   00000010   0xE3A0207C         MOV      R2,#+124
   \   00000014   0x........         LDR      R1,??DataTable36
   \   00000018   0x........         LDR      R0,??DataTable36_1
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    125          	return (pXdmac->XDMAC_GIM);
   \                     ??XDMAC_GetGItMask_0:
   \   00000024   0xE5940014         LDR      R0,[R4, #+20]
   \   00000028   0xE8BD8010         POP      {R4,PC}          ;; return
    126          }
    127          
    128          /**
    129           * \brief Get XDMAC global interrupt status.
    130           *
    131           * \param pXdmac Pointer to the XDMAC peripheral.
    132           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    133          uint32_t
    134          XDMAC_GetGIsr(Xdmac * pXdmac)
    135          {
   \                     XDMAC_GetGIsr:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    136          	assert(pXdmac);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??XDMAC_GetGIsr_0
   \   00000010   0xE3A02088         MOV      R2,#+136
   \   00000014   0x........         LDR      R1,??DataTable36
   \   00000018   0x........         LDR      R0,??DataTable36_1
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    137          	return (pXdmac->XDMAC_GIS);
   \                     ??XDMAC_GetGIsr_0:
   \   00000024   0xE5940018         LDR      R0,[R4, #+24]
   \   00000028   0xE8BD8010         POP      {R4,PC}          ;; return
    138          }
    139          
    140          /**
    141           * \brief Get XDMAC masked global interrupt.
    142           *
    143           * \param pXdmac Pointer to the XDMAC peripheral.
    144           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    145          uint32_t
    146          XDMAC_GetMaskedGIsr(Xdmac * pXdmac)
    147          {
   \                     XDMAC_GetMaskedGIsr:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    148          	uint32_t _dwStatus;
    149          	assert(pXdmac);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??XDMAC_GetMaskedGIsr_0
   \   00000010   0xE3A02095         MOV      R2,#+149
   \   00000014   0x........         LDR      R1,??DataTable36
   \   00000018   0x........         LDR      R0,??DataTable36_1
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    150          	_dwStatus = pXdmac->XDMAC_GIS;
   \                     ??XDMAC_GetMaskedGIsr_0:
   \   00000024   0xE5940018         LDR      R0,[R4, #+24]
   \   00000028   0xE1B05000         MOVS     R5,R0
    151          	_dwStatus &= pXdmac->XDMAC_GIM;
   \   0000002C   0xE5940014         LDR      R0,[R4, #+20]
   \   00000030   0xE0105005         ANDS     R5,R0,R5
    152          	return _dwStatus;
   \   00000034   0xE1B00005         MOVS     R0,R5
   \   00000038   0xE8BD8032         POP      {R1,R4,R5,PC}    ;; return
    153          }
    154          
    155          /**
    156           * \brief enables the relevant channel of given XDMAC.
    157           *
    158           * \param pXdmac Pointer to the XDMAC peripheral.
    159           * \param channel Particular channel number.
    160           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    161          void
    162          XDMAC_EnableChannel(Xdmac * pXdmac, uint8_t channel)
    163          {
   \                     XDMAC_EnableChannel:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    164          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_EnableChannel_0
   \   00000014   0xE3A020A4         MOV      R2,#+164
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    165          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_EnableChannel_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_EnableChannel_1
   \   00000038   0xE3A020A5         MOV      R2,#+165
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    166          	pXdmac->XDMAC_GE |= XDMAC_GE_EN0 << channel;
   \                     ??XDMAC_EnableChannel_1:
   \   0000004C   0xE594001C         LDR      R0,[R4, #+28]
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0xE1900511         ORRS     R0,R0,R1, LSL R5
   \   00000058   0xE584001C         STR      R0,[R4, #+28]
    167          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    168          
    169          /**
    170           * \brief enables the relevant channels of given XDMAC.
    171           *
    172           * \param pXdmac Pointer to the XDMAC peripheral.
    173           * \param bmChannels Channels bitmap.
    174           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    175          void
    176          XDMAC_EnableChannels(Xdmac * pXdmac, uint8_t bmChannels)
    177          {
   \                     XDMAC_EnableChannels:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    178          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_EnableChannels_0
   \   00000014   0xE3A020B2         MOV      R2,#+178
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    179          	pXdmac->XDMAC_GE = bmChannels;
   \                     ??XDMAC_EnableChannels_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE584001C         STR      R0,[R4, #+28]
    180          }
   \   00000034   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    181          
    182          /**
    183           * \brief Disables the relevant channel of given XDMAC.
    184           *
    185           * \param pXdmac Pointer to the XDMAC peripheral.
    186           * \param channel Particular channel number.
    187           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    188          void
    189          XDMAC_DisableChannel(Xdmac * pXdmac, uint8_t channel)
    190          {
   \                     XDMAC_DisableChannel:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    191          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_DisableChannel_0
   \   00000014   0xE3A020BF         MOV      R2,#+191
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    192          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_DisableChannel_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_DisableChannel_1
   \   00000038   0xE3A020C0         MOV      R2,#+192
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    193          	pXdmac->XDMAC_GD |= XDMAC_GD_DI0 << channel;
   \                     ??XDMAC_DisableChannel_1:
   \   0000004C   0xE5940020         LDR      R0,[R4, #+32]
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0xE1900511         ORRS     R0,R0,R1, LSL R5
   \   00000058   0xE5840020         STR      R0,[R4, #+32]
    194          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    195          
    196          /**
    197           * \brief Disables the relevant channels of given XDMAC.
    198           *
    199           * \param pXdmac Pointer to the XDMAC peripheral.
    200           * \param bmChannels Channels bitmap.
    201           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    202          void
    203          XDMAC_DisableChannels(Xdmac * pXdmac, uint8_t bmChannels)
    204          {
   \                     XDMAC_DisableChannels:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    205          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_DisableChannels_0
   \   00000014   0xE3A020CD         MOV      R2,#+205
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    206          	pXdmac->XDMAC_GD = bmChannels;
   \                     ??XDMAC_DisableChannels_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE5840020         STR      R0,[R4, #+32]
    207          }
   \   00000034   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    208          
    209          /**
    210           * \brief Get Global channel status of given XDMAC.
    211           * \note: When set to 1, this bit indicates that the channel x is enabled. If a channel disable request is issued, this bit remains asserted
    212              until pending transaction is completed.
    213           * \param pXdmac Pointer to the XDMAC peripheral.
    214           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    215          uint32_t
    216          XDMAC_GetGlobalChStatus(Xdmac * pXdmac)
    217          {
   \                     XDMAC_GetGlobalChStatus:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    218          
    219          	assert(pXdmac);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??XDMAC_GetGlobalChStatus_0
   \   00000010   0xE3A020DB         MOV      R2,#+219
   \   00000014   0x........         LDR      R1,??DataTable36
   \   00000018   0x........         LDR      R0,??DataTable36_1
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    220          	return pXdmac->XDMAC_GS;
   \                     ??XDMAC_GetGlobalChStatus_0:
   \   00000024   0xE5940024         LDR      R0,[R4, #+36]
   \   00000028   0xE8BD8010         POP      {R4,PC}          ;; return
    221          }
    222          
    223          /**
    224           * \brief Suspend the relevant channel's read.
    225           *
    226           * \param pXdmac Pointer to the XDMAC peripheral.
    227           * \param channel Particular channel number.
    228           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    229          void
    230          XDMAC_SuspendReadChannel(Xdmac * pXdmac, uint8_t channel)
    231          {
   \                     XDMAC_SuspendReadChannel:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    232          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_SuspendReadChannel_0
   \   00000014   0xE3A020E8         MOV      R2,#+232
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    233          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SuspendReadChannel_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_SuspendReadChannel_1
   \   00000038   0xE3A020E9         MOV      R2,#+233
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    234          	pXdmac->XDMAC_GRS |= XDMAC_GRS_RS0 << channel;
   \                     ??XDMAC_SuspendReadChannel_1:
   \   0000004C   0xE5940028         LDR      R0,[R4, #+40]
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0xE1900511         ORRS     R0,R0,R1, LSL R5
   \   00000058   0xE5840028         STR      R0,[R4, #+40]
    235          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    236          
    237          /**
    238           * \brief Suspend the relevant channel's write.
    239           *
    240           * \param pXdmac Pointer to the XDMAC peripheral.
    241           * \param channel Particular channel number.
    242           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    243          void
    244          XDMAC_SuspendWriteChannel(Xdmac * pXdmac, uint8_t channel)
    245          {
   \                     XDMAC_SuspendWriteChannel:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    246          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_SuspendWriteChannel_0
   \   00000014   0xE3A020F6         MOV      R2,#+246
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    247          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SuspendWriteChannel_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_SuspendWriteChannel_1
   \   00000038   0xE3A020F7         MOV      R2,#+247
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    248          	pXdmac->XDMAC_GWS |= XDMAC_GWS_WS0 << channel;
   \                     ??XDMAC_SuspendWriteChannel_1:
   \   0000004C   0xE594002C         LDR      R0,[R4, #+44]
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0xE1900511         ORRS     R0,R0,R1, LSL R5
   \   00000058   0xE584002C         STR      R0,[R4, #+44]
    249          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    250          
    251          /**
    252           * \brief Suspend the relevant channel's read & write.
    253           *
    254           * \param pXdmac Pointer to the XDMAC peripheral.
    255           * \param channel Particular channel number.
    256           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    257          void
    258          XDMAC_SuspendReadWriteChannel(Xdmac * pXdmac, uint8_t channel)
    259          {
   \                     XDMAC_SuspendReadWriteChannel:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    260          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_SuspendReadWriteChannel_0
   \   00000014   0xE3A02F41         MOV      R2,#+260
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    261          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SuspendReadWriteChannel_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_SuspendReadWriteChannel_1
   \   00000038   0xE3002105         MOVW     R2,#+261
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    262          	pXdmac->XDMAC_GRWS |= XDMAC_GRWS_RWS0 << channel;
   \                     ??XDMAC_SuspendReadWriteChannel_1:
   \   0000004C   0xE5940030         LDR      R0,[R4, #+48]
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0xE1900511         ORRS     R0,R0,R1, LSL R5
   \   00000058   0xE5840030         STR      R0,[R4, #+48]
    263          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    264          
    265          /**
    266           * \brief Resume the relevant channel's read & write.
    267           *
    268           * \param pXdmac Pointer to the XDMAC peripheral.
    269           * \param channel Particular channel number.
    270           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    271          void
    272          XDMAC_ResumeReadWriteChannel(Xdmac * pXdmac, uint8_t channel)
    273          {
   \                     XDMAC_ResumeReadWriteChannel:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    274          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_ResumeReadWriteChannel_0
   \   00000014   0xE3002112         MOVW     R2,#+274
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    275          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_ResumeReadWriteChannel_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_ResumeReadWriteChannel_1
   \   00000038   0xE3002113         MOVW     R2,#+275
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    276          	pXdmac->XDMAC_GRWR |= XDMAC_GRWR_RWR0 << channel;
   \                     ??XDMAC_ResumeReadWriteChannel_1:
   \   0000004C   0xE5940034         LDR      R0,[R4, #+52]
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0xE1900511         ORRS     R0,R0,R1, LSL R5
   \   00000058   0xE5840034         STR      R0,[R4, #+52]
    277          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    278          
    279          /**
    280           * \brief Set software transfer request on the relevant channel.
    281           *
    282           * \param pXdmac Pointer to the XDMAC peripheral.
    283           * \param channel Particular channel number.
    284           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    285          void
    286          XDMAC_SoftwareTransferReq(Xdmac * pXdmac, uint8_t channel)
    287          {
   \                     XDMAC_SoftwareTransferReq:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    288          
    289          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_SoftwareTransferReq_0
   \   00000014   0xE3002121         MOVW     R2,#+289
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    290          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SoftwareTransferReq_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_SoftwareTransferReq_1
   \   00000038   0xE3002122         MOVW     R2,#+290
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    291          	pXdmac->XDMAC_GSWR |= (XDMAC_GSWR_SWREQ0 << channel);
   \                     ??XDMAC_SoftwareTransferReq_1:
   \   0000004C   0xE5940038         LDR      R0,[R4, #+56]
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0xE1900511         ORRS     R0,R0,R1, LSL R5
   \   00000058   0xE5840038         STR      R0,[R4, #+56]
    292          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    293          
    294          /**
    295           * \brief Get software transfer status of the relevant channel.
    296           *
    297           * \param pXdmac Pointer to the XDMAC peripheral.
    298           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    299          uint32_t
    300          XDMAC_GetSoftwareTransferStatus(Xdmac * pXdmac)
    301          {
   \                     XDMAC_GetSoftwareTransferStatus:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    302          
    303          	assert(pXdmac);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??XDMAC_GetSoftwareTransferStatus_0
   \   00000010   0xE300212F         MOVW     R2,#+303
   \   00000014   0x........         LDR      R1,??DataTable36
   \   00000018   0x........         LDR      R0,??DataTable36_1
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    304          	return pXdmac->XDMAC_GSWS;
   \                     ??XDMAC_GetSoftwareTransferStatus_0:
   \   00000024   0xE594003C         LDR      R0,[R4, #+60]
   \   00000028   0xE8BD8010         POP      {R4,PC}          ;; return
    305          }
    306          
    307          /**
    308           * \brief Set software flush request on the relevant channel.
    309           *
    310           * \param pXdmac Pointer to the XDMAC peripheral.
    311           * \param channel Particular channel number.
    312           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    313          void
    314          XDMAC_SoftwareFlushReq(Xdmac * pXdmac, uint8_t channel)
    315          {
   \                     XDMAC_SoftwareFlushReq:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    316          
    317          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_SoftwareFlushReq_0
   \   00000014   0xE300213D         MOVW     R2,#+317
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    318          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SoftwareFlushReq_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_SoftwareFlushReq_1
   \   00000038   0xE300213E         MOVW     R2,#+318
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    319          	pXdmac->XDMAC_GSWF |= XDMAC_GSWF_SWF0 << channel;
   \                     ??XDMAC_SoftwareFlushReq_1:
   \   0000004C   0xE5940040         LDR      R0,[R4, #+64]
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0xE1900511         ORRS     R0,R0,R1, LSL R5
   \   00000058   0xE5840040         STR      R0,[R4, #+64]
    320          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    321          
    322          /**
    323           * \brief Disable interrupt with mask on the relevant channel of given XDMA.
    324           *
    325           * \param pXdmac Pointer to the XDMAC peripheral.
    326           * \param channel Particular channel number.
    327           * \param dwInteruptMask Interrupt mask.
    328           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    329          void
    330          XDMAC_EnableChannelIt(Xdmac * pXdmac, uint8_t channel, uint32_t dwInteruptMask)
    331          {
   \                     XDMAC_EnableChannelIt:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    332          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_EnableChannelIt_0
   \   00000018   0xE3A02F53         MOV      R2,#+332
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    333          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_EnableChannelIt_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_EnableChannelIt_1
   \   0000003C   0xE300214D         MOVW     R2,#+333
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    334          	pXdmac->XDMAC_CHID[channel].XDMAC_CIE = dwInteruptMask;
   \                     ??XDMAC_EnableChannelIt_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806050         STR      R6,[R0, #+80]
    335          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    336          
    337          /**
    338           * \brief Enable interrupt with mask on the relevant channel of given XDMA.
    339           *
    340           * \param pXdmac Pointer to the XDMAC peripheral.
    341           * \param channel Particular channel number.
    342           * \param dwInteruptMask Interrupt mask.
    343           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    344          void
    345          XDMAC_DisableChannelIt(Xdmac * pXdmac, uint8_t channel, uint32_t dwInteruptMask)
    346          {
   \                     XDMAC_DisableChannelIt:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    347          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_DisableChannelIt_0
   \   00000018   0xE300215B         MOVW     R2,#+347
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    348          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_DisableChannelIt_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_DisableChannelIt_1
   \   0000003C   0xE3A02F57         MOV      R2,#+348
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    349          	pXdmac->XDMAC_CHID[channel].XDMAC_CID = dwInteruptMask;
   \                     ??XDMAC_DisableChannelIt_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806054         STR      R6,[R0, #+84]
    350          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    351          
    352          /**
    353           * \brief Get interrupt mask for the relevant channel of given XDMA.
    354           *
    355           * \param pXdmac Pointer to the XDMAC peripheral.
    356           * \param channel Particular channel number.
    357           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    358          uint32_t
    359          XDMAC_GetChannelItMask(Xdmac * pXdmac, uint8_t channel)
    360          {
   \                     XDMAC_GetChannelItMask:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    361          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_GetChannelItMask_0
   \   00000014   0xE3002169         MOVW     R2,#+361
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    362          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_GetChannelItMask_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_GetChannelItMask_1
   \   00000038   0xE300216A         MOVW     R2,#+362
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    363          	return pXdmac->XDMAC_CHID[channel].XDMAC_CIM;
   \                     ??XDMAC_GetChannelItMask_1:
   \   0000004C   0xE6EF5075         UXTB     R5,R5
   \   00000050   0xE1B00305         LSLS     R0,R5,#+6
   \   00000054   0xE0900004         ADDS     R0,R0,R4
   \   00000058   0xE5900058         LDR      R0,[R0, #+88]
   \   0000005C   0xE8BD8032         POP      {R1,R4,R5,PC}    ;; return
    364          }
    365          
    366          /**
    367           * \brief Get interrupt status for the relevant channel of given XDMA.
    368           *
    369           * \param pXdmac Pointer to the XDMAC peripheral.
    370           * \param channel Particular channel number.
    371           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    372          uint32_t
    373          XDMAC_GetChannelIsr(Xdmac * pXdmac, uint8_t channel)
    374          {
   \                     XDMAC_GetChannelIsr:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    375          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_GetChannelIsr_0
   \   00000014   0xE3002177         MOVW     R2,#+375
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    376          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_GetChannelIsr_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_GetChannelIsr_1
   \   00000038   0xE3A02F5E         MOV      R2,#+376
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    377          	return pXdmac->XDMAC_CHID[channel].XDMAC_CIS;
   \                     ??XDMAC_GetChannelIsr_1:
   \   0000004C   0xE6EF5075         UXTB     R5,R5
   \   00000050   0xE1B00305         LSLS     R0,R5,#+6
   \   00000054   0xE0900004         ADDS     R0,R0,R4
   \   00000058   0xE590005C         LDR      R0,[R0, #+92]
   \   0000005C   0xE8BD8032         POP      {R1,R4,R5,PC}    ;; return
    378          }
    379          
    380          /**
    381           * \brief Get masked interrupt status for the relevant channel of given XDMA.
    382           *
    383           * \param pXdmac Pointer to the XDMAC peripheral.
    384           * \param channel Particular channel number.
    385           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    386          uint32_t
    387          XDMAC_GetMaskChannelIsr(Xdmac * pXdmac, uint8_t channel)
    388          {
   \                     XDMAC_GetMaskChannelIsr:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B06001         MOVS     R6,R1
    389          	uint32_t status;
    390          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_GetMaskChannelIsr_0
   \   00000014   0xE3002186         MOVW     R2,#+390
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    391          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_GetMaskChannelIsr_0:
   \   00000028   0xE1B00006         MOVS     R0,R6
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_GetMaskChannelIsr_1
   \   00000038   0xE3002187         MOVW     R2,#+391
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    392          	status = pXdmac->XDMAC_CHID[channel].XDMAC_CIS;
   \                     ??XDMAC_GetMaskChannelIsr_1:
   \   0000004C   0xE1B00006         MOVS     R0,R6
   \   00000050   0xE6EF0070         UXTB     R0,R0
   \   00000054   0xE1B00300         LSLS     R0,R0,#+6
   \   00000058   0xE0900004         ADDS     R0,R0,R4
   \   0000005C   0xE590005C         LDR      R0,[R0, #+92]
   \   00000060   0xE1B05000         MOVS     R5,R0
    393          	status &= pXdmac->XDMAC_CHID[channel].XDMAC_CIM;
   \   00000064   0xE1B00006         MOVS     R0,R6
   \   00000068   0xE6EF0070         UXTB     R0,R0
   \   0000006C   0xE1B00300         LSLS     R0,R0,#+6
   \   00000070   0xE0900004         ADDS     R0,R0,R4
   \   00000074   0xE5900058         LDR      R0,[R0, #+88]
   \   00000078   0xE0105005         ANDS     R5,R0,R5
    394          
    395          	return status;
   \   0000007C   0xE1B00005         MOVS     R0,R5
   \   00000080   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    396          }
    397          
    398          /**
    399           * \brief Set source address for the relevant channel of given XDMA.
    400           *
    401           * \param pXdmac Pointer to the XDMAC peripheral.
    402           * \param channel Particular channel number.
    403           * \param addr Source address.
    404           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    405          void
    406          XDMAC_SetSourceAddr(Xdmac * pXdmac, uint8_t channel, uint32_t addr)
    407          {
   \                     XDMAC_SetSourceAddr:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    408          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetSourceAddr_0
   \   00000018   0xE3A02F66         MOV      R2,#+408
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    409          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetSourceAddr_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetSourceAddr_1
   \   0000003C   0xE3002199         MOVW     R2,#+409
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    410          	pXdmac->XDMAC_CHID[channel].XDMAC_CSA = addr;
   \                     ??XDMAC_SetSourceAddr_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806060         STR      R6,[R0, #+96]
    411          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    412          
    413          /**
    414           * \brief Set destination address for the relevant channel of given XDMA.
    415           *
    416           * \param pXdmac Pointer to the XDMAC peripheral.
    417           * \param channel Particular channel number.
    418           * \param addr Destination address.
    419           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    420          void
    421          XDMAC_SetDestinationAddr(Xdmac * pXdmac, uint8_t channel, uint32_t addr)
    422          {
   \                     XDMAC_SetDestinationAddr:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    423          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetDestinationAddr_0
   \   00000018   0xE30021A7         MOVW     R2,#+423
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    424          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetDestinationAddr_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetDestinationAddr_1
   \   0000003C   0xE3A02F6A         MOV      R2,#+424
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    425          	pXdmac->XDMAC_CHID[channel].XDMAC_CDA = addr;
   \                     ??XDMAC_SetDestinationAddr_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806064         STR      R6,[R0, #+100]
    426          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    427          
    428          /**
    429           * \brief Set next descriptor's address & interface for the relevant channel of given XDMA.
    430           *
    431           * \param pXdmac Pointer to the XDMAC peripheral.
    432           * \param channel Particular channel number.
    433           * \param addr Address of next descriptor.
    434           * \param ndaif Interface of next descriptor.
    435           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    436          void
    437          XDMAC_SetDescriptorAddr(Xdmac * pXdmac, uint8_t channel, uint32_t addr,
    438          			uint32_t ndaif)
    439          {
   \                     XDMAC_SetDescriptorAddr:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    440          	assert(pXdmac);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000004         BNE      ??XDMAC_SetDescriptorAddr_0
   \   0000001C   0xE3A02F6E         MOV      R2,#+440
   \   00000020   0x........         LDR      R1,??DataTable36
   \   00000024   0x........         LDR      R0,??DataTable36_1
   \   00000028   0x........         BL       __aeabi_assert
   \   0000002C   0x........         BL       __iar_EmptyStepPoint
    441          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetDescriptorAddr_0:
   \   00000030   0xE1B00005         MOVS     R0,R5
   \   00000034   0xE6EF0070         UXTB     R0,R0
   \   00000038   0xE3500010         CMP      R0,#+16
   \   0000003C   0xBA000004         BLT      ??XDMAC_SetDescriptorAddr_1
   \   00000040   0xE30021B9         MOVW     R2,#+441
   \   00000044   0x........         LDR      R1,??DataTable36
   \   00000048   0x........         LDR      R0,??DataTable36_2
   \   0000004C   0x........         BL       __aeabi_assert
   \   00000050   0x........         BL       __iar_EmptyStepPoint
    442          	pXdmac->XDMAC_CHID[channel].XDMAC_CNDA = (addr & 0xFFFFFFFC) | ndaif;
   \                     ??XDMAC_SetDescriptorAddr_1:
   \   00000054   0xE1B00126         LSRS     R0,R6,#+2
   \   00000058   0xE1970100         ORRS     R0,R7,R0, LSL #+2
   \   0000005C   0xE1B01005         MOVS     R1,R5
   \   00000060   0xE6EF1071         UXTB     R1,R1
   \   00000064   0xE1B01301         LSLS     R1,R1,#+6
   \   00000068   0xE0911004         ADDS     R1,R1,R4
   \   0000006C   0xE5810068         STR      R0,[R1, #+104]
    443          }
   \   00000070   0xE8BD80F1         POP      {R0,R4-R7,PC}    ;; return
    444          
    445          /**
    446           * \brief Set next descriptor's configuration for the relevant channel of given XDMA.
    447           *
    448           * \param pXdmac Pointer to the XDMAC peripheral.
    449           * \param channel Particular channel number.
    450           * \param config Configuration of next descriptor.
    451           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    452          void
    453          XDMAC_SetDescriptorControl(Xdmac * pXdmac, uint8_t channel, uint32_t config)
    454          {
   \                     XDMAC_SetDescriptorControl:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    455          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetDescriptorControl_0
   \   00000018   0xE30021C7         MOVW     R2,#+455
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    456          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetDescriptorControl_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetDescriptorControl_1
   \   0000003C   0xE3A02F72         MOV      R2,#+456
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    457          	pXdmac->XDMAC_CHID[channel].XDMAC_CNDC = config;
   \                     ??XDMAC_SetDescriptorControl_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE580606C         STR      R6,[R0, #+108]
    458          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    459          
    460          /**
    461           * \brief Set microblock length for the relevant channel of given XDMA.
    462           *
    463           * \param pXdmac Pointer to the XDMAC peripheral.
    464           * \param channel Particular channel number.
    465           * \param ublen Microblock length.
    466           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    467          void
    468          XDMAC_SetMicroblockControl(Xdmac * pXdmac, uint8_t channel, uint32_t ublen)
    469          {
   \                     XDMAC_SetMicroblockControl:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    470          
    471          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetMicroblockControl_0
   \   00000018   0xE30021D7         MOVW     R2,#+471
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    472          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetMicroblockControl_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetMicroblockControl_1
   \   0000003C   0xE3A02F76         MOV      R2,#+472
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    473          	pXdmac->XDMAC_CHID[channel].XDMAC_CUBC = ublen;
   \                     ??XDMAC_SetMicroblockControl_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806070         STR      R6,[R0, #+112]
    474          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    475          
    476          /**
    477           * \brief Set block length for the relevant channel of given XDMA.
    478           *
    479           * \param pXdmac Pointer to the XDMAC peripheral.
    480           * \param channel Particular channel number.
    481           * \param blen Block length.
    482           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    483          void
    484          XDMAC_SetBlockControl(Xdmac * pXdmac, uint8_t channel, uint32_t blen)
    485          {
   \                     XDMAC_SetBlockControl:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    486          
    487          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetBlockControl_0
   \   00000018   0xE30021E7         MOVW     R2,#+487
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    488          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetBlockControl_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetBlockControl_1
   \   0000003C   0xE3A02F7A         MOV      R2,#+488
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    489          	pXdmac->XDMAC_CHID[channel].XDMAC_CBC = blen;
   \                     ??XDMAC_SetBlockControl_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806074         STR      R6,[R0, #+116]
    490          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    491          
    492          /**
    493           * \brief Set configuration for the relevant channel of given XDMA.
    494           *
    495           * \param pXdmac Pointer to the XDMAC peripheral.
    496           * \param channel Particular channel number.
    497           * \param config Channel configuration.
    498           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    499          void
    500          XDMAC_SetChannelConfig(Xdmac * pXdmac, uint8_t channel, uint32_t config)
    501          {
   \                     XDMAC_SetChannelConfig:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    502          
    503          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetChannelConfig_0
   \   00000018   0xE30021F7         MOVW     R2,#+503
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    504          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetChannelConfig_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetChannelConfig_1
   \   0000003C   0xE3A02F7E         MOV      R2,#+504
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    505          	pXdmac->XDMAC_CHID[channel].XDMAC_CC = config;
   \                     ??XDMAC_SetChannelConfig_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806078         STR      R6,[R0, #+120]
    506          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    507          
    508          /**
    509           * \brief Get the relevant channel's configuration of given XDMA.
    510           *
    511           * \param pXdmac Pointer to the XDMAC peripheral.
    512           * \param channel Particular channel number.
    513           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    514          uint32_t
    515          XDMAC_GetChannelConfig(Xdmac * pXdmac, uint8_t channel)
    516          {
   \                     XDMAC_GetChannelConfig:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    517          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_GetChannelConfig_0
   \   00000014   0xE3002205         MOVW     R2,#+517
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    518          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_GetChannelConfig_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_GetChannelConfig_1
   \   00000038   0xE3002206         MOVW     R2,#+518
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    519          	return pXdmac->XDMAC_CHID[channel].XDMAC_CC;
   \                     ??XDMAC_GetChannelConfig_1:
   \   0000004C   0xE6EF5075         UXTB     R5,R5
   \   00000050   0xE1B00305         LSLS     R0,R5,#+6
   \   00000054   0xE0900004         ADDS     R0,R0,R4
   \   00000058   0xE5900078         LDR      R0,[R0, #+120]
   \   0000005C   0xE8BD8032         POP      {R1,R4,R5,PC}    ;; return
    520          }
    521          
    522          /**
    523           * \brief Set the relevant channel's data stride memory pattern of given XDMA.
    524           *
    525           * \param pXdmac Pointer to the XDMAC peripheral.
    526           * \param channel Particular channel number.
    527           * \param dds_msp Data stride memory pattern.
    528           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    529          void
    530          XDMAC_SetDataStride_MemPattern(Xdmac * pXdmac, uint8_t channel,
    531          			       uint32_t dds_msp)
    532          {
   \                     XDMAC_SetDataStride_MemPattern:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    533          
    534          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetDataStride_MemPattern_0
   \   00000018   0xE3002216         MOVW     R2,#+534
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    535          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetDataStride_MemPattern_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetDataStride_MemPattern_1
   \   0000003C   0xE3002217         MOVW     R2,#+535
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    536          	pXdmac->XDMAC_CHID[channel].XDMAC_CDS_MSP = dds_msp;
   \                     ??XDMAC_SetDataStride_MemPattern_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE580607C         STR      R6,[R0, #+124]
    537          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    538          
    539          /**
    540           * \brief Set the relevant channel's source microblock stride of given XDMA.
    541           *
    542           * \param pXdmac Pointer to the XDMAC peripheral.
    543           * \param channel Particular channel number.
    544           * \param subs Source microblock stride.
    545           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    546          void
    547          XDMAC_SetSourceMicroBlockStride(Xdmac * pXdmac, uint8_t channel, uint32_t subs)
    548          {
   \                     XDMAC_SetSourceMicroBlockStride:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    549          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetSourceMicroBlockStride_0
   \   00000018   0xE3002225         MOVW     R2,#+549
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    550          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetSourceMicroBlockStride_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetSourceMicroBlockStride_1
   \   0000003C   0xE3002226         MOVW     R2,#+550
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    551          	pXdmac->XDMAC_CHID[channel].XDMAC_CSUS = subs;
   \                     ??XDMAC_SetSourceMicroBlockStride_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806080         STR      R6,[R0, #+128]
    552          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    553          
    554          /**
    555           * \brief Set the relevant channel's destination microblock stride of given XDMA.
    556           *
    557           * \param pXdmac Pointer to the XDMAC peripheral.
    558           * \param channel Particular channel number.
    559           * \param dubs Destination microblock stride.
    560           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    561          void
    562          XDMAC_SetDestinationMicroBlockStride(Xdmac * pXdmac, uint8_t channel,
    563          				     uint32_t dubs)
    564          {
   \                     XDMAC_SetDestinationMicroBlockStride:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    565          	assert(pXdmac);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000004         BNE      ??XDMAC_SetDestinationMicroBlockStride_0
   \   00000018   0xE3002235         MOVW     R2,#+565
   \   0000001C   0x........         LDR      R1,??DataTable36
   \   00000020   0x........         LDR      R0,??DataTable36_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    566          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_SetDestinationMicroBlockStride_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500010         CMP      R0,#+16
   \   00000038   0xBA000004         BLT      ??XDMAC_SetDestinationMicroBlockStride_1
   \   0000003C   0xE3002236         MOVW     R2,#+566
   \   00000040   0x........         LDR      R1,??DataTable36
   \   00000044   0x........         LDR      R0,??DataTable36_2
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    567          	pXdmac->XDMAC_CHID[channel].XDMAC_CDUS = dubs;
   \                     ??XDMAC_SetDestinationMicroBlockStride_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE1B00300         LSLS     R0,R0,#+6
   \   0000005C   0xE0900004         ADDS     R0,R0,R4
   \   00000060   0xE5806084         STR      R6,[R0, #+132]
    568          }
   \   00000064   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    569          
    570          /**
    571           * \brief Get the relevant channel's destination address of given XDMA.
    572           *
    573           * \param pXdmac Pointer to the XDMAC peripheral.
    574           * \param channel Particular channel number.
    575           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    576          uint32_t
    577          XDMAC_GetChDestinationAddr(Xdmac * pXdmac, uint8_t channel)
    578          {
   \                     XDMAC_GetChDestinationAddr:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    579          	assert(pXdmac);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAC_GetChDestinationAddr_0
   \   00000014   0xE3002243         MOVW     R2,#+579
   \   00000018   0x........         LDR      R1,??DataTable36
   \   0000001C   0x........         LDR      R0,??DataTable36_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    580          	assert(channel < XDMAC_CHANNEL_NUM);
   \                     ??XDMAC_GetChDestinationAddr_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE3500010         CMP      R0,#+16
   \   00000034   0xBA000004         BLT      ??XDMAC_GetChDestinationAddr_1
   \   00000038   0xE3A02F91         MOV      R2,#+580
   \   0000003C   0x........         LDR      R1,??DataTable36
   \   00000040   0x........         LDR      R0,??DataTable36_2
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    581          	return pXdmac->XDMAC_CHID[channel].XDMAC_CDA;
   \                     ??XDMAC_GetChDestinationAddr_1:
   \   0000004C   0xE6EF5075         UXTB     R5,R5
   \   00000050   0xE1B00305         LSLS     R0,R5,#+6
   \   00000054   0xE0900004         ADDS     R0,R0,R4
   \   00000058   0xE5900064         LDR      R0,[R0, #+100]
   \   0000005C   0xE8BD8032         POP      {R1,R4,R5,PC}    ;; return
    582          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable36_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable36_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x70 0x58          DC8 "pXdmac"
   \              0x64 0x6D    
   \              0x61 0x63    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 62H, 75H, 73H, 5CH
   \              0x73 0x5C    
   \              0x62 0x75    
   \              0x73 0x5C    
   \   00000038   0x78 0x64          DC8 78H, 64H, 6DH, 61H, 63H, 2EH, 63H, 0
   \              0x6D 0x61    
   \              0x63 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x63 0x68          DC8 "channel < XDMAC_CHANNEL_NUM"
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x3C 0x20    
   \              0x58 0x44    
   \              0x4D 0x41    
   \              0x43 0x5F    
   \              0x43 0x48    
   \              0x41 0x4E    
   \              0x4E 0x45    
   \              0x4C 0x5F    
   \              0x4E 0x55    
   \              0x4D 0x00    
    583          
    584          /**@}*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   XDMAC_DisableChannel
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_DisableChannelIt
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_DisableChannels
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_DisableGIt
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_EnableChannel
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_EnableChannelIt
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_EnableChannels
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_EnableGIt
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   XDMAC_GetArbiter
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   XDMAC_GetChDestinationAddr
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_GetChannelConfig
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_GetChannelIsr
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_GetChannelItMask
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   XDMAC_GetConfig
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   XDMAC_GetGIsr
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   XDMAC_GetGItMask
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   XDMAC_GetGlobalChStatus
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   XDMAC_GetMaskChannelIsr
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_GetMaskedGIsr
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   XDMAC_GetSoftwareTransferStatus
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   XDMAC_GetType
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   XDMAC_ResumeReadWriteChannel
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SetBlockControl
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SetChannelConfig
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SetDataStride_MemPattern
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   XDMAC_SetDescriptorAddr
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      16   XDMAC_SetDescriptorControl
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SetDestinationAddr
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SetDestinationMicroBlockStride
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SetMicroblockControl
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SetSourceAddr
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SetSourceMicroBlockStride
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SoftwareFlushReq
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SoftwareTransferReq
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SuspendReadChannel
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SuspendReadWriteChannel
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   XDMAC_SuspendWriteChannel
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_2
       8  ?_0
      64  ?_1
      28  ?_2
      96  XDMAC_DisableChannel
     104  XDMAC_DisableChannelIt
      56  XDMAC_DisableChannels
      48  XDMAC_DisableGIt
      96  XDMAC_EnableChannel
     104  XDMAC_EnableChannelIt
      56  XDMAC_EnableChannels
      48  XDMAC_EnableGIt
      44  XDMAC_GetArbiter
      96  XDMAC_GetChDestinationAddr
      96  XDMAC_GetChannelConfig
      96  XDMAC_GetChannelIsr
      96  XDMAC_GetChannelItMask
      44  XDMAC_GetConfig
      44  XDMAC_GetGIsr
      44  XDMAC_GetGItMask
      44  XDMAC_GetGlobalChStatus
     132  XDMAC_GetMaskChannelIsr
      60  XDMAC_GetMaskedGIsr
      44  XDMAC_GetSoftwareTransferStatus
      44  XDMAC_GetType
      96  XDMAC_ResumeReadWriteChannel
     104  XDMAC_SetBlockControl
     104  XDMAC_SetChannelConfig
     104  XDMAC_SetDataStride_MemPattern
     116  XDMAC_SetDescriptorAddr
     104  XDMAC_SetDescriptorControl
     104  XDMAC_SetDestinationAddr
     104  XDMAC_SetDestinationMicroBlockStride
     104  XDMAC_SetMicroblockControl
     104  XDMAC_SetSourceAddr
     104  XDMAC_SetSourceMicroBlockStride
      96  XDMAC_SoftwareFlushReq
      96  XDMAC_SoftwareTransferReq
      96  XDMAC_SuspendReadChannel
      96  XDMAC_SuspendReadWriteChannel
      96  XDMAC_SuspendWriteChannel
      16  _id_h64_matrix

 
   116 bytes in section .rodata
 3 132 bytes in section SOFTPACK
 
 3 132 bytes of CODE  memory
   116 bytes of CONST memory

Errors: none
Warnings: 1
