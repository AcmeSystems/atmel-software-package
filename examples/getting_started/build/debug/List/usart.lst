###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:08
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\serial\usart.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\serial\usart.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\usart.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\usart.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\serial\usart.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup usart_module Working with USART
     31           * \section Purpose
     32           * The USART driver provides the interface to configure and use the USART peripheral.\n
     33           *
     34           * The USART supports several kinds of communication modes such as full-duplex asynchronous/
     35           * synchronous serial communication,RS485 with driver control signal,ISO7816,SPI and Test modes.
     36           *
     37           * To start a USART transfer with \ref dmad_module "DMA" support, the user could follow these steps:
     38           * <ul>
     39           * <li> Configure USART with expected mode and baudrate(see \ref usart_configure), which could be done by:
     40           * -# Resetting and disabling transmitter and receiver by setting US_CR(Control Register). </li>
     41           * -# Configuring the USART in a specific mode by setting USART_MODE bits in US_MR(Mode Register) </li>
     42           * -# Setting baudrate which is different from mode to mode.
     43             </li>
     44           * <li> Enable transmitter or receiver respectively by set US_CR_TXEN or US_CR_RXEN in US_CR.</li>
     45           * <li> Read from or write to the peripheral with  \ref dmad_module </li>
     46           * </ul>
     47           *
     48           * \section Usage
     49           * <ul>
     50           * <li>  Enable or disable USART transmitter or receiver using
     51           * usart_set_transmitter_enabled() and usart_set_receiver_enabled().
     52           * <li>  Enable or disable USART interrupt using usart_enable_it() or usart_disable_it().
     53           * </li>
     54           * </ul>
     55           *
     56           * For more accurate information, please look at the USART section of the
     57           * Datasheet.
     58           *
     59           * Related files :\n
     60           * \ref usart.c\n
     61           * \ref usart.h\n
     62          */
     63          
     64          /**
     65           * \file
     66           *
     67           * Implementation of USART (Universal Synchronous Asynchronous Receiver Transmitter)
     68           * controller.
     69           *
     70           */
     71          /*-----------------------------------------------------------------------------
     72          *         Headers
     73           *---------------------------------------------------------------------------*/
     74          
     75          #include "chip.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void writeb(void volatile *, uint8_t)
   \                     writeb:
   \   00000000   0xE5C01000         STRB     R1,[R0, #+0]
   \   00000004   0xE12FFF1E         BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void readb(void const volatile *, uint8_t *)
   \                     readb:
   \   00000000   0xE5D02000         LDRB     R2,[R0, #+0]
   \   00000004   0xE5C12000         STRB     R2,[R1, #+0]
   \   00000008   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp uint32_t get_usart_id_from_addr(Usart const *)
   \                     get_usart_id_from_addr:
   \   00000000   0xE1B01000         MOVS     R1,R0
   \   00000004   0x........         LDR      R0,??DataTable3  ;; 0xf8034200
   \   00000008   0xE1510000         CMP      R1,R0
   \   0000000C   0x1A000001         BNE      ??get_usart_id_from_addr_0
   \   00000010   0xE3A00013         MOV      R0,#+19
   \   00000014   0xEA000014         B        ??get_usart_id_from_addr_1
   \                     ??get_usart_id_from_addr_0:
   \   00000018   0x........         LDR      R0,??DataTable3_1  ;; 0xf8038200
   \   0000001C   0xE1510000         CMP      R1,R0
   \   00000020   0x1A000001         BNE      ??get_usart_id_from_addr_2
   \   00000024   0xE3A00014         MOV      R0,#+20
   \   00000028   0xEA00000F         B        ??get_usart_id_from_addr_1
   \                     ??get_usart_id_from_addr_2:
   \   0000002C   0x........         LDR      R0,??DataTable3_2  ;; 0xfc010200
   \   00000030   0xE1510000         CMP      R1,R0
   \   00000034   0x1A000001         BNE      ??get_usart_id_from_addr_3
   \   00000038   0xE3A00015         MOV      R0,#+21
   \   0000003C   0xEA00000A         B        ??get_usart_id_from_addr_1
   \                     ??get_usart_id_from_addr_3:
   \   00000040   0x........         LDR      R0,??DataTable3_3  ;; 0xfc014200
   \   00000044   0xE1510000         CMP      R1,R0
   \   00000048   0x1A000001         BNE      ??get_usart_id_from_addr_4
   \   0000004C   0xE3A00016         MOV      R0,#+22
   \   00000050   0xEA000005         B        ??get_usart_id_from_addr_1
   \                     ??get_usart_id_from_addr_4:
   \   00000054   0x........         LDR      R0,??DataTable3_4  ;; 0xfc018200
   \   00000058   0xE1510000         CMP      R1,R0
   \   0000005C   0x1A000001         BNE      ??get_usart_id_from_addr_5
   \   00000060   0xE3A00017         MOV      R0,#+23
   \   00000064   0xEA000000         B        ??get_usart_id_from_addr_1
   \                     ??get_usart_id_from_addr_5:
   \   00000068   0xE3A0004F         MOV      R0,#+79
   \                     ??get_usart_id_from_addr_1:
   \   0000006C   0xE12FFF1E         BX       LR               ;; return
     76          #include "resources/compiler_defines.h"
     77          #include "serial/usart.h"
     78          #include "core/pmc.h"
     79          
     80          #include "utils/trace.h"
     81          
     82          #include <assert.h>
     83          #include <string.h>
     84          
     85          #ifdef FIFO_ENABLED
     86          /* Clear FIFO related register if present. Dummy function otherwise. */
     87          static inline void _clear_fifo_control_flags(uint32_t* control_reg)
     88          {
     89          	*control_reg |= US_CR_FIFODIS | US_CR_TXFCLR | US_CR_RXFCLR | US_CR_TXFLCLR;
     90          }
     91          #else
     92          #define _clear_fifo_control_flags(dummy) do {} while(0)
     93          #endif
     94          /*----------------------------------------------------------------------------
     95           *         Exported functions
     96           *----------------------------------------------------------------------------*/
     97          
     98          /**
     99           * \brief Configures an USART peripheral with the specified parameters.
    100           *  \param usart  Pointer to the USART peripheral to configure.
    101           *  \param mode  Desired value for the USART mode register (see the datasheet).
    102           *  \param baudrate  Baudrate at which the USART should operate (in Hz).
    103           *  \param clock  Frequency of the system master clock (in Hz).
    104           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    105          void usart_configure(Usart *usart, uint32_t mode,
    106          		     uint32_t baudrate)
    107          {
   \                     usart_configure:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    108          	uint32_t clock = pmc_get_peripheral_max_clock(get_usart_id_from_addr(usart));
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0x........         BL       get_usart_id_from_addr
   \   00000018   0x........         BL       pmc_get_peripheral_max_clock
   \   0000001C   0xE1B07000         MOVS     R7,R0
    109          	/* Reset and disable receiver & transmitter */
    110          	uint32_t control = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS;
   \   00000020   0xE3A080AC         MOV      R8,#+172
    111          	/* Reset and disable FIFO if present */
    112          	_clear_fifo_control_flags(&control);
    113          	/* apply */
    114          	usart->US_CR = control;
   \   00000024   0xE5848000         STR      R8,[R4, #+0]
    115          	/* Configure mode */
    116          	usart->US_MR = mode;
   \   00000028   0xE5845004         STR      R5,[R4, #+4]
    117          
    118          	/* Configure baudrate */
    119          	/* Asynchronous, no oversampling */
    120          	if (((mode & US_MR_SYNC) == 0)
    121          	    && ((mode & US_MR_OVER) == 0)) {
   \   0000002C   0xE3A00A80         MOV      R0,#+524288
   \   00000030   0xE3800F40         ORR      R0,R0,#0x100
   \   00000034   0xE1100005         TST      R0,R5
   \   00000038   0x1A000004         BNE      ??usart_configure_0
    122          		usart->US_BRGR = (clock / baudrate) / 16;
   \   0000003C   0xE1B00007         MOVS     R0,R7
   \   00000040   0xE1B01006         MOVS     R1,R6
   \   00000044   0x........         BL       __aeabi_uidiv
   \   00000048   0xE1B00220         LSRS     R0,R0,#+4
   \   0000004C   0xE5840020         STR      R0,[R4, #+32]
    123          	}
    124          	if (((mode & US_MR_USART_MODE_SPI_MASTER) ==
    125          	     US_MR_USART_MODE_SPI_MASTER) || ((mode & US_MR_SYNC) == US_MR_SYNC)) {
   \                     ??usart_configure_0:
   \   00000050   0xE215000E         ANDS     R0,R5,#0xE
   \   00000054   0xE350000E         CMP      R0,#+14
   \   00000058   0x0A000001         BEQ      ??usart_configure_1
   \   0000005C   0xE3150F40         TST      R5,#0x100
   \   00000060   0x0A00000D         BEQ      ??usart_configure_2
    126          		if ((mode & US_MR_USCLKS_Msk) == US_MR_USCLKS_MCK) {
   \                     ??usart_configure_1:
   \   00000064   0xE3150030         TST      R5,#0x30
   \   00000068   0x1A000004         BNE      ??usart_configure_3
    127          			usart->US_BRGR = clock / baudrate;
   \   0000006C   0xE1B00007         MOVS     R0,R7
   \   00000070   0xE1B01006         MOVS     R1,R6
   \   00000074   0x........         BL       __aeabi_uidiv
   \   00000078   0xE5840020         STR      R0,[R4, #+32]
   \   0000007C   0xEA000006         B        ??usart_configure_2
    128          		} else {
    129          			if ((mode & US_MR_USCLKS_DIV) == US_MR_USCLKS_DIV) {
   \                     ??usart_configure_3:
   \   00000080   0xE3150010         TST      R5,#0x10
   \   00000084   0x0A000004         BEQ      ??usart_configure_2
    130          				usart->US_BRGR = clock / baudrate / 8;
   \   00000088   0xE1B00007         MOVS     R0,R7
   \   0000008C   0xE1B01006         MOVS     R1,R6
   \   00000090   0x........         BL       __aeabi_uidiv
   \   00000094   0xE1B001A0         LSRS     R0,R0,#+3
   \   00000098   0xE5840020         STR      R0,[R4, #+32]
    131          			}
    132          		}
    133          	}
    134          	/* TODO other modes */
    135          
    136          	/* Disable all interrupts */
    137          	usart->US_IDR = 0xFFFFFFFF;
   \                     ??usart_configure_2:
   \   0000009C   0xE3E00000         MVN      R0,#+0
   \   000000A0   0xE584000C         STR      R0,[R4, #+12]
    138          
    139          	/* Enable receiver and transmitter */
    140          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
   \   000000A4   0xE3A00050         MOV      R0,#+80
   \   000000A8   0xE5840000         STR      R0,[R4, #+0]
    141          }
   \   000000AC   0xE8BD81F0         POP      {R4-R8,PC}       ;; return
    142          
    143          /**
    144           * \brief   Get present status
    145           * \param usart  Pointer to an USART peripheral.
    146           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    147          uint32_t usart_get_status(Usart *usart)
    148          {
    149          	return usart->US_CSR;
   \                     usart_get_status:
   \   00000000   0xE5900014         LDR      R0,[R0, #+20]
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    150          }
    151          
    152          /**
    153           * \brief   Enable interrupt
    154           * \param usart  Pointer to an USART peripheral.
    155           * \param mode  Interrupt mode.
    156           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    157          void usart_enable_it(Usart *usart, uint32_t mode)
    158          {
    159          	usart->US_IER = mode;
   \                     usart_enable_it:
   \   00000000   0xE5801008         STR      R1,[R0, #+8]
    160          }
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    161          
    162          /**
    163           * \brief   Disable interrupt
    164           * \param usart  Pointer to an USART peripheral.
    165           * \param mode  Interrupt mode.
    166           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    167          void usart_disable_it(Usart *usart, uint32_t mode)
    168          {
    169          	usart->US_IDR = mode;
   \                     usart_disable_it:
   \   00000000   0xE580100C         STR      R1,[R0, #+12]
    170          }
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    171          
    172          /**
    173           * \brief   Return interrupt mask
    174           * \param usart  Pointer to an USART peripheral.
    175           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    176          uint32_t usart_get_it_mask(Usart *usart)
    177          {
    178          	return usart->US_IMR;
   \                     usart_get_it_mask:
   \   00000000   0xE5900010         LDR      R0,[R0, #+16]
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    179          }
    180          
    181          /**
    182           * \brief Enables or disables the transmitter of an USART peripheral.
    183           * \param usart  Pointer to an USART peripheral
    184           * \param enabled  If true, the transmitter is enabled; otherwise it is
    185           *                disabled.
    186           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    187          void usart_set_transmitter_enabled(Usart *usart, uint8_t enabled)
    188          {
    189          	if (enabled) {
   \                     usart_set_transmitter_enabled:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE3520000         CMP      R2,#+0
   \   0000000C   0x0A000002         BEQ      ??usart_set_transmitter_enabled_0
    190          		usart->US_CR = US_CR_TXEN;
   \   00000010   0xE3A02040         MOV      R2,#+64
   \   00000014   0xE5802000         STR      R2,[R0, #+0]
   \   00000018   0xEA000001         B        ??usart_set_transmitter_enabled_1
    191          	} else {
    192          		usart->US_CR = US_CR_TXDIS;
   \                     ??usart_set_transmitter_enabled_0:
   \   0000001C   0xE3A02080         MOV      R2,#+128
   \   00000020   0xE5802000         STR      R2,[R0, #+0]
    193          	}
    194          }
   \                     ??usart_set_transmitter_enabled_1:
   \   00000024   0xE12FFF1E         BX       LR               ;; return
    195          
    196          /**
    197           * \brief Enables or disables the receiver of an USART peripheral
    198           * \param usart  Pointer to an USART peripheral
    199           * \param enabled  If true, the receiver is enabled; otherwise it is disabled.
    200           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    201          void usart_set_receiver_enabled(Usart *usart, uint8_t enabled)
    202          {
    203          	if (enabled) {
   \                     usart_set_receiver_enabled:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE3520000         CMP      R2,#+0
   \   0000000C   0x0A000002         BEQ      ??usart_set_receiver_enabled_0
    204          		usart->US_CR = US_CR_RXEN;
   \   00000010   0xE3A02010         MOV      R2,#+16
   \   00000014   0xE5802000         STR      R2,[R0, #+0]
   \   00000018   0xEA000001         B        ??usart_set_receiver_enabled_1
    205          	} else {
    206          		usart->US_CR = US_CR_RXDIS;
   \                     ??usart_set_receiver_enabled_0:
   \   0000001C   0xE3A02020         MOV      R2,#+32
   \   00000020   0xE5802000         STR      R2,[R0, #+0]
    207          	}
    208          }
   \                     ??usart_set_receiver_enabled_1:
   \   00000024   0xE12FFF1E         BX       LR               ;; return
    209          
    210          /**
    211           * \brief Enables or disables the Request To Send (RTS) of an USART peripheral
    212           * \param usart  Pointer to an USART peripheral
    213           * \param enabled  If true, the RTS is enabled (0); otherwise it is disabled.
    214           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    215          void usart_set_rts_enabled(Usart *usart, uint8_t enabled)
    216          {
    217          	if (enabled) {
   \                     usart_set_rts_enabled:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE3520000         CMP      R2,#+0
   \   0000000C   0x0A000002         BEQ      ??usart_set_rts_enabled_0
    218          		usart->US_CR = US_CR_RTSEN;
   \   00000010   0xE3A02A40         MOV      R2,#+262144
   \   00000014   0xE5802000         STR      R2,[R0, #+0]
   \   00000018   0xEA000001         B        ??usart_set_rts_enabled_1
    219          	} else {
    220          		usart->US_CR = US_CR_RTSDIS;
   \                     ??usart_set_rts_enabled_0:
   \   0000001C   0xE3A02A80         MOV      R2,#+524288
   \   00000020   0xE5802000         STR      R2,[R0, #+0]
    221          	}
    222          }
   \                     ??usart_set_rts_enabled_1:
   \   00000024   0xE12FFF1E         BX       LR               ;; return
    223          
    224          /**
    225           * \brief Sends one packet of data through the specified USART peripheral. This
    226           * function operates synchronously, so it only returns when the data has been
    227           * actually sent.
    228           * \param usart  Pointer to an USART peripheral.
    229           * \param data  Data to send including 9nth bit and sync field if necessary (in
    230           *        the same format as the US_THR register in the datasheet).
    231           * \param timeOut  Time out value (0 = no timeout).
    232           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    233          void usart_write(Usart *usart, uint16_t data, volatile uint32_t timeOut)
    234          {
   \                     usart_write:
   \   00000000   0xE92D4034         PUSH     {R2,R4,R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    235          	if (timeOut == 0) {
   \   0000000C   0xE59D0000         LDR      R0,[SP, #+0]
   \   00000010   0xE3500000         CMP      R0,#+0
   \   00000014   0x1A000003         BNE      ??usart_write_0
    236          		while ((usart->US_CSR & US_CSR_TXRDY) == 0) ;
   \                     ??usart_write_1:
   \   00000018   0xE5940014         LDR      R0,[R4, #+20]
   \   0000001C   0xE3100002         TST      R0,#0x2
   \   00000020   0x1A00000D         BNE      ??usart_write_2
   \   00000024   0xEAFFFFFB         B        ??usart_write_1
    237          	} else {
    238          		while ((usart->US_CSR & US_CSR_TXRDY) == 0) {
   \                     ??usart_write_0:
   \   00000028   0xE5940014         LDR      R0,[R4, #+20]
   \   0000002C   0xE3100002         TST      R0,#0x2
   \   00000030   0x1A000009         BNE      ??usart_write_2
    239          			if (timeOut == 0) {
   \   00000034   0xE59D0000         LDR      R0,[SP, #+0]
   \   00000038   0xE3500000         CMP      R0,#+0
   \   0000003C   0x1A000002         BNE      ??usart_write_3
    240          				TRACE_ERROR("usart_write: Timed out.\n\r");
   \   00000040   0x........         LDR      R0,??DataTable3_5
   \   00000044   0x........         BL       printf
    241          				return;
   \   00000048   0xEA000006         B        ??usart_write_4
    242          			}
    243          			timeOut--;
   \                     ??usart_write_3:
   \   0000004C   0xE59D0000         LDR      R0,[SP, #+0]
   \   00000050   0xE2500001         SUBS     R0,R0,#+1
   \   00000054   0xE58D0000         STR      R0,[SP, #+0]
   \   00000058   0xEAFFFFF2         B        ??usart_write_0
    244          		}
    245          	}
    246          	usart->US_THR = data;
   \                     ??usart_write_2:
   \   0000005C   0xE1B00005         MOVS     R0,R5
   \   00000060   0xE6FF0070         UXTH     R0,R0
   \   00000064   0xE584001C         STR      R0,[R4, #+28]
    247          }
   \                     ??usart_write_4:
   \   00000068   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    248          
    249          /**
    250           * \brief  Reads and return a packet of data on the specified USART peripheral. This
    251           * function operates asynchronously, so it waits until some data has been
    252           * received.
    253           * \param usart  Pointer to an USART peripheral.
    254           * \param timeOut  Time out value (0 -> no timeout).
    255           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    256          uint16_t usart_read(Usart *usart, volatile uint32_t timeOut)
    257          {
   \                     usart_read:
   \   00000000   0xE92D4013         PUSH     {R0,R1,R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    258          	if (timeOut == 0) {
   \   00000008   0xE59D0004         LDR      R0,[SP, #+4]
   \   0000000C   0xE3500000         CMP      R0,#+0
   \   00000010   0x1A000003         BNE      ??usart_read_0
    259          		while ((usart->US_CSR & US_CSR_RXRDY) == 0) ;
   \                     ??usart_read_1:
   \   00000014   0xE5940014         LDR      R0,[R4, #+20]
   \   00000018   0xE3100001         TST      R0,#0x1
   \   0000001C   0x1A00000E         BNE      ??usart_read_2
   \   00000020   0xEAFFFFFB         B        ??usart_read_1
    260          	} else {
    261          		while ((usart->US_CSR & US_CSR_RXRDY) == 0) {
   \                     ??usart_read_0:
   \   00000024   0xE5940014         LDR      R0,[R4, #+20]
   \   00000028   0xE3100001         TST      R0,#0x1
   \   0000002C   0x1A00000A         BNE      ??usart_read_2
    262          			if (timeOut == 0) {
   \   00000030   0xE59D0004         LDR      R0,[SP, #+4]
   \   00000034   0xE3500000         CMP      R0,#+0
   \   00000038   0x1A000003         BNE      ??usart_read_3
    263          				TRACE_ERROR("usart_read: Timed out.\n\r");
   \   0000003C   0x........         LDR      R0,??DataTable3_6
   \   00000040   0x........         BL       printf
    264          				return 0;
   \   00000044   0xE3A00000         MOV      R0,#+0
   \   00000048   0xEA000005         B        ??usart_read_4
    265          			}
    266          			timeOut--;
   \                     ??usart_read_3:
   \   0000004C   0xE59D0004         LDR      R0,[SP, #+4]
   \   00000050   0xE2500001         SUBS     R0,R0,#+1
   \   00000054   0xE58D0004         STR      R0,[SP, #+4]
   \   00000058   0xEAFFFFF1         B        ??usart_read_0
    267          		}
    268          	}
    269          	return usart->US_RHR;
   \                     ??usart_read_2:
   \   0000005C   0xE5940018         LDR      R0,[R4, #+24]
   \   00000060   0xE6FF0070         UXTH     R0,R0
   \                     ??usart_read_4:
   \   00000064   0xE8BD8016         POP      {R1,R2,R4,PC}    ;; return
    270          }
    271          
    272          /**
    273           * \brief  Returns 1 if some data has been received and can be read from an USART;
    274           * otherwise returns 0.
    275           * \param usart  Pointer to an USART instance.
    276           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    277          uint8_t usart_is_data_available(Usart *usart)
    278          {
   \                     usart_is_data_available:
   \   00000000   0xE1B01000         MOVS     R1,R0
    279          	if ((usart->US_CSR & US_CSR_RXRDY) != 0) {
   \   00000004   0xE5910014         LDR      R0,[R1, #+20]
   \   00000008   0xE3100001         TST      R0,#0x1
   \   0000000C   0x0A000001         BEQ      ??usart_is_data_available_0
    280          		return 1;
   \   00000010   0xE3A00001         MOV      R0,#+1
   \   00000014   0xEA000000         B        ??usart_is_data_available_1
    281          	} else {
    282          		return 0;
   \                     ??usart_is_data_available_0:
   \   00000018   0xE3A00000         MOV      R0,#+0
   \                     ??usart_is_data_available_1:
   \   0000001C   0xE12FFF1E         BX       LR               ;; return
    283          	}
    284          }
    285          
    286          /**
    287           * \brief   Return 1 if a character can be read in USART
    288           * \param usart  Pointer to an USART peripheral.
    289           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    290          uint32_t usart_is_rx_ready(Usart *usart)
    291          {
    292          	return (usart->US_CSR & US_CSR_RXRDY);
   \                     usart_is_rx_ready:
   \   00000000   0xE5900014         LDR      R0,[R0, #+20]
   \   00000004   0xE2100001         ANDS     R0,R0,#0x1
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    293          }
    294          
    295          /**
    296           * \brief  Sends one packet of data through the specified USART peripheral. This
    297           * function operates synchronously, so it only returns when the data has been
    298           * actually sent.
    299           * \param usart  Pointer to an USART peripheral.
    300           * \param c  Character to send
    301           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    302          void usart_put_char(Usart *usart, uint8_t c)
    303          {
   \                     usart_put_char:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    304          	/* Wait for the transmitter to be ready */
    305          	while ((usart->US_CSR & US_CSR_TXEMPTY) == 0) ;
   \                     ??usart_put_char_0:
   \   0000000C   0xE5940014         LDR      R0,[R4, #+20]
   \   00000010   0xE3100F80         TST      R0,#0x200
   \   00000014   0x0AFFFFFC         BEQ      ??usart_put_char_0
    306          	/* Send character */
    307          	/* Force an octet write to avoid race conditions with FIFO mode */
    308          	writeb(&usart->US_THR, c);
   \   00000018   0xE1B01005         MOVS     R1,R5
   \   0000001C   0xE6EF1071         UXTB     R1,R1
   \   00000020   0xE294001C         ADDS     R0,R4,#+28
   \   00000024   0x........         BL       writeb
    309          }
   \   00000028   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    310          
    311          /**
    312           * \brief  Reads and returns a character from the USART.
    313           * \note This function is synchronous (i.e. uses polling).
    314           * \param usart  Pointer to an USART peripheral.
    315           * \return Character received.
    316           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    317          uint8_t usart_get_char(Usart *usart)
    318          {
   \                     usart_get_char:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE24DD008         SUB      SP,SP,#+8
   \   00000008   0xE1B04000         MOVS     R4,R0
    319          	while ((usart->US_CSR & US_CSR_RXRDY) == 0) ;
   \                     ??usart_get_char_0:
   \   0000000C   0xE5940014         LDR      R0,[R4, #+20]
   \   00000010   0xE3100001         TST      R0,#0x1
   \   00000014   0x0AFFFFFC         BEQ      ??usart_get_char_0
    320          	/* Force an octet read to avoid race conditions with FIFO mode */
    321          	uint8_t v;
    322          	readb(&usart->US_RHR, &v);
   \   00000018   0xE1B0100D         MOVS     R1,SP
   \   0000001C   0xE2940018         ADDS     R0,R4,#+24
   \   00000020   0x........         BL       readb
    323          	return v;
   \   00000024   0xE5DD0000         LDRB     R0,[SP, #+0]
   \   00000028   0xE8BD8016         POP      {R1,R2,R4,PC}    ;; return
    324          }
    325          
    326          /**
    327           * \brief  Sets the filter value for the IRDA demodulator.
    328           * \param usart  Pointer to an USART instance.
    329           * \param filter  Filter value.
    330           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    331          void usart_set_irda_filter(Usart *usart, uint8_t filter)
    332          {
   \                     usart_set_irda_filter:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    333          	assert(usart != NULL);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??usart_set_irda_filter_0
   \   00000014   0xE300214D         MOVW     R2,#+333
   \   00000018   0x........         LDR      R1,??DataTable3_7
   \   0000001C   0x........         LDR      R0,??DataTable3_8
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    334          
    335          	usart->US_IF = filter;
   \                     ??usart_set_irda_filter_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE584004C         STR      R0,[R4, #+76]
    336          }
   \   00000034   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xF8034200         DC32     0xf8034200

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xF8038200         DC32     0xf8038200

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0xFC010200         DC32     0xfc010200

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0xFC014200         DC32     0xfc014200

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0xFC018200         DC32     0xfc018200

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2D 0x45          DC8 "-E- usart_write: Timed out.\012\015"
   \              0x2D 0x20    
   \              0x75 0x73    
   \              0x61 0x72    
   \              0x74 0x5F    
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x65 0x3A    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x64    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x2E 0x0A    
   \              0x0D 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x2D 0x45          DC8 "-E- usart_read: Timed out.\012\015"
   \              0x2D 0x20    
   \              0x75 0x73    
   \              0x61 0x72    
   \              0x74 0x5F    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x3A 0x20    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x6F 0x75    
   \              0x74 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x75 0x73          DC8 "usart != NULL"
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x21 0x3D    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 73H, 65H, 72H, 69H
   \              0x73 0x5C    
   \              0x73 0x65    
   \              0x72 0x69    
   \   00000038   0x61 0x6C          DC8 61H, 6CH, 5CH, 75H, 73H, 61H, 72H, 74H
   \              0x5C 0x75    
   \              0x73 0x61    
   \              0x72 0x74    
   \   00000040   0x2E 0x63          DC8 2EH, 63H, 0
   \              0x00         
   \   00000043   0x00               DC8 0
    337          
    338          
    339          #ifdef FIFO_ENABLED
    340          /**
    341           * \brief Configure the FIFO of USART device
    342           *
    343           * \param usart Pointer to an USART instance.
    344           * \param tx_thres
    345           * \param rx_down_thres
    346           * \param rx_up_thres
    347           * \param ready_modes
    348           */
    349          void usart_fifo_configure(Usart *usart, uint8_t tx_thres,
    350          			  uint8_t rx_down_thres, uint8_t rx_up_thres,
    351          			  uint32_t ready_modes)
    352          {
    353          	/* Disable transmitter & receiver */
    354          	usart->US_CR = US_CR_RXDIS | US_CR_TXDIS;
    355          	/* Enable FIFO */
    356          	usart->US_CR = US_CR_FIFOEN;
    357          	/* Configure FIFO */
    358          	usart->US_FMR = US_FMR_TXFTHRES(tx_thres) | US_FMR_RXFTHRES(rx_down_thres)
    359          		| US_FMR_RXFTHRES2(rx_up_thres) | ready_modes;
    360          
    361          	/* Disable all fifo related interrupts */
    362          	usart->US_FIDR = 0xFFFFFFFF;
    363          
    364          	/* Reenable receiver & transmitter */
    365          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
    366          }
    367          
    368          /**
    369           * \brief Disable the FIFO mode from the USART device
    370           *
    371           * \param usart Pointer to an USART instance.
    372           * \note receiver and transmitter are reenabled.
    373           */
    374          void usart_fifo_disable(Usart *usart)
    375          {
    376          	/* Reset and disable receiver & transmitter */
    377          	uint32_t control = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS;
    378          	/* clear and disable FIFO */
    379          	_clear_fifo_control_flags(&control);
    380          	/* apply */
    381          	usart->US_CR = control;
    382          
    383          	/* Reenable receiver & transmitter */
    384          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
    385          }
    386          
    387          /**
    388           * \brief Enable FIFO related interrupts according to the given mask
    389           *
    390           * \param usart Pointer to an USART instance.
    391           * \param interrupt_mask The mask to apply
    392           */
    393          void usart_fifo_enable_it(Usart *usart, uint32_t interrupt_mask)
    394          {
    395          	usart->US_FIER = interrupt_mask;
    396          }
    397          
    398          /**
    399           * \brief Disable FIFO related interrupts according to the given mask
    400           *
    401           * \param usart Pointer to an USART instance.
    402           * \param interrupt_mask The mask to apply
    403           */
    404          void usart_fifo_disable_it(Usart *usart, uint32_t interrupt_mask)
    405          {
    406          	usart->US_FIDR = interrupt_mask;
    407          }
    408          
    409          /**
    410           * \brief Retrive FIFO related interrupt mask.
    411           *
    412           * \param usart Pointer to an USART instance.
    413           * \return current FIFO interrupt mask.
    414           */
    415          uint32_t usart_fifo_get_interrupts(Usart *usart)
    416          {
    417          	return usart->US_FIMR;
    418          }
    419          
    420          
    421          /**
    422           * \brief Get the size occupied in the input FIFO of USART device.
    423           *
    424           * \param usart Pointer to an USART instance.
    425           * \return Size occupied in the input FIFO (not read yet) in octet
    426           */
    427          uint32_t usart_fifo_rx_size(Usart *usart)
    428          {
    429          	return (usart->US_FLR & US_FLR_RXFL_Msk) >> US_FLR_RXFL_Pos;
    430          }
    431          
    432          /**
    433           * \brief Get the size occupied in the ouput FIFO of USART device.
    434           *
    435           * \param usart Pointer to an USART instance.
    436           * \return Size occupied in the output FIFO (not sent yet) in octet
    437           */
    438          uint32_t usart_fifo_tx_size(Usart *usart)
    439          {
    440          	return (usart->US_FLR & US_FLR_TXFL_Msk) >> US_FLR_TXFL_Pos;
    441          }
    442          
    443          /**
    444           * \brief Reads from USART device input channel until the specified length is
    445           * reached.
    446           *
    447           * \param usart Pointer to an USART instance.
    448           * \param stream Pointer to the receive buffer.
    449           * \param len Size of the receive buffer, in octets.
    450           *
    451           * \return Number of read octets
    452           *
    453           * \warning WORKS ONLY IN LITTLE ENDIAN MODE!
    454           *
    455           * \note The FIFO must be configured before using this function.
    456           * \note In case of a TIMEOUT or a BREAK, a null character is appended to the
    457           * buffer and the returned value should be inferior to \ref len.
    458           */
    459          uint32_t usart_read_stream(Usart *usart, void *stream, uint32_t len)
    460          {
    461          	uint8_t* buffer = stream;
    462          	uint32_t left = len;
    463          	while (left > 0) {
    464          		/* Stop reception if a timeout or break occur */
    465          		if ((usart->US_CSR & (US_CSR_TIMEOUT | US_CSR_RXBRK)) != 0) {
    466          			*buffer = '\0';
    467          			--left;
    468          			break;
    469          		}
    470          
    471          		if ((usart->US_CSR & US_CSR_RXRDY) == 0) continue;
    472          
    473          		/* Get FIFO size (in octets) and clamp it */
    474          		uint32_t buf_size = usart_fifo_rx_size(usart);
    475          		buf_size = buf_size > left ? left : buf_size;
    476          
    477          		/* Fill the buffer as must as possible with four data reads */
    478          		while (buf_size >= sizeof(uint32_t)) {
    479          			*(uint32_t*)buffer = usart->US_RHR;
    480          			buffer += sizeof(uint32_t);
    481          			left -= sizeof(uint32_t);
    482          			buf_size -= sizeof(uint32_t);
    483          		}
    484          		/* Add tail data if stream is not 4 octet aligned */
    485          		if (buf_size >= sizeof(uint16_t)) {
    486          			/* two data read */
    487          			readhw(&usart->US_RHR, (uint16_t*)buffer);
    488          			left -= sizeof(uint16_t);
    489          			buffer += sizeof(uint16_t);
    490          		}
    491          		if (buf_size >= sizeof(uint8_t)) {
    492          			/* one data read */
    493          			readb(&usart->US_RHR, buffer);
    494          			left -= sizeof(uint8_t);
    495          		}
    496          	}
    497          	return len - left;
    498          }
    499          
    500          /**
    501           * \brief Writes given data to USART device output channel until the specified
    502           * length is reached.
    503           *
    504           * \param usart Pointer to an USART instance.
    505           * \param stream Pointer to the data to send.
    506           * \param len Size of the data to send, in octets.
    507           *
    508           * \return Number of written octets
    509           *
    510           * \warning WORKS ONLY IN LITTLE ENDIAN MODE!
    511           *
    512           * \note The FIFO must be configured before using this function.
    513           * \note This function do not wait for the FIFO to be empty.
    514           * \note In case of a TIMEOUT the transmission is aborted and the returned value
    515           * should be inferior to \ref len.
    516           */
    517          uint32_t usart_write_stream(Usart *usart, const void *stream,
    518          			    uint32_t len)
    519          {
    520          	const uint8_t* buffer = stream;
    521          	uint32_t left = len;
    522          
    523          	while (left > 0) {
    524          		if ((usart->US_CSR & US_CSR_TXRDY) == 0) continue;
    525          
    526          		/* Get FIFO free size (int octet) and clamp it */
    527          		uint32_t buf_size = USART_FIFO_DEPTH - usart_fifo_tx_size(usart);
    528          		buf_size = buf_size > left ? left : buf_size;
    529          
    530          		/* Fill the FIFO as must as possible with four data writes */
    531          		while (buf_size >= sizeof(uint32_t)) {
    532          			usart->US_THR = *(uint32_t*)buffer;
    533          			buffer += sizeof(uint32_t);
    534          			left -= sizeof(uint32_t);
    535          			buf_size -= sizeof(uint32_t);
    536          		}
    537          		/* Add tail data if stream is not 4 octet aligned */
    538          		if (buf_size >= sizeof(uint16_t)) {
    539          			/* two data write */
    540          			writehw(&usart->US_THR, *(uint16_t*)buffer);
    541          			buffer += sizeof(uint16_t);
    542          			left -= sizeof(uint16_t);
    543          			buf_size -= sizeof(uint16_t);
    544          		}
    545          		if (buf_size >= sizeof(uint8_t)) {
    546          			/* one data write */
    547          			writeb(&usart->US_THR, *buffer);
    548          			buffer += sizeof(uint8_t);
    549          			left -= sizeof(uint8_t);
    550          		}
    551          	}
    552          	return len - left;
    553          }
    554          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   get_usart_id_from_addr
       0   readb
      24   usart_configure
        24   -> get_usart_id_from_addr
        24   -> pmc_get_peripheral_max_clock
        24 __aeabi_uidiv
       0   usart_disable_it
       0   usart_enable_it
      16   usart_get_char
        16   -> readb
       0   usart_get_it_mask
       0   usart_get_status
       0   usart_is_data_available
       0   usart_is_rx_ready
      16   usart_put_char
        16   -> writeb
      16   usart_read
        16   -> printf
      16   usart_set_irda_filter
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   usart_set_receiver_enabled
       0   usart_set_rts_enabled
       0   usart_set_transmitter_enabled
      16   usart_write
        16   -> printf
       0   writeb


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
      32  ?_0
      32  ?_1
      16  ?_2
      68  ?_3
      56  _id_h64_matrix
     112  get_usart_id_from_addr
      12  readb
     176  usart_configure
       8  usart_disable_it
       8  usart_enable_it
      44  usart_get_char
       8  usart_get_it_mask
       8  usart_get_status
      32  usart_is_data_available
      12  usart_is_rx_ready
      44  usart_put_char
     104  usart_read
      56  usart_set_irda_filter
      40  usart_set_receiver_enabled
      40  usart_set_rts_enabled
      40  usart_set_transmitter_enabled
     108  usart_write
       8  writeb

 
 204 bytes in section .rodata
 896 bytes in section SOFTPACK
 
 896 bytes of CODE  memory
 204 bytes of CONST memory

Errors: none
Warnings: 1
