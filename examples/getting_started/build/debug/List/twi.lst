###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:07
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\twi.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\twi.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup twi_module Working with TWI
     31           * \section Purpose
     32           * The TWI driver provides the interface to configure and use the TWI
     33           * peripheral.
     34           *
     35           * \section Usage
     36           * <ul>
     37           * <li> Configures a TWI peripheral to operate in master mode, at the given
     38           * frequency (in Hz) using TWI_Configure(). </li>
     39           * <li> Sends a STOP condition on the TWI using twi_stop().</li>
     40           * <li> Starts a read operation on the TWI bus with the specified slave using
     41           * twi_start_read(). Data must then be read using twi_read_byte() whenever
     42           * a byte is available (poll using twi_is_byte_received()).</li>
     43           * <li> Starts a write operation on the TWI to access the selected slave using
     44           * twi_start_write(). A byte of data must be provided to start the write;
     45           * other bytes are written next.</li>
     46           * <li> Sends a byte of data to one of the TWI slaves on the bus using twi_write_byte().
     47           * This function must be called once before twi_start_write() with the first byte of data
     48           * to send, then it shall be called repeatedly after that to send the remaining bytes.</li>
     49           * <li> Check if a byte has been received and can be read on the given TWI
     50           * peripheral using twi_is_byte_received().<
     51           * Check if a byte has been sent using twi_byte_sent().</li>
     52           * <li> Check if the current transmission is complete (the STOP has been sent)
     53           * using twi_is_transfer_complete().</li>
     54           * <li> Enables & disable the selected interrupts sources on a TWI peripheral
     55           * using twi_enable_it() and twi_enable_it().</li>
     56           * <li> Get current status register of the given TWI peripheral using
     57           * twi_get_status(). Get current status register of the given TWI peripheral, but
     58           * masking interrupt sources which are not currently enabled using
     59           * twi_get_masked_status().</li>
     60           * </ul>
     61           * For more accurate information, please look at the TWI section of the
     62           * Datasheet.
     63           *
     64           * Related files :\n
     65           * \ref twi.c\n
     66           * \ref twi.h.\n
     67          */
     68          /*@{*/
     69          /*@}*/
     70          
     71          /**
     72           * \file
     73           *
     74           * Implementation of Two Wire Interface (TWI).
     75           *
     76           */
     77          
     78          /*----------------------------------------------------------------------------
     79           *        Headers
     80           *----------------------------------------------------------------------------*/
     81          
     82          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp uint32_t get_twi_id_from_addr(Twi const *)
   \                     get_twi_id_from_addr:
   \   00000000   0xE1B01000         MOVS     R1,R0
   \   00000004   0x........         LDR      R0,??DataTable15  ;; 0xf8034600
   \   00000008   0xE1510000         CMP      R1,R0
   \   0000000C   0x1A000001         BNE      ??get_twi_id_from_addr_0
   \   00000010   0xE3A00013         MOV      R0,#+19
   \   00000014   0xEA000020         B        ??get_twi_id_from_addr_1
   \                     ??get_twi_id_from_addr_0:
   \   00000018   0x........         LDR      R0,??DataTable15_1  ;; 0xf8038600
   \   0000001C   0xE1510000         CMP      R1,R0
   \   00000020   0x1A000001         BNE      ??get_twi_id_from_addr_2
   \   00000024   0xE3A00014         MOV      R0,#+20
   \   00000028   0xEA00001B         B        ??get_twi_id_from_addr_1
   \                     ??get_twi_id_from_addr_2:
   \   0000002C   0x........         LDR      R0,??DataTable15_2  ;; 0xfc010600
   \   00000030   0xE1510000         CMP      R1,R0
   \   00000034   0x1A000001         BNE      ??get_twi_id_from_addr_3
   \   00000038   0xE3A00015         MOV      R0,#+21
   \   0000003C   0xEA000016         B        ??get_twi_id_from_addr_1
   \                     ??get_twi_id_from_addr_3:
   \   00000040   0x........         LDR      R0,??DataTable15_3  ;; 0xfc014600
   \   00000044   0xE1510000         CMP      R1,R0
   \   00000048   0x1A000001         BNE      ??get_twi_id_from_addr_4
   \   0000004C   0xE3A00016         MOV      R0,#+22
   \   00000050   0xEA000011         B        ??get_twi_id_from_addr_1
   \                     ??get_twi_id_from_addr_4:
   \   00000054   0x........         LDR      R0,??DataTable15_4  ;; 0xfc018600
   \   00000058   0xE1510000         CMP      R1,R0
   \   0000005C   0x1A000001         BNE      ??get_twi_id_from_addr_5
   \   00000060   0xE3A00017         MOV      R0,#+23
   \   00000064   0xEA00000C         B        ??get_twi_id_from_addr_1
   \                     ??get_twi_id_from_addr_5:
   \   00000068   0xE3A004F8         MOV      R0,#-134217728
   \   0000006C   0xE3800BA0         ORR      R0,R0,#0x28000
   \   00000070   0xE1510000         CMP      R1,R0
   \   00000074   0x1A000001         BNE      ??get_twi_id_from_addr_6
   \   00000078   0xE3A0001D         MOV      R0,#+29
   \   0000007C   0xEA000006         B        ??get_twi_id_from_addr_1
   \                     ??get_twi_id_from_addr_6:
   \   00000080   0xE3A004FC         MOV      R0,#-67108864
   \   00000084   0xE3800BA0         ORR      R0,R0,#0x28000
   \   00000088   0xE1510000         CMP      R1,R0
   \   0000008C   0x1A000001         BNE      ??get_twi_id_from_addr_7
   \   00000090   0xE3A0001E         MOV      R0,#+30
   \   00000094   0xEA000000         B        ??get_twi_id_from_addr_1
   \                     ??get_twi_id_from_addr_7:
   \   00000098   0xE3A0004F         MOV      R0,#+79
   \                     ??get_twi_id_from_addr_1:
   \   0000009C   0xE12FFF1E         BX       LR               ;; return
     83          #include "bus/twi.h"
     84          #include "core/pmc.h"
     85          #include "utils/trace.h"
     86          
     87          #include <stddef.h>
     88          #include <assert.h>
     89          
     90          /*----------------------------------------------------------------------------
     91           *        Exported functions
     92           *----------------------------------------------------------------------------*/
     93          
     94          /**
     95           * \brief Configures a TWI peripheral to operate in master mode, at the given
     96           * frequency (in Hz). The duty cycle of the TWI clock is set to 50%.
     97           * \param twi  Pointer to an Twi instance.
     98           * \param dwTwCk  Desired TWI clock frequency.
     99           * \param dwMCk  Master clock frequency.
    100           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    101          void twi_configure_master(Twi * pTwi, uint32_t twi_clock)
    102          {
   \                     twi_configure_master:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    103          	uint32_t ck_div, cl_div, ok, max_clock;
    104          	uint32_t id = get_twi_id_from_addr(pTwi);
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       get_twi_id_from_addr
   \   00000014   0xE1B09000         MOVS     R9,R0
    105          
    106          	TRACE_DEBUG("twi_configure_master()\n\r");
    107          	assert(pTwi);
   \   00000018   0xE3540000         CMP      R4,#+0
   \   0000001C   0x1A000004         BNE      ??twi_configure_master_0
   \   00000020   0xE3A0206B         MOV      R2,#+107
   \   00000024   0x........         LDR      R1,??DataTable15_5
   \   00000028   0x........         LDR      R0,??DataTable15_6
   \   0000002C   0x........         BL       __aeabi_assert
   \   00000030   0x........         BL       __iar_EmptyStepPoint
    108          	assert(id != ID_PERIPH_COUNT);
   \                     ??twi_configure_master_0:
   \   00000034   0xE359004F         CMP      R9,#+79
   \   00000038   0x1A000004         BNE      ??twi_configure_master_1
   \   0000003C   0xE3A0206C         MOV      R2,#+108
   \   00000040   0x........         LDR      R1,??DataTable15_5
   \   00000044   0x........         LDR      R0,??DataTable15_7
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    109          	/* SVEN: TWI Slave Mode Enabled */
    110          	pTwi->TWI_CR = TWI_CR_SVEN;
   \                     ??twi_configure_master_1:
   \   00000050   0xE3A00010         MOV      R0,#+16
   \   00000054   0xE5840000         STR      R0,[R4, #+0]
    111          	/* Reset the TWI */
    112          	pTwi->TWI_CR = TWI_CR_SWRST;
   \   00000058   0xE3A00080         MOV      R0,#+128
   \   0000005C   0xE5840000         STR      R0,[R4, #+0]
    113          	pTwi->TWI_RHR;
   \   00000060   0xE5940030         LDR      R0,[R4, #+48]
    114          	/* TWI Slave Mode Disabled, TWI Master Mode Disabled. */
    115          	pTwi->TWI_CR = TWI_CR_SVDIS;
   \   00000064   0xE3A00020         MOV      R0,#+32
   \   00000068   0xE5840000         STR      R0,[R4, #+0]
    116          	pTwi->TWI_CR = TWI_CR_MSDIS;
   \   0000006C   0xE3A00008         MOV      R0,#+8
   \   00000070   0xE5840000         STR      R0,[R4, #+0]
    117          	/* Set master mode */
    118          	pTwi->TWI_CR = TWI_CR_MSEN;
   \   00000074   0xE3A00004         MOV      R0,#+4
   \   00000078   0xE5840000         STR      R0,[R4, #+0]
    119          	max_clock = pmc_get_peripheral_max_clock(id);
   \   0000007C   0xE1B00009         MOVS     R0,R9
   \   00000080   0x........         BL       pmc_get_peripheral_max_clock
   \   00000084   0xE1B08000         MOVS     R8,R0
    120          	/* Configure clock */
    121          	ck_div = 0; ok = 0;
   \   00000088   0xE3A00000         MOV      R0,#+0
   \   0000008C   0xE1B06000         MOVS     R6,R0
   \   00000090   0xE3A00000         MOV      R0,#+0
   \   00000094   0xE1B0A000         MOVS     R10,R0
    122          	while (!ok) {
   \                     ??twi_configure_master_2:
   \   00000098   0xE35A0000         CMP      R10,#+0
   \   0000009C   0x1A00000F         BNE      ??twi_configure_master_3
    123          		cl_div = ((max_clock / (2 * twi_clock)) - 8) / (1 << ck_div);
   \   000000A0   0xE1B00008         MOVS     R0,R8
   \   000000A4   0xE1B01085         LSLS     R1,R5,#+1
   \   000000A8   0x........         BL       __aeabi_uidiv
   \   000000AC   0xE2500008         SUBS     R0,R0,#+8
   \   000000B0   0xE3A01001         MOV      R1,#+1
   \   000000B4   0xE1B01611         LSLS     R1,R1,R6
   \   000000B8   0x........         BL       __aeabi_uidiv
   \   000000BC   0xE1B07000         MOVS     R7,R0
    124          		(cl_div <= 255) ? ok = 1 : ck_div++;
   \   000000C0   0xE3570F40         CMP      R7,#+256
   \   000000C4   0x2A000002         BCS      ??twi_configure_master_4
   \   000000C8   0xE3A0A001         MOV      R10,#+1
   \   000000CC   0xE1B0000A         MOVS     R0,R10
   \   000000D0   0xEAFFFFF0         B        ??twi_configure_master_2
   \                     ??twi_configure_master_4:
   \   000000D4   0xE1B00006         MOVS     R0,R6
   \   000000D8   0xE2966001         ADDS     R6,R6,#+1
   \   000000DC   0xEAFFFFED         B        ??twi_configure_master_2
    125          	}
    126          	assert(ck_div < 8);
   \                     ??twi_configure_master_3:
   \   000000E0   0xE3560008         CMP      R6,#+8
   \   000000E4   0x3A000004         BCC      ??twi_configure_master_5
   \   000000E8   0xE3A0207E         MOV      R2,#+126
   \   000000EC   0x........         LDR      R1,??DataTable15_5
   \   000000F0   0x........         LDR      R0,??DataTable15_8
   \   000000F4   0x........         BL       __aeabi_assert
   \   000000F8   0x........         BL       __iar_EmptyStepPoint
    127          	TRACE_DEBUG("Using CKDIV = %u and CLDIV/CHDIV = %u\n\r", ck_div, cl_div);
    128          	pTwi->TWI_CWGR = 0;
   \                     ??twi_configure_master_5:
   \   000000FC   0xE3A00000         MOV      R0,#+0
   \   00000100   0xE5840010         STR      R0,[R4, #+16]
    129          	pTwi->TWI_CWGR = (cl_div << 16) | (cl_div << 8) | cl_div;
   \   00000104   0xE1B00407         LSLS     R0,R7,#+8
   \   00000108   0xE1900807         ORRS     R0,R0,R7, LSL #+16
   \   0000010C   0xE1970000         ORRS     R0,R7,R0
   \   00000110   0xE5840010         STR      R0,[R4, #+16]
    130          }
   \   00000114   0xE8BD87F0         POP      {R4-R10,PC}      ;; return
    131          
    132          /**
    133           * \brief Configures a TWI peripheral to operate in slave mode.
    134           * \param twi  Pointer to an Twi instance.
    135           * \param slaveAddress Slave address.
    136           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    137          void twi_configure_slave(Twi * pTwi, uint8_t slave_address)
    138          {
   \                     twi_configure_slave:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    139          	uint32_t i;
    140          
    141          	TRACE_DEBUG("twi_configure_slave()\n\r");
    142          	assert(pTwi);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??twi_configure_slave_0
   \   00000014   0xE3A0208E         MOV      R2,#+142
   \   00000018   0x........         LDR      R1,??DataTable15_5
   \   0000001C   0x........         LDR      R0,??DataTable15_6
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    143          	/* TWI software reset */
    144          	pTwi->TWI_CR = TWI_CR_SWRST;
   \                     ??twi_configure_slave_0:
   \   00000028   0xE3A00080         MOV      R0,#+128
   \   0000002C   0xE5840000         STR      R0,[R4, #+0]
    145          	pTwi->TWI_RHR;
   \   00000030   0xE5940030         LDR      R0,[R4, #+48]
    146          	/* Wait at least 10 ms */
    147          	for (i = 0; i < 1000000; i++) ;
   \   00000034   0xE3A00000         MOV      R0,#+0
   \   00000038   0xE1B06000         MOVS     R6,R0
   \                     ??twi_configure_slave_1:
   \   0000003C   0xE3A00AF4         MOV      R0,#+999424
   \   00000040   0xE3800F90         ORR      R0,R0,#0x240
   \   00000044   0xE1560000         CMP      R6,R0
   \   00000048   0x2A000001         BCS      ??twi_configure_slave_2
   \   0000004C   0xE2966001         ADDS     R6,R6,#+1
   \   00000050   0xEAFFFFF9         B        ??twi_configure_slave_1
    148          	/* TWI Slave Mode Disabled, TWI Master Mode Disabled */
    149          	pTwi->TWI_CR = TWI_CR_SVDIS | TWI_CR_MSDIS;
   \                     ??twi_configure_slave_2:
   \   00000054   0xE3A00028         MOV      R0,#+40
   \   00000058   0xE5840000         STR      R0,[R4, #+0]
    150          	/* Configure slave address. */
    151          	pTwi->TWI_SMR = 0;
   \   0000005C   0xE3A00000         MOV      R0,#+0
   \   00000060   0xE5840008         STR      R0,[R4, #+8]
    152          	pTwi->TWI_SMR = TWI_SMR_SADR(slave_address);
   \   00000064   0xE1B00005         MOVS     R0,R5
   \   00000068   0xE6EF0070         UXTB     R0,R0
   \   0000006C   0xE3A0187F         MOV      R1,#+8323072
   \   00000070   0xE0110800         ANDS     R0,R1,R0, LSL #+16
   \   00000074   0xE5840008         STR      R0,[R4, #+8]
    153          	/* SVEN: TWI Slave Mode Enabled */
    154          	pTwi->TWI_CR = TWI_CR_SVEN;
   \   00000078   0xE3A00010         MOV      R0,#+16
   \   0000007C   0xE5840000         STR      R0,[R4, #+0]
    155          	/* Wait at least 10 ms */
    156          	for (i = 0; i < 1000000; i++) ;
   \   00000080   0xE3A00000         MOV      R0,#+0
   \   00000084   0xE1B06000         MOVS     R6,R0
   \                     ??twi_configure_slave_3:
   \   00000088   0xE3A00AF4         MOV      R0,#+999424
   \   0000008C   0xE3800F90         ORR      R0,R0,#0x240
   \   00000090   0xE1560000         CMP      R6,R0
   \   00000094   0x2A000001         BCS      ??twi_configure_slave_4
   \   00000098   0xE2966001         ADDS     R6,R6,#+1
   \   0000009C   0xEAFFFFF9         B        ??twi_configure_slave_3
    157          	assert((pTwi->TWI_CR & TWI_CR_SVDIS) != TWI_CR_SVDIS);
   \                     ??twi_configure_slave_4:
   \   000000A0   0xE5940000         LDR      R0,[R4, #+0]
   \   000000A4   0xE3100020         TST      R0,#0x20
   \   000000A8   0x0A000004         BEQ      ??twi_configure_slave_5
   \   000000AC   0xE3A0209D         MOV      R2,#+157
   \   000000B0   0x........         LDR      R1,??DataTable15_5
   \   000000B4   0x........         LDR      R0,??DataTable15_9
   \   000000B8   0x........         BL       __aeabi_assert
   \   000000BC   0x........         BL       __iar_EmptyStepPoint
    158          }
   \                     ??twi_configure_slave_5:
   \   000000C0   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    159          
    160          /**
    161           * \brief Sends a STOP condition on the TWI.
    162           * \param twi  Pointer to an Twi instance.
    163           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    164          void twi_stop(Twi * pTwi)
    165          {
   \                     twi_stop:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    166          	assert(pTwi != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twi_stop_0
   \   00000010   0xE3A020A6         MOV      R2,#+166
   \   00000014   0x........         LDR      R1,??DataTable15_5
   \   00000018   0x........         LDR      R0,??DataTable15_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    167          	pTwi->TWI_CR = TWI_CR_STOP;
   \                     ??twi_stop_0:
   \   00000024   0xE3A00002         MOV      R0,#+2
   \   00000028   0xE5840000         STR      R0,[R4, #+0]
    168          }
   \   0000002C   0xE8BD8010         POP      {R4,PC}          ;; return
    169          
    170          /**
    171           * \brief Starts a read operation on the TWI bus with the specified slave, it returns
    172           * immediately. Data must then be read using twi_read_byte() whenever a byte is
    173           * available (poll using twi_is_byte_received()).
    174           * \param twi  Pointer to an Twi instance.
    175           * \param address  Slave address on the bus.
    176           * \param iaddress  Optional internal address bytes.
    177           * \param isize  Number of internal address bytes.
    178           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    179          void twi_start_read(Twi * pTwi, uint8_t address, uint32_t iaddress, uint8_t isize)
    180          {
   \                     twi_start_read:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    181          	assert(pTwi != NULL);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000004         BNE      ??twi_start_read_0
   \   0000001C   0xE3A020B5         MOV      R2,#+181
   \   00000020   0x........         LDR      R1,??DataTable15_5
   \   00000024   0x........         LDR      R0,??DataTable15_10
   \   00000028   0x........         BL       __aeabi_assert
   \   0000002C   0x........         BL       __iar_EmptyStepPoint
    182          	assert((address & 0x80) == 0);
   \                     ??twi_start_read_0:
   \   00000030   0xE3150080         TST      R5,#0x80
   \   00000034   0x0A000004         BEQ      ??twi_start_read_1
   \   00000038   0xE3A020B6         MOV      R2,#+182
   \   0000003C   0x........         LDR      R1,??DataTable15_5
   \   00000040   0x........         LDR      R0,??DataTable15_11
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    183          	assert((iaddress & 0xFF000000) == 0);
   \                     ??twi_start_read_1:
   \   0000004C   0xE31604FF         TST      R6,#0xFF000000
   \   00000050   0x0A000004         BEQ      ??twi_start_read_2
   \   00000054   0xE3A020B7         MOV      R2,#+183
   \   00000058   0x........         LDR      R1,??DataTable15_5
   \   0000005C   0x........         LDR      R0,??DataTable15_12
   \   00000060   0x........         BL       __aeabi_assert
   \   00000064   0x........         BL       __iar_EmptyStepPoint
    184          	assert(isize < 4);
   \                     ??twi_start_read_2:
   \   00000068   0xE1B00007         MOVS     R0,R7
   \   0000006C   0xE6EF0070         UXTB     R0,R0
   \   00000070   0xE3500004         CMP      R0,#+4
   \   00000074   0xBA000004         BLT      ??twi_start_read_3
   \   00000078   0xE3A020B8         MOV      R2,#+184
   \   0000007C   0x........         LDR      R1,??DataTable15_5
   \   00000080   0x........         LDR      R0,??DataTable15_13
   \   00000084   0x........         BL       __aeabi_assert
   \   00000088   0x........         BL       __iar_EmptyStepPoint
    185          	/* Set slave address and number of internal address bytes. */
    186          	pTwi->TWI_MMR = 0;
   \                     ??twi_start_read_3:
   \   0000008C   0xE3A00000         MOV      R0,#+0
   \   00000090   0xE5840004         STR      R0,[R4, #+4]
    187          	pTwi->TWI_MMR = (isize << 8) | TWI_MMR_MREAD | (address << 16);
   \   00000094   0xE1B00007         MOVS     R0,R7
   \   00000098   0xE6EF0070         UXTB     R0,R0
   \   0000009C   0xE3A01D40         MOV      R1,#+4096
   \   000000A0   0xE1910400         ORRS     R0,R1,R0, LSL #+8
   \   000000A4   0xE1B01005         MOVS     R1,R5
   \   000000A8   0xE6EF1071         UXTB     R1,R1
   \   000000AC   0xE1900801         ORRS     R0,R0,R1, LSL #+16
   \   000000B0   0xE5840004         STR      R0,[R4, #+4]
    188          	/* Set internal address bytes */
    189          	pTwi->TWI_IADR = 0;
   \   000000B4   0xE3A00000         MOV      R0,#+0
   \   000000B8   0xE584000C         STR      R0,[R4, #+12]
    190          	pTwi->TWI_IADR = iaddress;
   \   000000BC   0xE584600C         STR      R6,[R4, #+12]
    191          	/* Send START condition */
    192          	pTwi->TWI_CR = TWI_CR_START;
   \   000000C0   0xE3A00001         MOV      R0,#+1
   \   000000C4   0xE5840000         STR      R0,[R4, #+0]
    193          }
   \   000000C8   0xE8BD80F1         POP      {R0,R4-R7,PC}    ;; return
    194          
    195          /**
    196           * \brief Reads a byte from the TWI bus. The read operation must have been started
    197           * using twi_start_read() and a byte must be available (check with twi_is_byte_received()).
    198           * \param twi  Pointer to an Twi instance.
    199           * \return byte read.
    200           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    201          uint8_t twi_read_byte(Twi * pTwi)
    202          {
   \                     twi_read_byte:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    203          	assert(pTwi != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twi_read_byte_0
   \   00000010   0xE3A020CB         MOV      R2,#+203
   \   00000014   0x........         LDR      R1,??DataTable15_5
   \   00000018   0x........         LDR      R0,??DataTable15_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    204          	return pTwi->TWI_RHR;
   \                     ??twi_read_byte_0:
   \   00000024   0xE5940030         LDR      R0,[R4, #+48]
   \   00000028   0xE6EF0070         UXTB     R0,R0
   \   0000002C   0xE8BD8010         POP      {R4,PC}          ;; return
    205          }
    206          
    207          /**
    208           * \brief Sends a byte of data to one of the TWI slaves on the bus.
    209           * \note This function must be called once before twi_start_write() with
    210           * the first byte of data  to send, then it shall be called repeatedly
    211           * after that to send the remaining bytes.
    212           * \param twi  Pointer to an Twi instance.
    213           * \param byte  Byte to send.
    214           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    215          void twi_write_byte(Twi * pTwi, uint8_t byte)
    216          {
   \                     twi_write_byte:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    217          	assert(pTwi != NULL);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??twi_write_byte_0
   \   00000014   0xE3A020D9         MOV      R2,#+217
   \   00000018   0x........         LDR      R1,??DataTable15_5
   \   0000001C   0x........         LDR      R0,??DataTable15_10
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    218          	pTwi->TWI_THR = byte;
   \                     ??twi_write_byte_0:
   \   00000028   0xE1B00005         MOVS     R0,R5
   \   0000002C   0xE6EF0070         UXTB     R0,R0
   \   00000030   0xE5840034         STR      R0,[R4, #+52]
    219          }
   \   00000034   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    220          
    221          /**
    222           * \brief Starts a write operation on the TWI to access the selected slave, then
    223           *  returns immediately. A byte of data must be provided to start the write;
    224           * other bytes are written next.
    225           * after that to send the remaining bytes.
    226           * \param twi  Pointer to an Twi instance.
    227           * \param address  Address of slave to acccess on the bus.
    228           * \param iaddress  Optional slave internal address.
    229           * \param isize  Number of internal address bytes.
    230           * \param byte  First byte to send.
    231           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    232          void twi_start_write(Twi * pTwi, uint8_t address, uint32_t iaddress, uint8_t isize, uint8_t byte)
    233          {
   \                     twi_start_write:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
   \   00000014   0xE5DD8018         LDRB     R8,[SP, #+24]
    234          	assert(pTwi != NULL);
   \   00000018   0xE3540000         CMP      R4,#+0
   \   0000001C   0x1A000004         BNE      ??twi_start_write_0
   \   00000020   0xE3A020EA         MOV      R2,#+234
   \   00000024   0x........         LDR      R1,??DataTable15_5
   \   00000028   0x........         LDR      R0,??DataTable15_10
   \   0000002C   0x........         BL       __aeabi_assert
   \   00000030   0x........         BL       __iar_EmptyStepPoint
    235          	assert((address & 0x80) == 0);
   \                     ??twi_start_write_0:
   \   00000034   0xE3150080         TST      R5,#0x80
   \   00000038   0x0A000004         BEQ      ??twi_start_write_1
   \   0000003C   0xE3A020EB         MOV      R2,#+235
   \   00000040   0x........         LDR      R1,??DataTable15_5
   \   00000044   0x........         LDR      R0,??DataTable15_11
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    236          	assert((iaddress & 0xFF000000) == 0);
   \                     ??twi_start_write_1:
   \   00000050   0xE31604FF         TST      R6,#0xFF000000
   \   00000054   0x0A000004         BEQ      ??twi_start_write_2
   \   00000058   0xE3A020EC         MOV      R2,#+236
   \   0000005C   0x........         LDR      R1,??DataTable15_5
   \   00000060   0x........         LDR      R0,??DataTable15_12
   \   00000064   0x........         BL       __aeabi_assert
   \   00000068   0x........         BL       __iar_EmptyStepPoint
    237          	assert(isize < 4);
   \                     ??twi_start_write_2:
   \   0000006C   0xE1B00007         MOVS     R0,R7
   \   00000070   0xE6EF0070         UXTB     R0,R0
   \   00000074   0xE3500004         CMP      R0,#+4
   \   00000078   0xBA000004         BLT      ??twi_start_write_3
   \   0000007C   0xE3A020ED         MOV      R2,#+237
   \   00000080   0x........         LDR      R1,??DataTable15_5
   \   00000084   0x........         LDR      R0,??DataTable15_13
   \   00000088   0x........         BL       __aeabi_assert
   \   0000008C   0x........         BL       __iar_EmptyStepPoint
    238          	/* Set slave address and number of internal address bytes. */
    239          	pTwi->TWI_MMR = 0;
   \                     ??twi_start_write_3:
   \   00000090   0xE3A00000         MOV      R0,#+0
   \   00000094   0xE5840004         STR      R0,[R4, #+4]
    240          	pTwi->TWI_MMR = (isize << 8) | (address << 16);
   \   00000098   0xE1B00007         MOVS     R0,R7
   \   0000009C   0xE6EF0070         UXTB     R0,R0
   \   000000A0   0xE1B01005         MOVS     R1,R5
   \   000000A4   0xE6EF1071         UXTB     R1,R1
   \   000000A8   0xE1B01801         LSLS     R1,R1,#+16
   \   000000AC   0xE1910400         ORRS     R0,R1,R0, LSL #+8
   \   000000B0   0xE5840004         STR      R0,[R4, #+4]
    241          	/* Set internal address bytes. */
    242          	pTwi->TWI_IADR = 0;
   \   000000B4   0xE3A00000         MOV      R0,#+0
   \   000000B8   0xE584000C         STR      R0,[R4, #+12]
    243          	pTwi->TWI_IADR = iaddress;
   \   000000BC   0xE584600C         STR      R6,[R4, #+12]
    244          	/* Write first byte to send. */
    245          	twi_write_byte(pTwi, byte);
   \   000000C0   0xE1B01008         MOVS     R1,R8
   \   000000C4   0xE6EF1071         UXTB     R1,R1
   \   000000C8   0xE1B00004         MOVS     R0,R4
   \   000000CC   0x........         BL       twi_write_byte
    246          }
   \   000000D0   0xE8BD81F0         POP      {R4-R8,PC}       ;; return
    247          
    248          /**
    249           * \brief Check if a byte have been receiced from TWI.
    250           * \param twi  Pointer to an Twi instance.
    251           * \return 1 if a byte has been received and can be read on the given TWI
    252           * peripheral; otherwise, returns 0. This function resets the status register.
    253           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    254          uint8_t twi_is_byte_received(Twi * pTwi)
    255          {
   \                     twi_is_byte_received:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    256          	assert(pTwi != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twi_is_byte_received_0
   \   00000010   0xE3A02F40         MOV      R2,#+256
   \   00000014   0x........         LDR      R1,??DataTable15_5
   \   00000018   0x........         LDR      R0,??DataTable15_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    257          	return ((pTwi->TWI_SR & TWI_SR_RXRDY) == TWI_SR_RXRDY);
   \                     ??twi_is_byte_received_0:
   \   00000024   0xE5940020         LDR      R0,[R4, #+32]
   \   00000028   0xE1B000A0         LSRS     R0,R0,#+1
   \   0000002C   0xE2100001         ANDS     R0,R0,#0x1
   \   00000030   0xE8BD8010         POP      {R4,PC}          ;; return
    258          }
    259          
    260          /**
    261           * \brief Check if a byte have been sent to TWI.
    262           * \param twi  Pointer to an Twi instance.
    263           * \return 1 if a byte has been sent  so another one can be stored for
    264           * transmission; otherwise returns 0. This function clears the status register.
    265           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    266          uint8_t twi_byte_sent(Twi * pTwi)
    267          {
   \                     twi_byte_sent:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    268          	assert(pTwi != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twi_byte_sent_0
   \   00000010   0xE3A02F43         MOV      R2,#+268
   \   00000014   0x........         LDR      R1,??DataTable15_5
   \   00000018   0x........         LDR      R0,??DataTable15_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    269          	return ((pTwi->TWI_SR & TWI_SR_TXRDY) == TWI_SR_TXRDY);
   \                     ??twi_byte_sent_0:
   \   00000024   0xE5940020         LDR      R0,[R4, #+32]
   \   00000028   0xE1B00120         LSRS     R0,R0,#+2
   \   0000002C   0xE2100001         ANDS     R0,R0,#0x1
   \   00000030   0xE8BD8010         POP      {R4,PC}          ;; return
    270          }
    271          
    272          /**
    273           * \brief Check if current transmission is complet.
    274           * \param twi  Pointer to an Twi instance.
    275           * \return  1 if the current transmission is complete (the STOP has been sent);
    276           * otherwise returns 0.
    277           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    278          uint8_t twi_is_transfer_complete(Twi * pTwi)
    279          {
   \                     twi_is_transfer_complete:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    280          	assert(pTwi != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twi_is_transfer_complete_0
   \   00000010   0xE3A02F46         MOV      R2,#+280
   \   00000014   0x........         LDR      R1,??DataTable15_5
   \   00000018   0x........         LDR      R0,??DataTable15_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    281          	return ((pTwi->TWI_SR & TWI_SR_TXCOMP) == TWI_SR_TXCOMP);
   \                     ??twi_is_transfer_complete_0:
   \   00000024   0xE5940020         LDR      R0,[R4, #+32]
   \   00000028   0xE2100001         ANDS     R0,R0,#0x1
   \   0000002C   0xE8BD8010         POP      {R4,PC}          ;; return
    282          }
    283          
    284          /**
    285           * \brief Enables the selected interrupts sources on a TWI peripheral.
    286           * \param twi  Pointer to an Twi instance.
    287           * \param sources  Bitwise OR of selected interrupt sources.
    288           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    289          void twi_enable_it(Twi * pTwi, uint32_t sources)
    290          {
   \                     twi_enable_it:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    291          	assert(pTwi != NULL);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??twi_enable_it_0
   \   00000014   0xE3002123         MOVW     R2,#+291
   \   00000018   0x........         LDR      R1,??DataTable15_5
   \   0000001C   0x........         LDR      R0,??DataTable15_10
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    292          	assert((sources & 0xFFFFF088) == 0);
   \                     ??twi_enable_it_0:
   \   00000028   0xE3E00077         MVN      R0,#+119
   \   0000002C   0xE3C00EF0         BIC      R0,R0,#0xF00
   \   00000030   0xE1100005         TST      R0,R5
   \   00000034   0x0A000004         BEQ      ??twi_enable_it_1
   \   00000038   0xE3A02F49         MOV      R2,#+292
   \   0000003C   0x........         LDR      R1,??DataTable15_5
   \   00000040   0x........         LDR      R0,??DataTable15_14
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    293          	pTwi->TWI_IER = sources;
   \                     ??twi_enable_it_1:
   \   0000004C   0xE5845024         STR      R5,[R4, #+36]
    294          }
   \   00000050   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    295          
    296          /**
    297           * \brief Disables the selected interrupts sources on a TWI peripheral.
    298           * \param twi  Pointer to an Twi instance.
    299           * \param sources  Bitwise OR of selected interrupt sources.
    300           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    301          void twi_disable_it(Twi * pTwi, uint32_t sources)
    302          {
   \                     twi_disable_it:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    303          	assert(pTwi != NULL);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??twi_disable_it_0
   \   00000014   0xE300212F         MOVW     R2,#+303
   \   00000018   0x........         LDR      R1,??DataTable15_5
   \   0000001C   0x........         LDR      R0,??DataTable15_10
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    304          	assert((sources & 0xFFFFF088) == 0);
   \                     ??twi_disable_it_0:
   \   00000028   0xE3E00077         MVN      R0,#+119
   \   0000002C   0xE3C00EF0         BIC      R0,R0,#0xF00
   \   00000030   0xE1100005         TST      R0,R5
   \   00000034   0x0A000004         BEQ      ??twi_disable_it_1
   \   00000038   0xE3A02F4C         MOV      R2,#+304
   \   0000003C   0x........         LDR      R1,??DataTable15_5
   \   00000040   0x........         LDR      R0,??DataTable15_14
   \   00000044   0x........         BL       __aeabi_assert
   \   00000048   0x........         BL       __iar_EmptyStepPoint
    305          	pTwi->TWI_IDR = sources;
   \                     ??twi_disable_it_1:
   \   0000004C   0xE5845028         STR      R5,[R4, #+40]
    306          }
   \   00000050   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    307          
    308          /**
    309           * \brief Get the current status register of the given TWI peripheral.
    310           * \note This resets the internal value of the status register, so further
    311           * read may yield different values.
    312           * \param twi  Pointer to an Twi instance.
    313           * \return  TWI status register.
    314           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    315          uint32_t twi_get_status(Twi * pTwi)
    316          {
   \                     twi_get_status:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    317          	assert(pTwi != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twi_get_status_0
   \   00000010   0xE300213D         MOVW     R2,#+317
   \   00000014   0x........         LDR      R1,??DataTable15_5
   \   00000018   0x........         LDR      R0,??DataTable15_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    318          	return pTwi->TWI_SR;
   \                     ??twi_get_status_0:
   \   00000024   0xE5940020         LDR      R0,[R4, #+32]
   \   00000028   0xE8BD8010         POP      {R4,PC}          ;; return
    319          }
    320          
    321          /**
    322           * \brief Returns the current status register of the given TWI peripheral, but
    323           * masking interrupt sources which are not currently enabled.
    324           * \note This resets the internal value of the status register, so further
    325           * read may yield different values.
    326           * \param twi  Pointer to an Twi instance.
    327           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    328          uint32_t twi_get_masked_status(Twi * pTwi)
    329          {
   \                     twi_get_masked_status:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    330          	uint32_t status;
    331          	assert(pTwi != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twi_get_masked_status_0
   \   00000010   0xE300214B         MOVW     R2,#+331
   \   00000014   0x........         LDR      R1,??DataTable15_5
   \   00000018   0x........         LDR      R0,??DataTable15_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    332          	status = pTwi->TWI_SR;
   \                     ??twi_get_masked_status_0:
   \   00000024   0xE5940020         LDR      R0,[R4, #+32]
   \   00000028   0xE1B05000         MOVS     R5,R0
    333          	status &= pTwi->TWI_IMR;
   \   0000002C   0xE594002C         LDR      R0,[R4, #+44]
   \   00000030   0xE0105005         ANDS     R5,R0,R5
    334          	return status;
   \   00000034   0xE1B00005         MOVS     R0,R5
   \   00000038   0xE8BD8032         POP      {R1,R4,R5,PC}    ;; return
    335          }
    336          
    337          /**
    338           * \brief  Sends a STOP condition. STOP Condition is sent just after completing
    339           *  the current byte transmission in master read mode.
    340           * \param twi  Pointer to an Twi instance.
    341           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    342          void twi_send_stop_condition(Twi * pTwi)
    343          {
   \                     twi_send_stop_condition:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    344          	assert(pTwi != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twi_send_stop_condition_0
   \   00000010   0xE3A02F56         MOV      R2,#+344
   \   00000014   0x........         LDR      R1,??DataTable15_5
   \   00000018   0x........         LDR      R0,??DataTable15_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    345          	pTwi->TWI_CR |= TWI_CR_STOP;
   \                     ??twi_send_stop_condition_0:
   \   00000024   0xE5940000         LDR      R0,[R4, #+0]
   \   00000028   0xE3900002         ORRS     R0,R0,#0x2
   \   0000002C   0xE5840000         STR      R0,[R4, #+0]
    346          }
   \   00000030   0xE8BD8010         POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xF8034600         DC32     0xf8034600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xF8038600         DC32     0xf8038600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xFC010600         DC32     0xfc010600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0xFC014600         DC32     0xfc014600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0xFC018600         DC32     0xfc018600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x........         DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x........         DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x........         DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x........         DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x........         DC32     ?_7

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     ?_8

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x70 0x54          DC8 "pTwi"
   \              0x77 0x69    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 62H, 75H, 73H, 5CH
   \              0x73 0x5C    
   \              0x62 0x75    
   \              0x73 0x5C    
   \   00000038   0x74 0x77          DC8 74H, 77H, 69H, 2EH, 63H, 0
   \              0x69 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x69 0x64          DC8 "id != ID_PERIPH_COUNT"
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x49 0x44    
   \              0x5F 0x50    
   \              0x45 0x52    
   \              0x49 0x50    
   \              0x48 0x5F    
   \              0x43 0x4F    
   \              0x55 0x4E    
   \              0x54 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x63 0x6B          DC8 "ck_div < 8"
   \              0x5F 0x64    
   \              0x69 0x76    
   \              0x20 0x3C    
   \              0x20 0x38    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x28 0x70          DC8 "(pTwi->TWI_CR & TWI_CR_SVDIS) != TWI_CR_SVDIS"
   \              0x54 0x77    
   \              0x69 0x2D    
   \              0x3E 0x54    
   \              0x57 0x49    
   \              0x5F 0x43    
   \              0x52 0x20    
   \              0x26 0x20    
   \              0x54 0x57    
   \              0x49 0x5F    
   \              0x43 0x52    
   \              0x5F 0x53    
   \              0x56 0x44    
   \              0x49 0x53    
   \              0x29 0x20    
   \              0x21 0x3D    
   \              0x20 0x54    
   \              0x57 0x49    
   \              0x5F 0x43    
   \              0x52 0x5F    
   \              0x53 0x56    
   \              0x44 0x49    
   \              0x53 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x70 0x54          DC8 "pTwi != NULL"
   \              0x77 0x69    
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x28 0x61          DC8 "(address & 0x80) == 0"
   \              0x64 0x64    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x20 0x26    
   \              0x20 0x30    
   \              0x78 0x38    
   \              0x30 0x29    
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x30 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x28 0x69          DC8 "(iaddress & 0xFF000000) == 0"
   \              0x61 0x64    
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x26 0x20    
   \              0x30 0x78    
   \              0x46 0x46    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x29 0x20    
   \              0x3D 0x3D    
   \              0x20 0x30    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x69 0x73          DC8 "isize < 4"
   \              0x69 0x7A    
   \              0x65 0x20    
   \              0x3C 0x20    
   \              0x34 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x28 0x73          DC8 "(sources & 0xFFFFF088) == 0"
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x73    
   \              0x20 0x26    
   \              0x20 0x30    
   \              0x78 0x46    
   \              0x46 0x46    
   \              0x46 0x46    
   \              0x30 0x38    
   \              0x38 0x29    
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x30 0x00    
    347          
    348          #ifdef FIFO_ENABLED
    349          void twi_fifo_configure(Twi* twi, uint8_t tx_thres,
    350          			uint8_t rx_thres,
    351          			uint32_t ready_modes)
    352          {
    353          	/* Disable TWI master and slave mode and activate FIFO */
    354          	twi->TWI_CR = TWI_CR_MSDIS | TWI_CR_SVDIS | TWI_CR_FIFOEN;
    355          
    356          	/* Configure FIFO */
    357          	twi->TWI_FMR = TWI_FMR_TXFTHRES(tx_thres) | TWI_FMR_RXFTHRES(rx_thres)
    358          		| ready_modes;
    359          }
    360          
    361          uint32_t twi_fifo_rx_size(Twi *twi)
    362          {
    363          	return (twi->TWI_FLR & TWI_FLR_RXFL_Msk) >> TWI_FLR_RXFL_Pos;
    364          }
    365          
    366          uint32_t twi_fifo_tx_size(Twi *twi)
    367          {
    368          	return (twi->TWI_FLR & TWI_FLR_TXFL_Msk) >> TWI_FLR_TXFL_Pos;
    369          }
    370          
    371          uint32_t twi_write_stream(Twi *twi, uint32_t addr, const void *stream, uint32_t len)
    372          {
    373          	const uint8_t* buffer = stream;
    374          	uint32_t left = len;
    375          
    376          	twi->TWI_CR = TWI_CR_MSEN | TWI_CR_SVDIS | TWI_CR_ACMEN;
    377          	twi->TWI_MMR = TWI_MMR_DADR(addr);
    378          	twi->TWI_ACR = TWI_ACR_DATAL(len) | TWI_ACR_DIR;
    379          
    380          	while (left > 0) {
    381          		if ((twi->TWI_SR & TWI_SR_TXRDY) == 0) continue;
    382          
    383          		/* Get FIFO free size (int octet) and clamp it */
    384          		uint32_t buf_size = TWI_FIFO_DEPTH - twi_fifo_tx_size(twi);
    385          		buf_size = buf_size > left ? left : buf_size;
    386          
    387          		/* Fill the FIFO as must as possible */
    388          		while (buf_size > sizeof(uint32_t)) {
    389          			twi->TWI_THR = *(uint32_t*)buffer;
    390          			buffer += sizeof(uint32_t);
    391          			left -= sizeof(uint32_t);
    392          			buf_size -= sizeof(uint32_t);
    393          		}
    394          		while (buf_size >= sizeof(uint8_t)) {
    395          			twi->TWI_THR = *(uint8_t*)buffer;
    396          			buffer += sizeof(uint16_t);
    397          			left -= sizeof(uint16_t);
    398          			buf_size -= sizeof(uint32_t);
    399          		}
    400          
    401          	}
    402          	return len - left;
    403          }
    404          
    405          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   get_twi_id_from_addr
       8   twi_byte_sent
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      32   twi_configure_master
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
        32   -> get_twi_id_from_addr
        32   -> pmc_get_peripheral_max_clock
        32 __aeabi_uidiv
      16   twi_configure_slave
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   twi_disable_it
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   twi_enable_it
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   twi_get_masked_status
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   twi_get_status
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_is_byte_received
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_is_transfer_complete
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_read_byte
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_send_stop_condition
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      24   twi_start_read
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   twi_start_write
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> twi_write_byte
       8   twi_stop
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   twi_write_byte
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       8  ?_0
      64  ?_1
      24  ?_2
      12  ?_3
      48  ?_4
      16  ?_5
      24  ?_6
      32  ?_7
      12  ?_8
      28  ?_9
      56  _id_h64_matrix
     160  get_twi_id_from_addr
      52  twi_byte_sent
     280  twi_configure_master
     196  twi_configure_slave
      84  twi_disable_it
      84  twi_enable_it
      60  twi_get_masked_status
      44  twi_get_status
      52  twi_is_byte_received
      48  twi_is_transfer_complete
      48  twi_read_byte
      52  twi_send_stop_condition
     204  twi_start_read
     212  twi_start_write
      48  twi_stop
      56  twi_write_byte

 
   324 bytes in section .rodata
 1 740 bytes in section SOFTPACK
 
 1 740 bytes of CODE  memory
   324 bytes of CONST memory

Errors: none
Warnings: 1
