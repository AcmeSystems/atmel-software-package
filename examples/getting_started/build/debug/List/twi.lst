###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        19/May/2015  13:45:52
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D24
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\twi.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\twi.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup twi_module Working with TWI
     31           * \section Purpose
     32           * The TWI driver provides the interface to configure and use the TWI
     33           * peripheral.
     34           *
     35           * \section Usage
     36           * <ul>
     37           * <li> Configures a TWI peripheral to operate in master mode, at the given
     38           * frequency (in Hz) using TWI_Configure(). </li>
     39           * <li> Sends a STOP condition on the TWI using twi_stop().</li>
     40           * <li> Starts a read operation on the TWI bus with the specified slave using
     41           * twi_start_read(). Data must then be read using twi_read_byte() whenever
     42           * a byte is available (poll using twi_is_byte_received()).</li>
     43           * <li> Starts a write operation on the TWI to access the selected slave using
     44           * twi_start_write(). A byte of data must be provided to start the write;
     45           * other bytes are written next.</li>
     46           * <li> Sends a byte of data to one of the TWI slaves on the bus using twi_write_byte().
     47           * This function must be called once before twi_start_write() with the first byte of data
     48           * to send, then it shall be called repeatedly after that to send the remaining bytes.</li>
     49           * <li> Check if a byte has been received and can be read on the given TWI
     50           * peripheral using twi_is_byte_received().<
     51           * Check if a byte has been sent using twi_byte_sent().</li>
     52           * <li> Check if the current transmission is complete (the STOP has been sent)
     53           * using twi_is_transfer_complete().</li>
     54           * <li> Enables & disable the selected interrupts sources on a TWI peripheral
     55           * using twi_enable_it() and twi_enable_it().</li>
     56           * <li> Get current status register of the given TWI peripheral using
     57           * twi_get_status(). Get current status register of the given TWI peripheral, but
     58           * masking interrupt sources which are not currently enabled using
     59           * twi_get_masked_status().</li>
     60           * </ul>
     61           * For more accurate information, please look at the TWI section of the
     62           * Datasheet.
     63           *
     64           * Related files :\n
     65           * \ref twi.c\n
     66           * \ref twi.h.\n
     67          */
     68          /*@{*/
     69          /*@}*/
     70          
     71          /**
     72           * \file
     73           *
     74           * Implementation of Two Wire Interface (TWI).
     75           *
     76           */
     77          
     78          /*----------------------------------------------------------------------------
     79           *        Headers
     80           *----------------------------------------------------------------------------*/
     81          
     82          #include "chip.h"

  	if (addr == (void*)TWI0) return ID_FLEXCOM0; /**< \brief FLEXCOM 0 (FLEXCOM0) */
  	                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",178  Error[Pe020]: 
          identifier "TWI0" is undefined

  	if (id == ID_FLEXCOM0) return TWI0; /**< \brief FLEXCOM 0 (FLEXCOM0) */
  	                              ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",206  Error[Pe020]: 
          identifier "TWI0" is undefined

  	else if (addr == (void*)FCOMSPI0) return ID_FCOMSPI0;
  	                        ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",235  Error[Pe020]: 
          identifier "FCOMSPI0" is undefined

  	else if (addr == (void*)FCOMSPI1) return ID_FCOMSPI1;
  	                        ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",236  Error[Pe020]: 
          identifier "FCOMSPI1" is undefined

  	else if (addr == (void*)FCOMSPI3) return ID_FCOMSPI3;
  	                        ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",237  Error[Pe020]: 
          identifier "FCOMSPI3" is undefined

  	else if (addr == (void*)FCOMSPI4) return ID_FCOMSPI4;
  	                        ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",238  Error[Pe020]: 
          identifier "FCOMSPI4" is undefined

  	else if (id == ID_FCOMSPI0) return FCOMSPI0; /**< \brief FLEXCOM SPI 0 (FCOMSPI0) */
  	                                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",246  Error[Pe020]: 
          identifier "FCOMSPI0" is undefined

  	else if (id == ID_FCOMSPI1) return FCOMSPI1; /**< \brief FLEXCOM SPI 1 (FCOMSPI1) */
  	                                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",247  Error[Pe020]: 
          identifier "FCOMSPI1" is undefined

  	else if (id == ID_FCOMSPI3) return FCOMSPI3; /**< \brief FLEXCOM SPI 3 (FCOMSPI3) */
  	                                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",248  Error[Pe020]: 
          identifier "FCOMSPI3" is undefined

  	else if (id == ID_FCOMSPI4) return FCOMSPI4; /**< \brief FLEXCOM SPI 4 (FCOMSPI4) */
  	                                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",249  Error[Pe020]: 
          identifier "FCOMSPI4" is undefined

  	if (addr == (void*)USART0) return ID_USART0;
  	                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",273  Error[Pe020]: 
          identifier "USART0" is undefined
     83          #include "bus/twi.h"
     84          #include "core/pmc.h"
     85          #include "utils/trace.h"
     86          
     87          #include <stddef.h>
     88          #include <assert.h>
     89          
     90          /*----------------------------------------------------------------------------
     91           *        Exported functions
     92           *----------------------------------------------------------------------------*/
     93          
     94          /**
     95           * \brief Configures a TWI peripheral to operate in master mode, at the given
     96           * frequency (in Hz). The duty cycle of the TWI clock is set to 50%.
     97           * \param twi  Pointer to an Twi instance.
     98           * \param dwTwCk  Desired TWI clock frequency.
     99           * \param dwMCk  Master clock frequency.
    100           */
    101          void twi_configure_master(Twi * pTwi, uint32_t twi_clock, uint32_t master_clock)
    102          {
    103          	uint32_t ck_div, cl_div, ok, max_clock;
    104          	uint32_t id = GET_TWI_ID_FROM_ADDR(pTwi);
    105          
    106          	TRACE_DEBUG("twi_configure_master()\n\r");
    107          	assert(pTwi);
    108          	assert(id != ID_PERIPH_COUNT);
    109          	/* SVEN: TWI Slave Mode Enabled */
    110          	pTwi->TWI_CR = TWI_CR_SVEN;
    111          	/* Reset the TWI */
    112          	pTwi->TWI_CR = TWI_CR_SWRST;
    113          	pTwi->TWI_RHR;
    114          	/* TWI Slave Mode Disabled, TWI Master Mode Disabled. */
    115          	pTwi->TWI_CR = TWI_CR_SVDIS;
    116          	pTwi->TWI_CR = TWI_CR_MSDIS;
    117          	/* Set master mode */
    118          	pTwi->TWI_CR = TWI_CR_MSEN;
    119          	max_clock = pmc_get_peripheral_max_clock(id);
    120          	/* Configure clock */
    121          	ck_div = 0; ok = 0;
    122          	while (!ok) {
    123          		cl_div = ((max_clock / (2 * twi_clock)) - 8) / (1 << ck_div);
    124          		(cl_div <= 255) ? ok = 1 : ck_div++;
    125          	}
    126          	assert(ck_div < 8);
    127          	TRACE_DEBUG("Using CKDIV = %u and CLDIV/CHDIV = %u\n\r", ck_div, cl_div);
    128          	pTwi->TWI_CWGR = 0;
    129          	pTwi->TWI_CWGR = (cl_div << 16) | (cl_div << 8) | cl_div;
    130          }
    131          
    132          /**
    133           * \brief Configures a TWI peripheral to operate in slave mode.
    134           * \param twi  Pointer to an Twi instance.
    135           * \param slaveAddress Slave address.
    136           */
    137          void twi_configure_slave(Twi * pTwi, uint8_t slave_address)
    138          {
    139          	uint32_t i;
    140          
    141          	TRACE_DEBUG("twi_configure_slave()\n\r");
    142          	assert(pTwi);
    143          	/* TWI software reset */
    144          	pTwi->TWI_CR = TWI_CR_SWRST;
    145          	pTwi->TWI_RHR;
    146          	/* Wait at least 10 ms */
    147          	for (i = 0; i < 1000000; i++) ;
    148          	/* TWI Slave Mode Disabled, TWI Master Mode Disabled */
    149          	pTwi->TWI_CR = TWI_CR_SVDIS | TWI_CR_MSDIS;
    150          	/* Configure slave address. */
    151          	pTwi->TWI_SMR = 0;
    152          	pTwi->TWI_SMR = TWI_SMR_SADR(slave_address);
    153          	/* SVEN: TWI Slave Mode Enabled */
    154          	pTwi->TWI_CR = TWI_CR_SVEN;
    155          	/* Wait at least 10 ms */
    156          	for (i = 0; i < 1000000; i++) ;
    157          	assert((pTwi->TWI_CR & TWI_CR_SVDIS) != TWI_CR_SVDIS);
    158          }
    159          
    160          /**
    161           * \brief Sends a STOP condition on the TWI.
    162           * \param twi  Pointer to an Twi instance.
    163           */
    164          void twi_stop(Twi * pTwi)
    165          {
    166          	assert(pTwi != NULL);
    167          	pTwi->TWI_CR = TWI_CR_STOP;
    168          }
    169          
    170          /**
    171           * \brief Starts a read operation on the TWI bus with the specified slave, it returns
    172           * immediately. Data must then be read using twi_read_byte() whenever a byte is
    173           * available (poll using twi_is_byte_received()).
    174           * \param twi  Pointer to an Twi instance.
    175           * \param address  Slave address on the bus.
    176           * \param iaddress  Optional internal address bytes.
    177           * \param isize  Number of internal address bytes.
    178           */
    179          void twi_start_read(Twi * pTwi, uint8_t address, uint32_t iaddress, uint8_t isize)
    180          {
    181          	assert(pTwi != NULL);
    182          	assert((address & 0x80) == 0);
    183          	assert((iaddress & 0xFF000000) == 0);
    184          	assert(isize < 4);
    185          	/* Set slave address and number of internal address bytes. */
    186          	pTwi->TWI_MMR = 0;
    187          	pTwi->TWI_MMR = (isize << 8) | TWI_MMR_MREAD | (address << 16);
    188          	/* Set internal address bytes */
    189          	pTwi->TWI_IADR = 0;
    190          	pTwi->TWI_IADR = iaddress;
    191          	/* Send START condition */
    192          	pTwi->TWI_CR = TWI_CR_START;
    193          }
    194          
    195          /**
    196           * \brief Reads a byte from the TWI bus. The read operation must have been started
    197           * using twi_start_read() and a byte must be available (check with twi_is_byte_received()).
    198           * \param twi  Pointer to an Twi instance.
    199           * \return byte read.
    200           */
    201          uint8_t twi_read_byte(Twi * pTwi)
    202          {
    203          	assert(pTwi != NULL);
    204          	return pTwi->TWI_RHR;
    205          }
    206          
    207          /**
    208           * \brief Sends a byte of data to one of the TWI slaves on the bus.
    209           * \note This function must be called once before twi_start_write() with
    210           * the first byte of data  to send, then it shall be called repeatedly
    211           * after that to send the remaining bytes.
    212           * \param twi  Pointer to an Twi instance.
    213           * \param byte  Byte to send.
    214           */
    215          void twi_write_byte(Twi * pTwi, uint8_t byte)
    216          {
    217          	assert(pTwi != NULL);
    218          	pTwi->TWI_THR = byte;
    219          }
    220          
    221          /**
    222           * \brief Starts a write operation on the TWI to access the selected slave, then
    223           *  returns immediately. A byte of data must be provided to start the write;
    224           * other bytes are written next.
    225           * after that to send the remaining bytes.
    226           * \param twi  Pointer to an Twi instance.
    227           * \param address  Address of slave to acccess on the bus.
    228           * \param iaddress  Optional slave internal address.
    229           * \param isize  Number of internal address bytes.
    230           * \param byte  First byte to send.
    231           */
    232          void twi_start_write(Twi * pTwi, uint8_t address, uint32_t iaddress, uint8_t isize, uint8_t byte)
    233          {
    234          	assert(pTwi != NULL);
    235          	assert((address & 0x80) == 0);
    236          	assert((iaddress & 0xFF000000) == 0);
    237          	assert(isize < 4);
    238          	/* Set slave address and number of internal address bytes. */
    239          	pTwi->TWI_MMR = 0;
    240          	pTwi->TWI_MMR = (isize << 8) | (address << 16);
    241          	/* Set internal address bytes. */
    242          	pTwi->TWI_IADR = 0;
    243          	pTwi->TWI_IADR = iaddress;
    244          	/* Write first byte to send. */
    245          	twi_write_byte(pTwi, byte);
    246          }
    247          
    248          /**
    249           * \brief Check if a byte have been receiced from TWI.
    250           * \param twi  Pointer to an Twi instance.
    251           * \return 1 if a byte has been received and can be read on the given TWI
    252           * peripheral; otherwise, returns 0. This function resets the status register.
    253           */
    254          uint8_t twi_is_byte_received(Twi * pTwi)
    255          {
    256          	assert(pTwi != NULL);
    257          	return ((pTwi->TWI_SR & TWI_SR_RXRDY) == TWI_SR_RXRDY);
    258          }
    259          
    260          /**
    261           * \brief Check if a byte have been sent to TWI.
    262           * \param twi  Pointer to an Twi instance.
    263           * \return 1 if a byte has been sent  so another one can be stored for
    264           * transmission; otherwise returns 0. This function clears the status register.
    265           */
    266          uint8_t twi_byte_sent(Twi * pTwi)
    267          {
    268          	assert(pTwi != NULL);
    269          	return ((pTwi->TWI_SR & TWI_SR_TXRDY) == TWI_SR_TXRDY);
    270          }
    271          
    272          /**
    273           * \brief Check if current transmission is complet.
    274           * \param twi  Pointer to an Twi instance.
    275           * \return  1 if the current transmission is complete (the STOP has been sent);
    276           * otherwise returns 0.
    277           */
    278          uint8_t twi_is_transfer_complete(Twi * pTwi)
    279          {
    280          	assert(pTwi != NULL);
    281          	return ((pTwi->TWI_SR & TWI_SR_TXCOMP) == TWI_SR_TXCOMP);
    282          }
    283          
    284          /**
    285           * \brief Enables the selected interrupts sources on a TWI peripheral.
    286           * \param twi  Pointer to an Twi instance.
    287           * \param sources  Bitwise OR of selected interrupt sources.
    288           */
    289          void twi_enable_it(Twi * pTwi, uint32_t sources)
    290          {
    291          	assert(pTwi != NULL);
    292          	assert((sources & 0xFFFFF088) == 0);
    293          	pTwi->TWI_IER = sources;
    294          }
    295          
    296          /**
    297           * \brief Disables the selected interrupts sources on a TWI peripheral.
    298           * \param twi  Pointer to an Twi instance.
    299           * \param sources  Bitwise OR of selected interrupt sources.
    300           */
    301          void twi_disable_it(Twi * pTwi, uint32_t sources)
    302          {
    303          	assert(pTwi != NULL);
    304          	assert((sources & 0xFFFFF088) == 0);
    305          	pTwi->TWI_IDR = sources;
    306          }
    307          
    308          /**
    309           * \brief Get the current status register of the given TWI peripheral.
    310           * \note This resets the internal value of the status register, so further
    311           * read may yield different values.
    312           * \param twi  Pointer to an Twi instance.
    313           * \return  TWI status register.
    314           */
    315          uint32_t twi_get_status(Twi * pTwi)
    316          {
    317          	assert(pTwi != NULL);
    318          	return pTwi->TWI_SR;
    319          }
    320          
    321          /**
    322           * \brief Returns the current status register of the given TWI peripheral, but
    323           * masking interrupt sources which are not currently enabled.
    324           * \note This resets the internal value of the status register, so further
    325           * read may yield different values.
    326           * \param twi  Pointer to an Twi instance.
    327           */
    328          uint32_t twi_get_masked_status(Twi * pTwi)
    329          {
    330          	uint32_t status;
    331          	assert(pTwi != NULL);
    332          	status = pTwi->TWI_SR;
    333          	status &= pTwi->TWI_IMR;
    334          	return status;
    335          }
    336          
    337          /**
    338           * \brief  Sends a STOP condition. STOP Condition is sent just after completing
    339           *  the current byte transmission in master read mode.
    340           * \param twi  Pointer to an Twi instance.
    341           */
    342          void twi_send_stop_condition(Twi * pTwi)
    343          {
    344          	assert(pTwi != NULL);
    345          	pTwi->TWI_CR |= TWI_CR_STOP;
    346          }
    347          
    348          #ifdef FIFO_ENABLED
    349          void twi_fifo_configure(Twi* twi, uint8_t tx_thres,
    350          			uint8_t rx_thres,
    351          			uint32_t ready_modes)
    352          {
    353          	/* Disable TWI master and slave mode and activate FIFO */
    354          	twi->TWI_CR = TWI_CR_MSDIS | TWI_CR_SVDIS | TWI_CR_FIFOEN;
    355          
    356          	/* Configure FIFO */
    357          	twi->TWI_FMR = TWI_FMR_TXFTHRES(tx_thres) | TWI_FMR_RXFTHRES(rx_thres)
    358          		| ready_modes;
    359          }
    360          
    361          uint32_t twi_fifo_rx_size(Twi *twi)
    362          {
    363          	return (twi->TWI_FLR & TWI_FLR_RXFL_Msk) >> TWI_FLR_RXFL_Pos;
    364          }
    365          
    366          uint32_t twi_fifo_tx_size(Twi *twi)
    367          {
    368          	return (twi->TWI_FLR & TWI_FLR_TXFL_Msk) >> TWI_FLR_TXFL_Pos;
    369          }
    370          
    371          uint32_t twi_write_stream(Twi *twi, uint32_t addr, const void *stream, uint32_t len)
    372          {
    373          	const uint8_t* buffer = stream;
    374          	uint32_t left = len;
    375          
    376          	twi->TWI_CR = TWI_CR_MSEN | TWI_CR_SVDIS | TWI_CR_ACMEN;
    377          	twi->TWI_MMR = TWI_MMR_DADR(addr);
    378          	twi->TWI_ACR = TWI_ACR_DATAL(len) | TWI_ACR_DIR;
    379          
    380          	while (left > 0) {
    381          		if ((twi->TWI_SR & TWI_SR_TXRDY) == 0) continue;
    382          
    383          		/* Get FIFO free size (int octet) and clamp it */
    384          		uint32_t buf_size = TWI_FIFO_DEPTH - twi_fifo_tx_size(twi);
    385          		buf_size = buf_size > left ? left : buf_size;
    386          
    387          		/* Fill the FIFO as must as possible */
    388          		while (buf_size > sizeof(uint32_t)) {
    389          			twi->TWI_THR = *(uint32_t*)buffer;
    390          			buffer += sizeof(uint32_t);
    391          			left -= sizeof(uint32_t);
    392          			buf_size -= sizeof(uint32_t);
    393          		}
    394          		while (buf_size >= sizeof(uint8_t)) {
    395          			twi->TWI_THR = *(uint8_t*)buffer;
    396          			buffer += sizeof(uint16_t);
    397          			left -= sizeof(uint16_t);
    398          			buf_size -= sizeof(uint32_t);
    399          		}
    400          
    401          	}
    402          	return len - left;
    403          }
    404          
    405          #endif

Errors: 11
Warnings: 1
