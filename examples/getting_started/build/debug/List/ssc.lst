###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\ssc.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\ssc.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\ssc.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\ssc.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\bus\ssc.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2012, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup ssc_module Working with SSC
     31           * \section Purpose
     32           * The SSC driver provides the interface to configure and use the SSC
     33           * peripheral.
     34           *
     35           * \section Usage
     36           * -# Enable the SSC interface pins.
     37           * -# Configure the SSC to operate at a specific frequency by calling
     38           *    SSC_Configure(). This function enables the peripheral clock of the SSC,
     39           *    but not its PIOs.
     40           * -# Configure the transmitter and/or the receiver using the
     41           *    SSC_ConfigureTransmitter() and SSC_ConfigureEmitter() functions.
     42           * -# Enable the PIOs or the transmitter and/or the received.
     43           * -# Enable the transmitter and/or the receiver using SSC_EnableTransmitter()
     44           *    and SSC_EnableReceiver()
     45           * -# Send data through the transmitter using SSC_Write()
     46           * -# Receive data from the receiver using SSC_Read()
     47           * -# Disable the transmitter and/or the receiver using SSC_DisableTransmitter()
     48           *    and SSC_DisableReceiver()
     49           *
     50           * For more accurate information, please look at the SSC section of the
     51           * Datasheet.
     52           *
     53           * Related files :\n
     54           * \ref ssc.c\n
     55           * \ref ssc.h.\n
     56          */
     57          /*@{*/
     58          /*@}*/
     59          
     60          /**
     61           * \file
     62           *
     63           * Implementation of Synchronous Serial (SSC) controller.
     64           *
     65           */
     66          
     67          /*----------------------------------------------------------------------------
     68           *        Headers
     69           *----------------------------------------------------------------------------*/
     70          
     71          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     72          #include "bus/ssc.h"
     73          #include "core/pmc.h"
     74          /*----------------------------------------------------------------------------
     75           *       Exported functions
     76           *----------------------------------------------------------------------------*/
     77          
     78          /**
     79           * \brief Configures a SSC peripheral.If the divided clock is not used, the master
     80           * clock frequency can be set to 0.
     81           * \note The emitter and transmitter are disabled by this function.
     82           * \param ssc  Pointer to an SSC instance.
     83           * \param bitRate  bit rate.
     84           * \param masterClock  master clock.
     85           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     86          void
     87          SSC_Configure(Ssc * ssc, uint32_t bitRate, uint32_t masterClock)
     88          {
   \                     SSC_Configure:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
     89          	uint32_t id;
     90          	uint32_t maxClock;
     91          	id = (ssc == SSC0) ? ID_SSC0 : ID_SSC1;
   \   00000010   0xE3A004F8         MOV      R0,#-134217728
   \   00000014   0xE3800C40         ORR      R0,R0,#0x4000
   \   00000018   0xE1540000         CMP      R4,R0
   \   0000001C   0x1A000001         BNE      ??SSC_Configure_0
   \   00000020   0xE3A0702B         MOV      R7,#+43
   \   00000024   0xEA000000         B        ??SSC_Configure_1
   \                     ??SSC_Configure_0:
   \   00000028   0xE3A0702C         MOV      R7,#+44
     92          	maxClock = pmc_set_peripheral_max_clock(id);
   \                     ??SSC_Configure_1:
   \   0000002C   0xE1B00007         MOVS     R0,R7
   \   00000030   0x........         BL       pmc_set_peripheral_max_clock
   \   00000034   0xE1B08000         MOVS     R8,R0
     93          
     94          	/* Reset, disable receiver & transmitter */
     95          	ssc->SSC_CR = SSC_CR_RXDIS | SSC_CR_TXDIS | SSC_CR_SWRST;
   \   00000038   0xE3080202         MOVW     R0,#+33282
   \   0000003C   0xE5840000         STR      R0,[R4, #+0]
     96          
     97          	/* Configure clock frequency */
     98          	if (bitRate != 0) {
   \   00000040   0xE3550000         CMP      R5,#+0
   \   00000044   0x0A000004         BEQ      ??SSC_Configure_2
     99          
    100          		ssc->SSC_CMR = maxClock / (2 * bitRate);
   \   00000048   0xE1B00008         MOVS     R0,R8
   \   0000004C   0xE1B01085         LSLS     R1,R5,#+1
   \   00000050   0x........         BL       __aeabi_uidiv
   \   00000054   0xE5840004         STR      R0,[R4, #+4]
   \   00000058   0xEA000001         B        ??SSC_Configure_3
    101          	} else {
    102          
    103          		ssc->SSC_CMR = 0;
   \                     ??SSC_Configure_2:
   \   0000005C   0xE3A00000         MOV      R0,#+0
   \   00000060   0xE5840004         STR      R0,[R4, #+4]
    104          	}
    105          	/* Enable SSC peripheral clock */
    106          	//pmc_enable_peripheral(id);
    107          }
   \                     ??SSC_Configure_3:
   \   00000064   0xE8BD81F0         POP      {R4-R8,PC}       ;; return
    108          
    109          /**
    110           * \brief Configures the transmitter of a SSC peripheral.
    111           * \param ssc  Pointer to an SSC instance.
    112           * \param tcmr Transmit Clock Mode Register value.
    113           * \param tfmr Transmit Frame Mode Register value.
    114           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    115          void
    116          SSC_ConfigureTransmitter(Ssc * ssc, uint32_t tcmr, uint32_t tfmr)
    117          {
    118          	ssc->SSC_TCMR = tcmr;
   \                     SSC_ConfigureTransmitter:
   \   00000000   0xE5801018         STR      R1,[R0, #+24]
    119          	ssc->SSC_TFMR = tfmr;
   \   00000004   0xE580201C         STR      R2,[R0, #+28]
    120          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    121          
    122          /**
    123           * \brief Configures the receiver of a SSC peripheral.
    124           * \param ssc  Pointer to an SSC instance.
    125           * \param rcmr Receive Clock Mode Register value.
    126           * \param rfmr Receive Frame Mode Register value.
    127           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    128          void
    129          SSC_ConfigureReceiver(Ssc * ssc, uint32_t rcmr, uint32_t rfmr)
    130          {
    131          	ssc->SSC_RCMR = rcmr;
   \                     SSC_ConfigureReceiver:
   \   00000000   0xE5801010         STR      R1,[R0, #+16]
    132          	ssc->SSC_RFMR = rfmr;
   \   00000004   0xE5802014         STR      R2,[R0, #+20]
    133          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    134          
    135          /**
    136           * \brief Enables the transmitter of a SSC peripheral.
    137           * \param ssc  Pointer to an SSC instance.
    138           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    139          void
    140          SSC_EnableTransmitter(Ssc * ssc)
    141          {
    142          	ssc->SSC_CR = SSC_CR_TXEN;
   \                     SSC_EnableTransmitter:
   \   00000000   0xE3A01F40         MOV      R1,#+256
   \   00000004   0xE5801000         STR      R1,[R0, #+0]
    143          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    144          
    145          /**
    146           * \brief Disables the transmitter of a SSC peripheral.
    147           * \param ssc  Pointer to an SSC instance.
    148           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    149          void
    150          SSC_DisableTransmitter(Ssc * ssc)
    151          {
    152          	ssc->SSC_CR = SSC_CR_TXDIS;
   \                     SSC_DisableTransmitter:
   \   00000000   0xE3A01F80         MOV      R1,#+512
   \   00000004   0xE5801000         STR      R1,[R0, #+0]
    153          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    154          
    155          /**
    156           * \brief Enables the receiver of a SSC peripheral.
    157           * \param ssc  Pointer to an SSC instance.
    158           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    159          void
    160          SSC_EnableReceiver(Ssc * ssc)
    161          {
    162          	ssc->SSC_CR = SSC_CR_RXEN;
   \                     SSC_EnableReceiver:
   \   00000000   0xE3A01001         MOV      R1,#+1
   \   00000004   0xE5801000         STR      R1,[R0, #+0]
    163          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    164          
    165          /**
    166           * \brief Disables the receiver of a SSC peripheral.
    167           * \param ssc  Pointer to an SSC instance.
    168           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    169          void
    170          SSC_DisableReceiver(Ssc * ssc)
    171          {
    172          	ssc->SSC_CR = SSC_CR_RXDIS;
   \                     SSC_DisableReceiver:
   \   00000000   0xE3A01002         MOV      R1,#+2
   \   00000004   0xE5801000         STR      R1,[R0, #+0]
    173          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    174          
    175          /**
    176           * \brief Enables one or more interrupt sources of a SSC peripheral.
    177           * \param ssc  Pointer to an SSC instance.
    178           * \param sources Bitwise OR of selected interrupt sources.
    179           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    180          void
    181          SSC_EnableInterrupts(Ssc * ssc, uint32_t sources)
    182          {
    183          	ssc->SSC_IER = sources;
   \                     SSC_EnableInterrupts:
   \   00000000   0xE5801044         STR      R1,[R0, #+68]
    184          }
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    185          
    186          /**
    187           * \brief Disables one or more interrupt sources of a SSC peripheral.
    188           * \param ssc  Pointer to an SSC instance.
    189           * \param sources Bitwise OR of selected interrupt sources.
    190           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    191          void
    192          SSC_DisableInterrupts(Ssc * ssc, uint32_t sources)
    193          {
    194          	ssc->SSC_IDR = sources;
   \                     SSC_DisableInterrupts:
   \   00000000   0xE5801048         STR      R1,[R0, #+72]
    195          }
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    196          
    197          /**
    198           * \brief Sends one data frame through a SSC peripheral. If another frame is currently
    199           * being sent, this function waits for the previous transfer to complete.
    200           * \param ssc  Pointer to an SSC instance.
    201           * \param frame Data frame to send.
    202           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    203          void
    204          SSC_Write(Ssc * ssc, uint32_t frame)
    205          {
    206          	while ((ssc->SSC_SR & SSC_SR_TXRDY) == 0) ;
   \                     SSC_Write:
   \                     ??SSC_Write_0:
   \   00000000   0xE5902040         LDR      R2,[R0, #+64]
   \   00000004   0xE3120001         TST      R2,#0x1
   \   00000008   0x0AFFFFFC         BEQ      ??SSC_Write_0
    207          	ssc->SSC_THR = frame;
   \   0000000C   0xE5801024         STR      R1,[R0, #+36]
    208          }
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    209          
    210          /**
    211           * \brief Waits until one frame is received on a SSC peripheral, and returns it.
    212           * \param ssc  Pointer to an SSC instance.
    213           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    214          uint32_t
    215          SSC_Read(Ssc * ssc)
    216          {
    217          	while ((ssc->SSC_SR & SSC_SR_RXRDY) == 0) ;
   \                     SSC_Read:
   \                     ??SSC_Read_0:
   \   00000000   0xE5901040         LDR      R1,[R0, #+64]
   \   00000004   0xE3110010         TST      R1,#0x10
   \   00000008   0x0AFFFFFC         BEQ      ??SSC_Read_0
    218          	return ssc->SSC_RHR;
   \   0000000C   0xE5900020         LDR      R0,[R0, #+32]
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    219          }
    220          
    221          /**
    222           * \brief Return 1 if one frame is received, 0 otherwise.
    223           * \param ssc  Pointer to an SSC instance.
    224           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    225          uint8_t
    226          SSC_IsRxReady(Ssc * ssc)
    227          {
    228          	return ((ssc->SSC_SR & SSC_SR_RXRDY) > 0);
   \                     SSC_IsRxReady:
   \   00000000   0xE5900040         LDR      R0,[R0, #+64]
   \   00000004   0xE1B00220         LSRS     R0,R0,#+4
   \   00000008   0xE2100001         ANDS     R0,R0,#0x1
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    229          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SSC_Configure
        24   -> pmc_set_peripheral_max_clock
        24 __aeabi_uidiv
       0   SSC_ConfigureReceiver
       0   SSC_ConfigureTransmitter
       0   SSC_DisableInterrupts
       0   SSC_DisableReceiver
       0   SSC_DisableTransmitter
       0   SSC_EnableInterrupts
       0   SSC_EnableReceiver
       0   SSC_EnableTransmitter
       0   SSC_IsRxReady
       0   SSC_Read
       0   SSC_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     104  SSC_Configure
      12  SSC_ConfigureReceiver
      12  SSC_ConfigureTransmitter
       8  SSC_DisableInterrupts
      12  SSC_DisableReceiver
      12  SSC_DisableTransmitter
       8  SSC_EnableInterrupts
      12  SSC_EnableReceiver
      12  SSC_EnableTransmitter
      16  SSC_IsRxReady
      20  SSC_Read
      20  SSC_Write
      56  _id_h64_matrix

 
  56 bytes in section .rodata
 248 bytes in section SOFTPACK
 
 248 bytes of CODE  memory
  56 bytes of CONST memory

Errors: none
Warnings: 1
