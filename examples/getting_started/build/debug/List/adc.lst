###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        19/May/2015  10:33:51
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\adc.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\adc.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D21
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\adc.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\adc.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\core\adc.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2012, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup adc_module Working with ADC
     31           * \ingroup peripherals_module
     32           * \section Purpose
     33           * The ADC driver provides the interface to configure and use the ADC peripheral.
     34           * \n
     35           *
     36           * It converts the analog input to digital format. The converted result could be
     37           * 10bit. The ADC supports up to 16 analog lines.
     38           *
     39           * To Enable a ADC conversion,the user has to follow these few steps:
     40           * <ul>
     41           * <li> Select an appropriate reference voltage on ADVREF   </li>
     42           * <li> Configure the ADC according to its requirements and special needs,which
     43           * could be  broken down into several parts:
     44           * -#   Select the resolution by setting or clearing ADC_MR_LOWRES bit in
     45           *      ADC_MR (Mode Register)
     46           * -#   Set ADC clock by setting ADC_MR_PRESCAL bits in ADC_MR, the clock is
     47           *      calculated with ADCClock = MCK / ( (PRESCAL+1) * 2 )
     48           * -#   Set Startup Time,Tracking Clock cycles and Transfer Clock respectively
     49           *      in ADC_MR.
     50           </li>
     51           * <li> Start conversion by setting ADC_CR_START in ADC_CR. </li>
     52           * </ul>
     53           *
     54           * \section Usage
     55           * <ul>
     56           * <li> Initialize the ADC controller using adc_initialize().
     57           * <li> ADC clock and timing configuration using adc_set_clock() and adc_set_timing().
     58           * <li> For ADC trigger using adc_set_trigger(), adc_set_trigger_mode() and
     59           * adc_set_trigger_period().
     60           * <li> For ADC sequence mode using adc_set_sequence_mode(), adc_set_sequence() and
     61           * adc_set_sequence_by_list().
     62           * <li> For ADC compare mode using adc_set_compare_channel(), adc_set_compare_mode()
     63           * and adc_set_comparison_window().
     64           * <li> ADC works with touchscreen using adc_ts_calibration(), adc_set_ts_mode(),
     65           * adc_set_ts_debounce(), adc_set_ts_pen_detect(), adc_set_ts_average(),
     66           * adc_get_ts_xposition(), adc_get_ts_yposition() and adc_get_ts_pressure().
     67           * </li>
     68           * </ul>
     69           *
     70           * For more accurate information, please look at the ADC section of the
     71           * Datasheet.
     72           *
     73           * Related files :\n
     74           * \ref adc.c\n
     75           * \ref adc.h\n
     76           */
     77          /**
     78           * \file
     79           *
     80           * Implementation of Analog-to-Digital Converter (ADC).
     81           *
     82           */
     83          /*----------------------------------------------------------------------------
     84           *        Headers
     85           *----------------------------------------------------------------------------*/
     86          
     87          #include "chip.h"
     88          #include "core/adc.h"
     89          #include "core/pmc.h"
     90          
     91          #include <stdio.h>
     92          /*----------------------------------------------------------------------------
     93           *        Local variables
     94           *----------------------------------------------------------------------------*/
     95          
     96          /** Current working clock */
     97          static uint32_t dwAdcClock = 0;
     98          
     99          /*----------------------------------------------------------------------------
    100           *        Exported functions
    101           *----------------------------------------------------------------------------*/
    102          
    103          /**
    104           * \brief Initialize the ADC controller
    105           *
    106           * \param pAdc Pointer to an Adc instance.
    107           * \param dwID ADC Index
    108           */
    109          void
    110          adc_initialize(Adc * pAdc, uint32_t dwID)
    111          {
    112          	/* Enable peripheral clock */
    113          	pmc_enable_peripheral(dwID);
    114          
    115          	/*  Reset the controller */
    116          	pAdc->ADC_CR = ADC_CR_SWRST;
    117          
    118          	/* Reset Mode Register */
    119          	pAdc->ADC_MR = 0;
    120          
    121          }
    122          
    123          /**
    124           * \brief Set ADC clock.
    125           *
    126           * \param pAdc Pointer to an Adc instance.
    127           * \param dwClk Desired ADC clock frequency.
    128           * \param dwMck Current MCK (Hz)
    129           *
    130           * \return ADC clock
    131           */
    132          //dwAdcClock = adc_set_clock( ADC, 2, dwMaxAdcClock ) ;
    133          
    134          extern uint32_t
    135          adc_set_clock(Adc * pAdc, uint32_t dwClk, uint32_t dwMck)
    136          {
    137          	uint32_t dwPres, dwMr;
    138          	/* Formula for PRESCAL is:
    139          	   ADCClock = MCK / ( (PRESCAL+1) * 2 )
    140          	   PRESCAL = (MCK / (2 * ADCCLK)) + 1
    141          	   First, we do the division, multiplied by 10 to get higher precision
    142          	   If the last digit is not zero, we round up to avoid generating a higher
    143          	   than required frequency. */
    144          	dwPres = (dwMck * 5) / dwClk;
    145          	if (dwPres % 10)
    146          		dwPres = dwPres / 10;
    147          	else {
    148          		if (dwPres == 0)
    149          			return 0;
    150          		dwPres = dwPres / 10 - 1;
    151          	}
    152          
    153          	dwMr = ADC_MR_PRESCAL(dwPres);
    154          	if (dwMr == 0)
    155          		return 0;
    156          
    157          	dwMr |= (pAdc->ADC_MR & ~ADC_MR_PRESCAL_Msk);
    158          	pAdc->ADC_MR = dwMr;
    159          
    160          	dwAdcClock = dwMck / (dwPres + 1) / 2;
    161          	//dwAdcClock = dwAdcClock / 1000 * 1000;
    162          	return dwAdcClock;
    163          }
    164          
    165          /**
    166           * \brief Set ADC timing.
    167           *
    168           * \param pAdc Pointer to an Adc instance.
    169           * \param dwStartup startup value
    170           * \param dwTracking tracking value
    171           * \param dwSettling settling value
    172           */
    173          void
    174          adc_set_timing(Adc * pAdc, uint32_t dwStartup, uint32_t dwTracking,
    175          	      uint32_t dwSettling)
    176          {
    177          	uint32_t dwMr;
    178          
    179          	dwMr = pAdc->ADC_MR;
    180          	dwMr &= (~ADC_MR_STARTUP_Msk) & (~ADC_MR_TRACKTIM_Msk);
    181          
    182          	/* Formula:
    183          	 *     Startup  Time = startup value / ADCClock
    184          	 *     Transfer Time = (TRANSFER * 2 + 3) / ADCClock
    185          	 *     Tracking Time = (TRACKTIM + 1) / ADCClock
    186          	 *     Settling Time = settling value / ADCClock
    187          	 */
    188          	dwMr |= dwStartup | dwTracking | dwSettling;
    189          	pAdc->ADC_MR |= dwMr;
    190          }
    191          
    192          /**
    193           * \brief Set ADC trigger.
    194           *
    195           * \param pAdc Pointer to an Adc instance.
    196           * \param dwTrgSel Trigger selection
    197           */
    198          void
    199          adc_set_trigger(Adc * pAdc, uint32_t dwTrgSel)
    200          {
    201          	uint32_t dwMr;
    202          
    203          	dwMr = pAdc->ADC_MR;
    204          	dwMr &= ~ADC_MR_TRGSEL_Msk;
                 	         ^
Error[Pe020]: identifier "ADC_MR_TRGSEL_Msk" is undefined
    205          	dwMr |= dwTrgSel;
    206          	pAdc->ADC_MR |= dwMr;
    207          }
    208          
    209          /**
    210           * Sets the trigger mode to following:
    211           * - \ref ADC_TRGR_TRGMOD_NO_TRIGGER
    212           * - \ref ADC_TRGR_TRGMOD_EXT_TRIG_RISE
    213           * - \ref ADC_TRGR_TRGMOD_EXT_TRIG_FALL
    214           * - \ref ADC_TRGR_TRGMOD_EXT_TRIG_ANY
    215           * - \ref ADC_TRGR_TRGMOD_PEN_TRIG
    216           * - \ref ADC_TRGR_TRGMOD_PERIOD_TRIG
    217           * - \ref ADC_TRGR_TRGMOD_CONTINUOUS
    218           * \param pAdc   Pointer to an Adc instance.
    219           * \param dwMode Trigger mode.
    220           */
    221          void
    222          adc_set_trigger_mode(Adc * pAdc, uint32_t dwMode)
    223          {
    224          	uint32_t dwTrgr = pAdc->ADC_TRGR & ~ADC_TRGR_TRGMOD_Msk;
    225          	pAdc->ADC_TRGR = dwTrgr | dwMode;
    226          }
    227          
    228          /**
    229           * \brief Enable/Disable low resolution.
    230           *
    231           * \param pAdc Pointer to an Adc instance.
    232           * \param bEnDis Enable/Disable low resolution.
    233           */
    234          void
    235          adc_set_low_resolution(Adc * pAdc, uint32_t bEnDis)
    236          {
    237          	if (bEnDis) {
    238          		pAdc->ADC_MR |= ADC_MR_LOWRES;
                 		                ^
Error[Pe020]: identifier "ADC_MR_LOWRES" is undefined
    239          	} else {
    240          		pAdc->ADC_MR &= ~ADC_MR_LOWRES;
                 		                 ^
Error[Pe020]: identifier "ADC_MR_LOWRES" is undefined
    241          	}
    242          }
    243          
    244          /**
    245           * \brief Enable/Disable sleep mode.
    246           *
    247           * \param pAdc Pointer to an Adc instance.
    248           * \param bEnDis Enable/Disable sleep mode.
    249           */
    250          void
    251          adc_set_sleep_mode(Adc * pAdc, uint8_t bEnDis)
    252          {
    253          	if (bEnDis) {
    254          		pAdc->ADC_MR |= ADC_MR_SLEEP;
    255          	} else {
    256          		pAdc->ADC_MR &= ~ADC_MR_SLEEP;
    257          	}
    258          }
    259          
    260          /**
    261           * \brief Enable/Disable seqnence mode.
    262           *
    263           * \param pAdc  Pointer to an Adc instance.
    264           * \param bEnDis Enable/Disable seqnence mode.
    265           */
    266          void
    267          adc_set_sequence_mode(Adc * pAdc, uint8_t bEnDis)
    268          {
    269          	if (bEnDis) {
    270          		/* User Sequence Mode: The sequence respects what is defined in
    271          		   ADC_SEQR1 and ADC_SEQR2 */
    272          		pAdc->ADC_MR |= ADC_MR_USEQ;
    273          	} else {
    274          		/* Normal Mode: The controller converts channels in a simple numeric order. */
    275          		pAdc->ADC_MR &= ~ADC_MR_USEQ;
    276          	}
    277          }
    278          
    279          /**
    280           * \brief Set channel sequence.
    281           *
    282           * \param pAdc   Pointer to an Adc instance.
    283           * \param dwSEQ1 Sequence 1 ~ 8  channel number.
    284           * \param dwSEQ2 Sequence 9 ~ 16 channel number.
    285           */
    286          void
    287          adc_set_sequence(Adc * pAdc, uint32_t dwSEQ1, uint32_t dwSEQ2)
    288          {
    289          	pAdc->ADC_SEQR1 = dwSEQ1;
    290          }
    291          
    292          /**
    293           * \brief Set channel sequence by given channel list.
    294           *
    295           * \param pAdc    Pointer to an Adc instance.
    296           * \param ucChList Channel list.
    297           * \param ucNumCh  Number of channels in list.
    298           */
    299          void
    300          adc_set_sequence_by_list(Adc * pAdc, uint8_t ucChList[], uint8_t ucNumCh)
    301          {
    302          	uint8_t i;
    303          	uint8_t ucShift;
    304          
    305          	pAdc->ADC_SEQR1 = 0;
    306          	for (i = 0, ucShift = 0; i < 8; i++, ucShift += 4) {
    307          		if (i >= ucNumCh)
    308          			return;
    309          		pAdc->ADC_SEQR1 |= ucChList[i] << ucShift;
    310          
    311          	}
    312          }
    313          
    314          /**
    315           * \brief Set "TAG" mode, show channel number in last data or not.
    316           *
    317           * \param pAdc   Pointer to an Adc instance.
    318           * \param bEnDis Enable/Disable TAG value.
    319           */
    320          void
    321          adc_set_tag_enable(Adc * pAdc, uint8_t bEnDis)
    322          {
    323          	if (bEnDis) {
    324          		pAdc->ADC_EMR |= ADC_EMR_TAG;
    325          	} else {
    326          		pAdc->ADC_EMR &= ~ADC_EMR_TAG;
    327          	}
    328          }
    329          
    330          /**
    331           * \brief Set compare channel.
    332           *
    333           * \param pAdc Pointer to an Adc instance.
    334           * \param dwChannel channel number to be set,16 for all channels
    335           */
    336          void
    337          adc_set_compare_channel(Adc * pAdc, uint32_t dwChannel)
    338          {
    339          	assert(dwChannel <= 16);
    340          
    341          	if (dwChannel < 16) {
    342          		pAdc->ADC_EMR &= ~(ADC_EMR_CMPALL);
    343          		pAdc->ADC_EMR &= ~(ADC_EMR_CMPSEL_Msk);
    344          		pAdc->ADC_EMR |= (dwChannel << ADC_EMR_CMPSEL_Pos);
    345          	} else {
    346          		pAdc->ADC_EMR |= ADC_EMR_CMPALL;
    347          	}
    348          }
    349          
    350          /**
    351           * \brief Set compare mode.
    352           *
    353           * \param pAdc Pointer to an Adc instance.
    354           * \param dwMode compare mode
    355           */
    356          void
    357          adc_set_compare_mode(Adc * pAdc, uint32_t dwMode)
    358          {
    359          	pAdc->ADC_EMR &= ~(ADC_EMR_CMPMODE_Msk);
    360          	pAdc->ADC_EMR |= (dwMode & ADC_EMR_CMPMODE_Msk);
    361          }
    362          
    363          /**
    364           * \brief Set comparsion window.
    365           *
    366           * \param pAdc Pointer to an Adc instance.
    367           * \param dwHi_Lo Comparison Window
    368           */
    369          void
    370          adc_set_comparison_window(Adc * pAdc, uint32_t dwHi_Lo)
    371          {
    372          	pAdc->ADC_CWR = dwHi_Lo;
    373          }
    374          
    375          /**
    376           * \brief Check if ADC configuration is right.
    377           *
    378           * \param pAdc Pointer to an Adc instance.
    379           * \param dwMck Board MCK (Hz)
    380           *
    381           * \return 0 if check ok, others if not ok.
    382           */
    383          extern uint8_t
    384          adc_set_configuration(Adc * pAdc, uint32_t dwMck)
    385          {
    386          	uint8_t bOk = 0;
    387          	uint32_t dwMr;
    388          	uint32_t dwPres;
    389          	uint32_t dwClock;
    390          
    391          	dwMr = pAdc->ADC_MR;
    392          
    393          	dwPres = (dwMr & ADC_MR_PRESCAL_Msk) >> ADC_MR_PRESCAL_Pos;
    394          	/* Formula: ADCClock = MCK / ( (PRESCAL+1) * 2 ) */
    395          	dwClock = dwMck / ((dwPres + 1) * 2);
    396          	if (dwClock > ADC_CLOCK_MAX) {
    397          		printf
    398          		    ("ADC clock is too high (out of specification: %d Hz)\r\n",
    399          		     (int) ADC_CLOCK_MAX);
    400          		bOk = 1;
    401          	}
    402          
    403          	return bOk;
    404          }
    405          
    406          /**
    407           * \brief Return the Channel Converted Data
    408           *
    409           * \param pAdc Pointer to an Adc instance.
    410           * \param dwChannel channel to get converted value
    411           */
    412          extern uint32_t
    413          adc_get_converted_data(Adc * pAdc, uint32_t dwChannel)
    414          {
    415          	uint32_t dwData = 0;
    416          
    417          	assert(dwChannel < 16);
    418          
    419          	dwData = pAdc->ADC_CDR[dwChannel];
                 	               ^
Error[Pe136]: struct "<unnamed>" has no field "ADC_CDR"
    420          
    421          	return dwData;
    422          }
    423          
    424          /**
    425           * Sets the ADC startup time.
    426           * \param pAdc  Pointer to an Adc instance.
    427           * \param dwUs  Startup time in uS.
    428           */
    429          void
    430          adc_set_startup_time(Adc * pAdc, uint32_t dwUs)
    431          {
    432          	uint32_t dwStart;
    433          	uint32_t dwMr;
    434          
    435          	if (dwAdcClock == 0)
    436          		return;
    437          	/* Formula for STARTUP is:
    438          	   STARTUP = (time x ADCCLK) / (1000000) - 1
    439          	   Division multiplied by 10 for higher precision */
    440          
    441          	dwStart = (dwUs * dwAdcClock) / (100000);
    442          	if (dwStart % 10)
    443          		dwStart /= 10;
    444          	else {
    445          		dwStart /= 10;
    446          		if (dwStart)
    447          			dwStart--;
    448          	}
    449          	if (dwStart > 896)
    450          		dwMr = ADC_MR_STARTUP_SUT960;
    451          	else if (dwStart > 832)
    452          		dwMr = ADC_MR_STARTUP_SUT896;
    453          	else if (dwStart > 768)
    454          		dwMr = ADC_MR_STARTUP_SUT832;
    455          	else if (dwStart > 704)
    456          		dwMr = ADC_MR_STARTUP_SUT768;
    457          	else if (dwStart > 640)
    458          		dwMr = ADC_MR_STARTUP_SUT704;
    459          	else if (dwStart > 576)
    460          		dwMr = ADC_MR_STARTUP_SUT640;
    461          	else if (dwStart > 512)
    462          		dwMr = ADC_MR_STARTUP_SUT576;
    463          	else if (dwStart > 112)
    464          		dwMr = ADC_MR_STARTUP_SUT512;
    465          	else if (dwStart > 96)
    466          		dwMr = ADC_MR_STARTUP_SUT112;
    467          	else if (dwStart > 80)
    468          		dwMr = ADC_MR_STARTUP_SUT96;
    469          	else if (dwStart > 64)
    470          		dwMr = ADC_MR_STARTUP_SUT80;
    471          	else if (dwStart > 24)
    472          		dwMr = ADC_MR_STARTUP_SUT64;
    473          	else if (dwStart > 16)
    474          		dwMr = ADC_MR_STARTUP_SUT24;
    475          	else if (dwStart > 8)
    476          		dwMr = ADC_MR_STARTUP_SUT16;
    477          	else if (dwStart > 0)
    478          		dwMr = ADC_MR_STARTUP_SUT8;
    479          	else
    480          		dwMr = ADC_MR_STARTUP_SUT0;
    481          
    482          	dwMr |= pAdc->ADC_MR & ~ADC_MR_STARTUP_Msk;
    483          	pAdc->ADC_MR = dwMr;
    484          }
    485          
    486          /**
    487           * Set ADC tracking time
    488           * \param pAdc  Pointer to an Adc instance.
    489           * \param dwNs  Tracking time in nS.
    490           */
    491          void
    492          adc_set_tracking_time(Adc * pAdc, uint32_t dwNs)
    493          {
    494          	uint32_t dwShtim;
    495          	uint32_t dwMr;
    496          
    497          	if (dwAdcClock == 0)
    498          		return;
    499          	/* Formula for SHTIM is:
    500          	   SHTIM = (time x ADCCLK) / (1000000000) - 1
    501          	   Since 1 billion is close to the maximum value for an integer, we first
    502          	   divide ADCCLK by 1000 to avoid an overflow */
    503          	dwShtim = (dwNs * (dwAdcClock / 1000)) / 100000;
    504          	if (dwShtim % 10)
    505          		dwShtim /= 10;
    506          	else {
    507          		dwShtim /= 10;
    508          		if (dwShtim)
    509          			dwShtim--;
    510          	}
    511          	dwMr = ADC_MR_TRACKTIM(dwShtim);
    512          	dwMr |= pAdc->ADC_MR & ~ADC_MR_TRACKTIM_Msk;
    513          	pAdc->ADC_MR = dwMr;
    514          }
    515          
    516          /**
    517           * Sets the trigger period.
    518           * \param pAdc   Pointer to an Adc instance.
    519           * \param dwPeriod Trigger period in nS.
    520           */
    521          void
    522          adc_set_trigger_period(Adc * pAdc, uint32_t dwPeriod)
    523          {
    524          	uint32_t dwTrgper;
    525          	uint32_t dwDiv = 100000000;
    526          	uint32_t dwTrgr;
    527          	if (dwAdcClock == 0)
    528          		return;
    529          	while (dwPeriod >= 10 && dwDiv >= 10) {
    530          		dwPeriod /= 10;
    531          		dwDiv /= 10;
    532          	}
    533          	dwTrgper = (dwPeriod * dwAdcClock) / dwDiv;
    534          	if (dwTrgper % 10)
    535          		dwTrgper /= 10;
    536          	else {
    537          		dwTrgper /= 10;
    538          		if (dwTrgper)
    539          			dwTrgper--;
    540          	}
    541          	dwTrgr = ADC_TRGR_TRGPER(dwTrgper);
    542          	dwTrgr |= pAdc->ADC_TRGR & ~ADC_TRGR_TRGPER_Msk;
    543          	pAdc->ADC_TRGR = dwTrgr;
    544          }
    545          
    546          /**
    547           * Start screen calibration (VDD/GND measurement)
    548           * \param pAdc Pointer to an Adc instance.
    549           */
    550          void
    551          adc_ts_calibration(Adc * pAdc)
    552          {
    553          	pAdc->ADC_CR = ADC_CR_TSCALIB;
    554          }
    555          
    556          /**
    557           * Sets the operation mode of the touch screen ADC. The mode can be:
    558           * - \ref ADC_TSMR_TSMODE_NONE (TSADC off)
    559           * - \ref ADC_TSMR_TSMODE_4_WIRE_NO_PM
    560           * - \ref ADC_TSMR_TSMODE_4_WIRE (CH 0~3 used)
    561           * - \ref ADC_TSMR_TSMODE_5_WIRE (CH 0~4 used)
    562           * \param pADC   Pointer to an Adc instance.
    563           * \param dwMode Desired mode
    564           */
    565          void
    566          adc_set_ts_mode(Adc * pADC, uint32_t dwMode)
    567          {
    568          	pADC->ADC_TSMR = (pADC->ADC_TSMR & ~ADC_TSMR_TSMODE_Msk) | dwMode;
    569          }
    570          
    571          /**
    572           * Configure extended mode register
    573           * \param pAdc Pointer to an Adc instance.
    574           * \param dwMode ADC extended mode.
    575           */
    576          void
    577          adc_configure_ext_mode(Adc * pAdc, uint32_t dwMode)
    578          {
    579          	pAdc->ADC_EMR = dwMode;
    580          }
    581          
    582          /**
    583           * Sets the touchscreen pan debounce time.
    584           * \param pADC   Pointer to an Adc instance.
    585           * \param dwTime Debounce time in nS.
    586           */
    587          void
    588          adc_set_ts_debounce(Adc * pADC, uint32_t dwTime)
    589          {
    590          	uint32_t dwDiv = 1000000000;
    591          	uint32_t dwClk = dwAdcClock;
    592          	uint32_t dwPenbc = 0;
    593          	uint32_t dwTarget, dwCurrent;
    594          	uint32_t dwTsmr;
    595          	if (dwTime == 0 || dwAdcClock == 0)
    596          		return;
    597          	/* Divide time & ADCCLK to avoid overflows */
    598          	while ((dwDiv > 1) && ((dwTime % 10) == 0)) {
    599          		dwTime /= 10;
    600          		dwDiv /= 10;
    601          	}
    602          	while ((dwDiv > 1) && ((dwClk & 10) == 0)) {
    603          		dwClk /= 10;
    604          		dwDiv /= 10;
    605          	}
    606          	/* Compute PENDBC */
    607          	dwTarget = dwTime * dwClk / dwDiv;
    608          	dwCurrent = 1;
    609          	while (dwCurrent < dwTarget) {
    610          		dwPenbc++;
    611          		dwCurrent *= 2;
    612          	}
    613          	dwTsmr = ADC_TSMR_PENDBC(dwPenbc);
    614          	if (dwTsmr == 0)
    615          		return;
    616          	dwTsmr |= pADC->ADC_TSMR & ~ADC_TSMR_PENDBC_Msk;
    617          	pADC->ADC_TSMR = dwTsmr;
    618          }
    619          
    620          /**
    621           * Enable/Disable touch screen pen detection.
    622           * \param pADC   Pointer to an Adc instance.
    623           * \param bEnDis If true, pen detection is enabled;
    624           *               in normal mode otherwise.
    625           */
    626          void
    627          adc_set_ts_pen_detect(Adc * pADC, uint8_t bEnDis)
    628          {
    629          	if (bEnDis)
    630          		pADC->ADC_TSMR |= ADC_TSMR_PENDET;
    631          	else
    632          		pADC->ADC_TSMR &= ~ADC_TSMR_PENDET;
    633          }
    634          
    635          /**
    636           * Sets the average of the touch screen ADC. The mode can be:
    637           * - \ref ADC_TSMR_TSAV_NO_FILTER (No filtering)
    638           * - \ref ADC_TSMR_TSAV_AVG2CONV (Average 2 conversions)
    639           * - \ref ADC_TSMR_TSAV_AVG4CONV (Average 4 conversions)
    640           * - \ref ADC_TSMR_TSAV_AVG8CONV (Average 8 conversions)
    641           * \param pADC   Pointer to an Adc instance.
    642           * \param dwAvg2Conv Average mode for touch screen
    643           */
    644          void
    645          adc_set_ts_average(Adc * pADC, uint32_t dwAvg2Conv)
    646          {
    647          	uint32_t dwMr = pADC->ADC_TSMR & ~ADC_TSMR_TSAV_Msk;
    648          	uint32_t dwTSAV = dwAvg2Conv >> ADC_TSMR_TSAV_Pos;
    649          	uint32_t dwTSFREQ = (dwMr & ADC_TSMR_TSFREQ_Msk) >> ADC_TSMR_TSFREQ_Pos;
    650          	if (dwTSAV) {
    651          		if (dwTSAV > dwTSFREQ) {
    652          			dwMr &= ~ADC_TSMR_TSFREQ_Msk;
    653          			dwMr |= ADC_TSMR_TSFREQ(dwTSAV);
    654          		}
    655          	}
    656          	pADC->ADC_TSMR = dwMr | dwAvg2Conv;
    657          }
    658          
    659          /**
    660           * Return X measurement position value.
    661           * \param pADC   Pointer to an Adc instance.
    662           */
    663          uint32_t
    664          adc_get_ts_xposition(Adc * pADC)
    665          {
    666          	return pADC->ADC_XPOSR;
    667          }
    668          
    669          /**
    670           * Return Y measurement position value.
    671           * \param pADC   Pointer to an Adc instance.
    672           */
    673          uint32_t
    674          adc_get_ts_yposition(Adc * pADC)
    675          {
    676          	return pADC->ADC_YPOSR;
    677          }
    678          
    679          /**
    680           * Return Z measurement position value.
    681           * \param pADC   Pointer to an Adc instance.
    682           */
    683          uint32_t
    684          adc_get_ts_pressure(Adc * pADC)
    685          {
    686          	return pADC->ADC_PRESSR;
    687          }

Errors: 4
Warnings: 1
