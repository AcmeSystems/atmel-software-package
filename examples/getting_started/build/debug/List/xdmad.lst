###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:08
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\xdmad.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\xdmad.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\xdmad.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\xdmad.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\bus\xdmad.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup xdmad_module
     31           *
     32           * \section Xdma xDma Configuration Usage
     33           *
     34           * To configure a XDMA channel, the user has to follow these few steps :
     35           * <ul>
     36           * <li> Initialize a XDMA driver instance by XDMAD_Initialize().</li>
     37           * <li> choose an available (disabled) channel using XDMAD_AllocateChannel().</li>
     38           * <li> After the XDMAC selected channel has been programmed, XDMAD_PrepareChannel() is to enable
     39           * clock and dma peripheral of the DMA, and set Configuration register to set up the transfer type
     40           * (memory or non-memory peripheral for source and destination) and flow control device.</li>
     41           * <li> Invoke XDMAD_StartTransfer() to start DMA transfer  or XDMAD_StopTransfer() to force stop DMA transfer.</li>
     42            * <li> Once the buffer of data is transferred, XDMAD_IsTransferDone() checks if DMA transfer is finished.</li>
     43           * <li> XDMAD_Handler() handles XDMA interrupt, and invoking XDMAD_SetCallback() if provided.</li>
     44           * </ul>
     45           *
     46           * Related files:\n
     47           * \ref xdmad.h\n
     48           * \ref xdmad.c\n
     49           */
     50          
     51          /** \file */
     52          
     53          /** \addtogroup dmad_functions
     54            @{*/
     55          
     56          /*----------------------------------------------------------------------------
     57           *        Includes
     58           *----------------------------------------------------------------------------*/
     59          
     60          //#include "board.h"
     61          #include <stdio.h>
     62          #include "core/pmc.h"
     63          
     64          #include "bus/xdmad.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     65          #include "bus/xdmac.h"
     66          #include "bus/xdma_hardware_interface.h"
     67          
     68          #include <assert.h>
     69          
     70          /*----------------------------------------------------------------------------
     71           *        Local functions
     72           *----------------------------------------------------------------------------*/
     73          /**
     74           * \brief Try to allocate a DMA channel for on given controller.
     75           * \param pXdmad  Pointer to DMA driver instance.
     76           * \param bXdmac xDMA controller ID (0 ~ 1).
     77           * \param bSrcID Source peripheral ID, 0xFF for memory.
     78           * \param bDstID Destination peripheral ID, 0xFF for memory.
     79           * \return Channel number if allocation successful, return
     80           * DMAD_ALLOC_FAILED if allocation failed.
     81           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     82          static uint32_t XDMAD_AllocateXdmacChannel(sXdmad * pXdmad,
     83          			   uint8_t bXdmac, uint8_t bSrcID, uint8_t bDstID)
     84          {
   \                     XDMAD_AllocateXdmacChannel:
   \   00000000   0xE92D43F8         PUSH     {R3-R9,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B08002         MOVS     R8,R2
   \   00000010   0xE1B06003         MOVS     R6,R3
     85          	uint32_t i;
     86          	/* Can't support peripheral to peripheral */
     87          	if (((bSrcID != XDMAD_TRANSFER_MEMORY)
     88          	     && (bDstID != XDMAD_TRANSFER_MEMORY))) {
   \   00000014   0xE1B00008         MOVS     R0,R8
   \   00000018   0xE6EF0070         UXTB     R0,R0
   \   0000001C   0xE35000FF         CMP      R0,#+255
   \   00000020   0x0A000006         BEQ      ??XDMAD_AllocateXdmacChannel_0
   \   00000024   0xE1B00006         MOVS     R0,R6
   \   00000028   0xE6EF0070         UXTB     R0,R0
   \   0000002C   0xE35000FF         CMP      R0,#+255
   \   00000030   0x0A000002         BEQ      ??XDMAD_AllocateXdmacChannel_0
     89          		return XDMAD_ALLOC_FAILED;
   \   00000034   0xE3A000FF         MOV      R0,#+255
   \   00000038   0xE3800CFF         ORR      R0,R0,#0xFF00
   \   0000003C   0xEA00007B         B        ??XDMAD_AllocateXdmacChannel_1
     90          	}
     91          	/* dma transfer from peripheral to memory */
     92          	if (bDstID == XDMAD_TRANSFER_MEMORY) {
   \                     ??XDMAD_AllocateXdmacChannel_0:
   \   00000040   0xE1B00006         MOVS     R0,R6
   \   00000044   0xE6EF0070         UXTB     R0,R0
   \   00000048   0xE35000FF         CMP      R0,#+255
   \   0000004C   0x1A000009         BNE      ??XDMAD_AllocateXdmacChannel_2
     93          		if ((!XDMAIF_IsValidatedPeripherOnDma(bXdmac, bSrcID))) {
   \   00000050   0xE1B01008         MOVS     R1,R8
   \   00000054   0xE6EF1071         UXTB     R1,R1
   \   00000058   0xE1B00005         MOVS     R0,R5
   \   0000005C   0xE6EF0070         UXTB     R0,R0
   \   00000060   0x........         BL       XDMAIF_IsValidatedPeripherOnDma
   \   00000064   0xE3500000         CMP      R0,#+0
   \   00000068   0x1A000002         BNE      ??XDMAD_AllocateXdmacChannel_2
     94          			return XDMAD_ALLOC_FAILED;
   \   0000006C   0xE3A000FF         MOV      R0,#+255
   \   00000070   0xE3800CFF         ORR      R0,R0,#0xFF00
   \   00000074   0xEA00006D         B        ??XDMAD_AllocateXdmacChannel_1
     95          		}
     96          	}
     97          	/* dma transfer from memory to peripheral */
     98          	if (bSrcID == XDMAD_TRANSFER_MEMORY) {
   \                     ??XDMAD_AllocateXdmacChannel_2:
   \   00000078   0xE1B00008         MOVS     R0,R8
   \   0000007C   0xE6EF0070         UXTB     R0,R0
   \   00000080   0xE35000FF         CMP      R0,#+255
   \   00000084   0x1A000009         BNE      ??XDMAD_AllocateXdmacChannel_3
     99          		if ((!XDMAIF_IsValidatedPeripherOnDma(bXdmac, bDstID))) {
   \   00000088   0xE1B01006         MOVS     R1,R6
   \   0000008C   0xE6EF1071         UXTB     R1,R1
   \   00000090   0xE1B00005         MOVS     R0,R5
   \   00000094   0xE6EF0070         UXTB     R0,R0
   \   00000098   0x........         BL       XDMAIF_IsValidatedPeripherOnDma
   \   0000009C   0xE3500000         CMP      R0,#+0
   \   000000A0   0x1A000002         BNE      ??XDMAD_AllocateXdmacChannel_3
    100          			return XDMAD_ALLOC_FAILED;
   \   000000A4   0xE3A000FF         MOV      R0,#+255
   \   000000A8   0xE3800CFF         ORR      R0,R0,#0xFF00
   \   000000AC   0xEA00005F         B        ??XDMAD_AllocateXdmacChannel_1
    101          		}
    102          	}
    103          
    104          	for (i = 0; i < pXdmad->numChannels; i++) {
   \                     ??XDMAD_AllocateXdmacChannel_3:
   \   000000B0   0xE3A00000         MOV      R0,#+0
   \   000000B4   0xE1B07000         MOVS     R7,R0
   \                     ??XDMAD_AllocateXdmacChannel_4:
   \   000000B8   0xE5D40209         LDRB     R0,[R4, #+521]
   \   000000BC   0xE1570000         CMP      R7,R0
   \   000000C0   0x2A000058         BCS      ??XDMAD_AllocateXdmacChannel_5
    105          		if (pXdmad->XdmaChannels[bXdmac][i].state == XDMAD_STATE_FREE) {
   \   000000C4   0xE1B00005         MOVS     R0,R5
   \   000000C8   0xE6EF0070         UXTB     R0,R0
   \   000000CC   0xE1B00400         LSLS     R0,R0,#+8
   \   000000D0   0xE0900004         ADDS     R0,R0,R4
   \   000000D4   0xE1B01207         LSLS     R1,R7,#+4
   \   000000D8   0xE0910000         ADDS     R0,R1,R0
   \   000000DC   0xE5D00017         LDRB     R0,[R0, #+23]
   \   000000E0   0xE3500000         CMP      R0,#+0
   \   000000E4   0x1A00004D         BNE      ??XDMAD_AllocateXdmacChannel_6
    106          			/* Allocate the channel */
    107          			pXdmad->XdmaChannels[bXdmac][i].state =
    108          			    XDMAD_STATE_ALLOCATED;
   \   000000E8   0xE1B00005         MOVS     R0,R5
   \   000000EC   0xE6EF0070         UXTB     R0,R0
   \   000000F0   0xE1B00400         LSLS     R0,R0,#+8
   \   000000F4   0xE0900004         ADDS     R0,R0,R4
   \   000000F8   0xE1B01207         LSLS     R1,R7,#+4
   \   000000FC   0xE0910000         ADDS     R0,R1,R0
   \   00000100   0xE3A01001         MOV      R1,#+1
   \   00000104   0xE5C01017         STRB     R1,[R0, #+23]
    109          			/* Get general informations */
    110          			pXdmad->XdmaChannels[bXdmac][i].bSrcPeriphID = bSrcID;
   \   00000108   0xE1B00005         MOVS     R0,R5
   \   0000010C   0xE6EF0070         UXTB     R0,R0
   \   00000110   0xE1B00400         LSLS     R0,R0,#+8
   \   00000114   0xE0900004         ADDS     R0,R0,R4
   \   00000118   0xE1B01207         LSLS     R1,R7,#+4
   \   0000011C   0xE0910000         ADDS     R0,R1,R0
   \   00000120   0xE5C08011         STRB     R8,[R0, #+17]
    111          			pXdmad->XdmaChannels[bXdmac][i].bDstPeriphID = bDstID;
   \   00000124   0xE1B00005         MOVS     R0,R5
   \   00000128   0xE6EF0070         UXTB     R0,R0
   \   0000012C   0xE1B00400         LSLS     R0,R0,#+8
   \   00000130   0xE0900004         ADDS     R0,R0,R4
   \   00000134   0xE1B01207         LSLS     R1,R7,#+4
   \   00000138   0xE0910000         ADDS     R0,R1,R0
   \   0000013C   0xE5C06012         STRB     R6,[R0, #+18]
    112          			pXdmad->XdmaChannels[bXdmac][i].bSrcTxIfID =
    113          			    XDMAIF_Get_ChannelNumber(bXdmac, bSrcID, 0);
   \   00000140   0xE1B00005         MOVS     R0,R5
   \   00000144   0xE6EF0070         UXTB     R0,R0
   \   00000148   0xE1B00400         LSLS     R0,R0,#+8
   \   0000014C   0xE0900004         ADDS     R0,R0,R4
   \   00000150   0xE1B01207         LSLS     R1,R7,#+4
   \   00000154   0xE0919000         ADDS     R9,R1,R0
   \   00000158   0xE3A02000         MOV      R2,#+0
   \   0000015C   0xE1B01008         MOVS     R1,R8
   \   00000160   0xE6EF1071         UXTB     R1,R1
   \   00000164   0xE1B00005         MOVS     R0,R5
   \   00000168   0xE6EF0070         UXTB     R0,R0
   \   0000016C   0x........         BL       XDMAIF_Get_ChannelNumber
   \   00000170   0xE5C90013         STRB     R0,[R9, #+19]
    114          			pXdmad->XdmaChannels[bXdmac][i].bSrcRxIfID =
    115          			    XDMAIF_Get_ChannelNumber(bXdmac, bSrcID, 1);
   \   00000174   0xE1B00005         MOVS     R0,R5
   \   00000178   0xE6EF0070         UXTB     R0,R0
   \   0000017C   0xE1B00400         LSLS     R0,R0,#+8
   \   00000180   0xE0900004         ADDS     R0,R0,R4
   \   00000184   0xE1B01207         LSLS     R1,R7,#+4
   \   00000188   0xE0919000         ADDS     R9,R1,R0
   \   0000018C   0xE3A02001         MOV      R2,#+1
   \   00000190   0xE1B01008         MOVS     R1,R8
   \   00000194   0xE6EF1071         UXTB     R1,R1
   \   00000198   0xE1B00005         MOVS     R0,R5
   \   0000019C   0xE6EF0070         UXTB     R0,R0
   \   000001A0   0x........         BL       XDMAIF_Get_ChannelNumber
   \   000001A4   0xE5C90014         STRB     R0,[R9, #+20]
    116          			pXdmad->XdmaChannels[bXdmac][i].bDstTxIfID =
    117          			    XDMAIF_Get_ChannelNumber(bXdmac, bDstID, 0);
   \   000001A8   0xE1B00005         MOVS     R0,R5
   \   000001AC   0xE6EF0070         UXTB     R0,R0
   \   000001B0   0xE1B00400         LSLS     R0,R0,#+8
   \   000001B4   0xE0900004         ADDS     R0,R0,R4
   \   000001B8   0xE1B01207         LSLS     R1,R7,#+4
   \   000001BC   0xE0919000         ADDS     R9,R1,R0
   \   000001C0   0xE3A02000         MOV      R2,#+0
   \   000001C4   0xE1B01006         MOVS     R1,R6
   \   000001C8   0xE6EF1071         UXTB     R1,R1
   \   000001CC   0xE1B00005         MOVS     R0,R5
   \   000001D0   0xE6EF0070         UXTB     R0,R0
   \   000001D4   0x........         BL       XDMAIF_Get_ChannelNumber
   \   000001D8   0xE5C90015         STRB     R0,[R9, #+21]
    118          			pXdmad->XdmaChannels[bXdmac][i].bDstTxIfID =
    119          			    XDMAIF_Get_ChannelNumber(bXdmac, bDstID, 1);
   \   000001DC   0xE1B00005         MOVS     R0,R5
   \   000001E0   0xE6EF0070         UXTB     R0,R0
   \   000001E4   0xE1B00400         LSLS     R0,R0,#+8
   \   000001E8   0xE0900004         ADDS     R0,R0,R4
   \   000001EC   0xE1B01207         LSLS     R1,R7,#+4
   \   000001F0   0xE0919000         ADDS     R9,R1,R0
   \   000001F4   0xE3A02001         MOV      R2,#+1
   \   000001F8   0xE1B01006         MOVS     R1,R6
   \   000001FC   0xE6EF1071         UXTB     R1,R1
   \   00000200   0xE1B00005         MOVS     R0,R5
   \   00000204   0xE6EF0070         UXTB     R0,R0
   \   00000208   0x........         BL       XDMAIF_Get_ChannelNumber
   \   0000020C   0xE5C90015         STRB     R0,[R9, #+21]
    120          			return ((bXdmac << 8)) | ((i) & 0xFF);
   \   00000210   0xE6EF5075         UXTB     R5,R5
   \   00000214   0xE21700FF         ANDS     R0,R7,#0xFF
   \   00000218   0xE1900405         ORRS     R0,R0,R5, LSL #+8
   \   0000021C   0xEA000003         B        ??XDMAD_AllocateXdmacChannel_1
    121          		}
    122          	}
   \                     ??XDMAD_AllocateXdmacChannel_6:
   \   00000220   0xE2977001         ADDS     R7,R7,#+1
   \   00000224   0xEAFFFFA3         B        ??XDMAD_AllocateXdmacChannel_4
    123          	return XDMAD_ALLOC_FAILED;
   \                     ??XDMAD_AllocateXdmacChannel_5:
   \   00000228   0xE3A000FF         MOV      R0,#+255
   \   0000022C   0xE3800CFF         ORR      R0,R0,#0xFF00
   \                     ??XDMAD_AllocateXdmacChannel_1:
   \   00000230   0xE8BD83F2         POP      {R1,R4-R9,PC}    ;; return
    124          }
    125          
    126          /*----------------------------------------------------------------------------
    127           *        Exported functions
    128           *----------------------------------------------------------------------------*/
    129          
    130          /**
    131           * \brief Initialize xDMA driver instance.
    132           * \param pXdmad Pointer to xDMA driver instance.
    133           * \param bPollingMode Polling DMA transfer:
    134           *                     1. Via XDMAD_IsTransferDone(); or
    135           *                     2. Via XDMAD_Handler().
    136           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    137          void XDMAD_Initialize(sXdmad * pXdmad, uint8_t bPollingMode)
    138          {
   \                     XDMAD_Initialize:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    139          	uint32_t i, j;
    140          
    141          	assert(pXdmad != NULL);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAD_Initialize_0
   \   00000014   0xE3A0208D         MOV      R2,#+141
   \   00000018   0x........         LDR      R1,??DataTable6
   \   0000001C   0x........         LDR      R0,??DataTable6_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    142          
    143          	pXdmad->pXdmacs[0] = XDMAC0;
   \                     ??XDMAD_Initialize_0:
   \   00000028   0xE3A004F0         MOV      R0,#-268435456
   \   0000002C   0xE3800B40         ORR      R0,R0,#0x10000
   \   00000030   0xE5840000         STR      R0,[R4, #+0]
    144          	pXdmad->pXdmacs[1] = XDMAC1;
   \   00000034   0xE3A004F0         MOV      R0,#-268435456
   \   00000038   0xE3800C40         ORR      R0,R0,#0x4000
   \   0000003C   0xE5840004         STR      R0,[R4, #+4]
    145          	pXdmad->pollingMode = bPollingMode;
   \   00000040   0xE5C4520A         STRB     R5,[R4, #+522]
    146          	pXdmad->numControllers = XDMAC_CONTROLLER_NUM;
   \   00000044   0xE3A00002         MOV      R0,#+2
   \   00000048   0xE5C40208         STRB     R0,[R4, #+520]
    147          	pXdmad->numChannels = XDMAC_CHANNEL_NUM;
   \   0000004C   0xE3A00010         MOV      R0,#+16
   \   00000050   0xE5C40209         STRB     R0,[R4, #+521]
    148          
    149          	for (i = 0; i < pXdmad->numControllers; i++) {
   \   00000054   0xE3A00000         MOV      R0,#+0
   \   00000058   0xE1B06000         MOVS     R6,R0
   \                     ??XDMAD_Initialize_1:
   \   0000005C   0xE5D40208         LDRB     R0,[R4, #+520]
   \   00000060   0xE1560000         CMP      R6,R0
   \   00000064   0x2A000044         BCS      ??XDMAD_Initialize_2
    150          		for (j = 0; j < pXdmad->numChannels; j++) {
   \   00000068   0xE3A00000         MOV      R0,#+0
   \   0000006C   0xE1B07000         MOVS     R7,R0
   \                     ??XDMAD_Initialize_3:
   \   00000070   0xE5D40209         LDRB     R0,[R4, #+521]
   \   00000074   0xE1570000         CMP      R7,R0
   \   00000078   0x2A00003D         BCS      ??XDMAD_Initialize_4
    151          			pXdmad->XdmaChannels[i][j].fCallback = 0;
   \   0000007C   0xE1B00406         LSLS     R0,R6,#+8
   \   00000080   0xE0900004         ADDS     R0,R0,R4
   \   00000084   0xE1B01207         LSLS     R1,R7,#+4
   \   00000088   0xE0910000         ADDS     R0,R1,R0
   \   0000008C   0xE3A01000         MOV      R1,#+0
   \   00000090   0xE5801008         STR      R1,[R0, #+8]
    152          			pXdmad->XdmaChannels[i][j].pArg = 0;
   \   00000094   0xE1B00406         LSLS     R0,R6,#+8
   \   00000098   0xE0900004         ADDS     R0,R0,R4
   \   0000009C   0xE1B01207         LSLS     R1,R7,#+4
   \   000000A0   0xE0910000         ADDS     R0,R1,R0
   \   000000A4   0xE3A01000         MOV      R1,#+0
   \   000000A8   0xE580100C         STR      R1,[R0, #+12]
    153          			pXdmad->XdmaChannels[i][j].bIrqOwner = 0;
   \   000000AC   0xE1B00406         LSLS     R0,R6,#+8
   \   000000B0   0xE0900004         ADDS     R0,R0,R4
   \   000000B4   0xE1B01207         LSLS     R1,R7,#+4
   \   000000B8   0xE0910000         ADDS     R0,R1,R0
   \   000000BC   0xE3A01000         MOV      R1,#+0
   \   000000C0   0xE5C01010         STRB     R1,[R0, #+16]
    154          			pXdmad->XdmaChannels[i][j].bSrcPeriphID = 0;
   \   000000C4   0xE1B00406         LSLS     R0,R6,#+8
   \   000000C8   0xE0900004         ADDS     R0,R0,R4
   \   000000CC   0xE1B01207         LSLS     R1,R7,#+4
   \   000000D0   0xE0910000         ADDS     R0,R1,R0
   \   000000D4   0xE3A01000         MOV      R1,#+0
   \   000000D8   0xE5C01011         STRB     R1,[R0, #+17]
    155          			pXdmad->XdmaChannels[i][j].bDstPeriphID = 0;
   \   000000DC   0xE1B00406         LSLS     R0,R6,#+8
   \   000000E0   0xE0900004         ADDS     R0,R0,R4
   \   000000E4   0xE1B01207         LSLS     R1,R7,#+4
   \   000000E8   0xE0910000         ADDS     R0,R1,R0
   \   000000EC   0xE3A01000         MOV      R1,#+0
   \   000000F0   0xE5C01012         STRB     R1,[R0, #+18]
    156          			pXdmad->XdmaChannels[i][j].bSrcTxIfID = 0;
   \   000000F4   0xE1B00406         LSLS     R0,R6,#+8
   \   000000F8   0xE0900004         ADDS     R0,R0,R4
   \   000000FC   0xE1B01207         LSLS     R1,R7,#+4
   \   00000100   0xE0910000         ADDS     R0,R1,R0
   \   00000104   0xE3A01000         MOV      R1,#+0
   \   00000108   0xE5C01013         STRB     R1,[R0, #+19]
    157          			pXdmad->XdmaChannels[i][j].bSrcRxIfID = 0;
   \   0000010C   0xE1B00406         LSLS     R0,R6,#+8
   \   00000110   0xE0900004         ADDS     R0,R0,R4
   \   00000114   0xE1B01207         LSLS     R1,R7,#+4
   \   00000118   0xE0910000         ADDS     R0,R1,R0
   \   0000011C   0xE3A01000         MOV      R1,#+0
   \   00000120   0xE5C01014         STRB     R1,[R0, #+20]
    158          			pXdmad->XdmaChannels[i][j].bDstTxIfID = 0;
   \   00000124   0xE1B00406         LSLS     R0,R6,#+8
   \   00000128   0xE0900004         ADDS     R0,R0,R4
   \   0000012C   0xE1B01207         LSLS     R1,R7,#+4
   \   00000130   0xE0910000         ADDS     R0,R1,R0
   \   00000134   0xE3A01000         MOV      R1,#+0
   \   00000138   0xE5C01015         STRB     R1,[R0, #+21]
    159          			pXdmad->XdmaChannels[i][j].bDstRxIfID = 0;
   \   0000013C   0xE1B00406         LSLS     R0,R6,#+8
   \   00000140   0xE0900004         ADDS     R0,R0,R4
   \   00000144   0xE1B01207         LSLS     R1,R7,#+4
   \   00000148   0xE0910000         ADDS     R0,R1,R0
   \   0000014C   0xE3A01000         MOV      R1,#+0
   \   00000150   0xE5C01016         STRB     R1,[R0, #+22]
    160          			pXdmad->XdmaChannels[i][j].state = XDMAD_STATE_FREE;
   \   00000154   0xE1B00406         LSLS     R0,R6,#+8
   \   00000158   0xE0900004         ADDS     R0,R0,R4
   \   0000015C   0xE1B01207         LSLS     R1,R7,#+4
   \   00000160   0xE0910000         ADDS     R0,R1,R0
   \   00000164   0xE3A01000         MOV      R1,#+0
   \   00000168   0xE5C01017         STRB     R1,[R0, #+23]
    161          		}
   \   0000016C   0xE2977001         ADDS     R7,R7,#+1
   \   00000170   0xEAFFFFBE         B        ??XDMAD_Initialize_3
    162          	}
   \                     ??XDMAD_Initialize_4:
   \   00000174   0xE2966001         ADDS     R6,R6,#+1
   \   00000178   0xEAFFFFB7         B        ??XDMAD_Initialize_1
    163          }
   \                     ??XDMAD_Initialize_2:
   \   0000017C   0xE8BD80F1         POP      {R0,R4-R7,PC}    ;; return
    164          
    165          /**
    166           * \brief Allocate a XDMA channel for upper layer.
    167           * \param pXdmad  Pointer to xDMA driver instance.
    168           * \param bSrcID Source peripheral ID, 0xFF for memory.
    169           * \param bDstID Destination peripheral ID, 0xFF for memory.
    170           * \return Channel number if allocation successful, return
    171           * XDMAD_ALLOC_FAILED if allocation failed.
    172           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    173          uint32_t XDMAD_AllocateChannel(sXdmad * pXdmad, uint8_t bSrcID, uint8_t bDstID)
    174          {
   \                     XDMAD_AllocateChannel:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    175          	uint32_t _iController;
    176          	uint32_t dwChannel = XDMAD_ALLOC_FAILED;
   \   00000010   0xE3A080FF         MOV      R8,#+255
   \   00000014   0xE3888CFF         ORR      R8,R8,#0xFF00
    177          	for (_iController = 0; _iController < pXdmad->numControllers;
   \   00000018   0xE3A00000         MOV      R0,#+0
   \   0000001C   0xE1B07000         MOVS     R7,R0
   \                     ??XDMAD_AllocateChannel_0:
   \   00000020   0xE5D40208         LDRB     R0,[R4, #+520]
   \   00000024   0xE1570000         CMP      R7,R0
   \   00000028   0x2A00000E         BCS      ??XDMAD_AllocateChannel_1
    178          	     _iController++) {
    179          		dwChannel =
    180          		    XDMAD_AllocateXdmacChannel(pXdmad, _iController, bSrcID,
    181          					       bDstID);
   \   0000002C   0xE1B03006         MOVS     R3,R6
   \   00000030   0xE6EF3073         UXTB     R3,R3
   \   00000034   0xE1B02005         MOVS     R2,R5
   \   00000038   0xE6EF2072         UXTB     R2,R2
   \   0000003C   0xE1B01007         MOVS     R1,R7
   \   00000040   0xE6EF1071         UXTB     R1,R1
   \   00000044   0xE1B00004         MOVS     R0,R4
   \   00000048   0x........         BL       XDMAD_AllocateXdmacChannel
   \   0000004C   0xE1B08000         MOVS     R8,R0
    182          		if (dwChannel != XDMAD_ALLOC_FAILED)
   \   00000050   0xE3A000FF         MOV      R0,#+255
   \   00000054   0xE3800CFF         ORR      R0,R0,#0xFF00
   \   00000058   0xE1580000         CMP      R8,R0
   \   0000005C   0x1A000001         BNE      ??XDMAD_AllocateChannel_1
    183          			break;
    184          	}
   \                     ??XDMAD_AllocateChannel_2:
   \   00000060   0xE2977001         ADDS     R7,R7,#+1
   \   00000064   0xEAFFFFED         B        ??XDMAD_AllocateChannel_0
    185          	return dwChannel;
   \                     ??XDMAD_AllocateChannel_1:
   \   00000068   0xE1B00008         MOVS     R0,R8
   \   0000006C   0xE8BD81F0         POP      {R4-R8,PC}       ;; return
    186          }
    187          
    188          /**
    189           * \brief Free the specified xDMA channel.
    190           * \param pXdmad     Pointer to xDMA driver instance.
    191           * \param dwChannel ControllerNumber << 8 | ChannelNumber.
    192           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    193          eXdmadRC XDMAD_FreeChannel(sXdmad * pXdmad, uint32_t dwChannel)
    194          {
   \                     XDMAD_FreeChannel:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    195          	uint8_t _iController = (dwChannel >> 8);
   \   0000000C   0xE1B06425         LSRS     R6,R5,#+8
    196          	uint8_t iChannel = (dwChannel) & 0xFF;
   \   00000010   0xE1B07005         MOVS     R7,R5
    197          
    198          	assert(pXdmad != NULL);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000004         BNE      ??XDMAD_FreeChannel_0
   \   0000001C   0xE3A020C6         MOV      R2,#+198
   \   00000020   0x........         LDR      R1,??DataTable6
   \   00000024   0x........         LDR      R0,??DataTable6_1
   \   00000028   0x........         BL       __aeabi_assert
   \   0000002C   0x........         BL       __iar_EmptyStepPoint
    199          	switch (pXdmad->XdmaChannels[_iController][iChannel].state) {
   \                     ??XDMAD_FreeChannel_0:
   \   00000030   0xE1B00006         MOVS     R0,R6
   \   00000034   0xE6EF0070         UXTB     R0,R0
   \   00000038   0xE1B00400         LSLS     R0,R0,#+8
   \   0000003C   0xE0900004         ADDS     R0,R0,R4
   \   00000040   0xE1B01007         MOVS     R1,R7
   \   00000044   0xE6EF1071         UXTB     R1,R1
   \   00000048   0xE1B01201         LSLS     R1,R1,#+4
   \   0000004C   0xE0910000         ADDS     R0,R1,R0
   \   00000050   0xE5D00017         LDRB     R0,[R0, #+23]
   \   00000054   0xE3500001         CMP      R0,#+1
   \   00000058   0x0A000006         BEQ      ??XDMAD_FreeChannel_1
   \   0000005C   0xE3500002         CMP      R0,#+2
   \   00000060   0x0A000002         BEQ      ??XDMAD_FreeChannel_2
   \   00000064   0xE3500004         CMP      R0,#+4
   \   00000068   0x0A000002         BEQ      ??XDMAD_FreeChannel_1
   \   0000006C   0xEA00000B         B        ??XDMAD_FreeChannel_3
    200          	case XDMAD_STATE_START:
    201          		return XDMAD_BUSY;
   \                     ??XDMAD_FreeChannel_2:
   \   00000070   0xE3A00003         MOV      R0,#+3
   \   00000074   0xEA00000A         B        ??XDMAD_FreeChannel_4
    202          	case XDMAD_STATE_ALLOCATED:
    203          	case XDMAD_STATE_DONE:
    204          		pXdmad->XdmaChannels[_iController][iChannel].state =
    205          		    XDMAD_STATE_FREE;
   \                     ??XDMAD_FreeChannel_1:
   \   00000078   0xE1B00006         MOVS     R0,R6
   \   0000007C   0xE6EF0070         UXTB     R0,R0
   \   00000080   0xE1B00400         LSLS     R0,R0,#+8
   \   00000084   0xE0900004         ADDS     R0,R0,R4
   \   00000088   0xE1B01007         MOVS     R1,R7
   \   0000008C   0xE6EF1071         UXTB     R1,R1
   \   00000090   0xE1B01201         LSLS     R1,R1,#+4
   \   00000094   0xE0910000         ADDS     R0,R1,R0
   \   00000098   0xE3A01000         MOV      R1,#+0
   \   0000009C   0xE5C01017         STRB     R1,[R0, #+23]
    206          		break;
    207          	}
    208          	return XDMAD_OK;
   \                     ??XDMAD_FreeChannel_3:
   \   000000A0   0xE3A00000         MOV      R0,#+0
   \                     ??XDMAD_FreeChannel_4:
   \   000000A4   0xE8BD80F2         POP      {R1,R4-R7,PC}    ;; return
    209          }
    210          
    211          /**
    212           * \brief Set the callback function for xDMA channel transfer.
    213           * \param pXdmad     Pointer to xDMA driver instance.
    214           * \param dwChannel ControllerNumber << 8 | ChannelNumber.
    215           * \param fCallback Pointer to callback function.
    216           * \param pArg Pointer to optional argument for callback.
    217           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    218          eXdmadRC XDMAD_SetCallback(sXdmad * pXdmad, uint32_t dwChannel,
    219          		  XdmadTransferCallback fCallback, void *pArg)
    220          {
   \                     XDMAD_SetCallback:
   \   00000000   0xE92D43F8         PUSH     {R3-R9,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    221          	uint8_t _iController = (dwChannel >> 8);
   \   00000014   0xE1B08425         LSRS     R8,R5,#+8
    222          	uint8_t iChannel = (dwChannel) & 0xFF;
   \   00000018   0xE1B09005         MOVS     R9,R5
    223          	assert(pXdmad != NULL);
   \   0000001C   0xE3540000         CMP      R4,#+0
   \   00000020   0x1A000004         BNE      ??XDMAD_SetCallback_0
   \   00000024   0xE3A020DF         MOV      R2,#+223
   \   00000028   0x........         LDR      R1,??DataTable6
   \   0000002C   0x........         LDR      R0,??DataTable6_1
   \   00000030   0x........         BL       __aeabi_assert
   \   00000034   0x........         BL       __iar_EmptyStepPoint
    224          	if (pXdmad->XdmaChannels[_iController][iChannel].state ==
    225          	    XDMAD_STATE_FREE)
   \                     ??XDMAD_SetCallback_0:
   \   00000038   0xE1B00008         MOVS     R0,R8
   \   0000003C   0xE6EF0070         UXTB     R0,R0
   \   00000040   0xE1B00400         LSLS     R0,R0,#+8
   \   00000044   0xE0900004         ADDS     R0,R0,R4
   \   00000048   0xE1B01009         MOVS     R1,R9
   \   0000004C   0xE6EF1071         UXTB     R1,R1
   \   00000050   0xE1B01201         LSLS     R1,R1,#+4
   \   00000054   0xE0910000         ADDS     R0,R1,R0
   \   00000058   0xE5D00017         LDRB     R0,[R0, #+23]
   \   0000005C   0xE3500000         CMP      R0,#+0
   \   00000060   0x1A000001         BNE      ??XDMAD_SetCallback_1
    226          		return XDMAD_ERROR;
   \   00000064   0xE3A00004         MOV      R0,#+4
   \   00000068   0xEA00001F         B        ??XDMAD_SetCallback_2
    227          	else if (pXdmad->XdmaChannels[_iController][iChannel].state ==
    228          		 XDMAD_STATE_START)
   \                     ??XDMAD_SetCallback_1:
   \   0000006C   0xE1B00008         MOVS     R0,R8
   \   00000070   0xE6EF0070         UXTB     R0,R0
   \   00000074   0xE1B00400         LSLS     R0,R0,#+8
   \   00000078   0xE0900004         ADDS     R0,R0,R4
   \   0000007C   0xE1B01009         MOVS     R1,R9
   \   00000080   0xE6EF1071         UXTB     R1,R1
   \   00000084   0xE1B01201         LSLS     R1,R1,#+4
   \   00000088   0xE0910000         ADDS     R0,R1,R0
   \   0000008C   0xE5D00017         LDRB     R0,[R0, #+23]
   \   00000090   0xE3500002         CMP      R0,#+2
   \   00000094   0x1A000001         BNE      ??XDMAD_SetCallback_3
    229          		return XDMAD_BUSY;
   \   00000098   0xE3A00003         MOV      R0,#+3
   \   0000009C   0xEA000012         B        ??XDMAD_SetCallback_2
    230          
    231          	pXdmad->XdmaChannels[_iController][iChannel].fCallback = fCallback;
   \                     ??XDMAD_SetCallback_3:
   \   000000A0   0xE1B00008         MOVS     R0,R8
   \   000000A4   0xE6EF0070         UXTB     R0,R0
   \   000000A8   0xE1B00400         LSLS     R0,R0,#+8
   \   000000AC   0xE0900004         ADDS     R0,R0,R4
   \   000000B0   0xE1B01009         MOVS     R1,R9
   \   000000B4   0xE6EF1071         UXTB     R1,R1
   \   000000B8   0xE1B01201         LSLS     R1,R1,#+4
   \   000000BC   0xE0910000         ADDS     R0,R1,R0
   \   000000C0   0xE5806008         STR      R6,[R0, #+8]
    232          	pXdmad->XdmaChannels[_iController][iChannel].pArg = pArg;
   \   000000C4   0xE1B00008         MOVS     R0,R8
   \   000000C8   0xE6EF0070         UXTB     R0,R0
   \   000000CC   0xE1B00400         LSLS     R0,R0,#+8
   \   000000D0   0xE0900004         ADDS     R0,R0,R4
   \   000000D4   0xE1B01009         MOVS     R1,R9
   \   000000D8   0xE6EF1071         UXTB     R1,R1
   \   000000DC   0xE1B01201         LSLS     R1,R1,#+4
   \   000000E0   0xE0910000         ADDS     R0,R1,R0
   \   000000E4   0xE580700C         STR      R7,[R0, #+12]
    233          
    234          	return XDMAD_OK;
   \   000000E8   0xE3A00000         MOV      R0,#+0
   \                     ??XDMAD_SetCallback_2:
   \   000000EC   0xE8BD83F2         POP      {R1,R4-R9,PC}    ;; return
    235          }
    236          
    237          /**
    238           * \brief Enable clock of the xDMA peripheral, Enable the dma peripheral,
    239           * configure configuration register for xDMA transfer.
    240           * \param pXdmad     Pointer to xDMA driver instance.
    241           * \param dwChannel ControllerNumber << 8 | ChannelNumber.
    242           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    243          eXdmadRC XDMAD_PrepareChannel(sXdmad * pXdmad, uint32_t dwChannel)
    244          {
   \                     XDMAD_PrepareChannel:
   \   00000000   0xE92D43F8         PUSH     {R3-R9,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    245          	uint8_t _iController = (dwChannel >> 8);
   \   0000000C   0xE1B08425         LSRS     R8,R5,#+8
    246          	uint8_t iChannel = (dwChannel) & 0xFF;
   \   00000010   0xE1B06005         MOVS     R6,R5
    247          	uint32_t _dwdmaId;
    248          
    249          	assert(pXdmad != NULL);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000004         BNE      ??XDMAD_PrepareChannel_0
   \   0000001C   0xE3A020F9         MOV      R2,#+249
   \   00000020   0x........         LDR      R1,??DataTable6
   \   00000024   0x........         LDR      R0,??DataTable6_1
   \   00000028   0x........         BL       __aeabi_assert
   \   0000002C   0x........         BL       __iar_EmptyStepPoint
    250          	Xdmac *pXdmac = pXdmad->pXdmacs[_iController];
   \                     ??XDMAD_PrepareChannel_0:
   \   00000030   0xE1B00008         MOVS     R0,R8
   \   00000034   0xE6EF0070         UXTB     R0,R0
   \   00000038   0xE1B00100         LSLS     R0,R0,#+2
   \   0000003C   0xE7909004         LDR      R9,[R0, +R4]
    251          
    252          	if (pXdmad->XdmaChannels[_iController][iChannel].state ==
    253          	    XDMAD_STATE_FREE)
   \   00000040   0xE1B00008         MOVS     R0,R8
   \   00000044   0xE6EF0070         UXTB     R0,R0
   \   00000048   0xE1B00400         LSLS     R0,R0,#+8
   \   0000004C   0xE0900004         ADDS     R0,R0,R4
   \   00000050   0xE1B01006         MOVS     R1,R6
   \   00000054   0xE6EF1071         UXTB     R1,R1
   \   00000058   0xE1B01201         LSLS     R1,R1,#+4
   \   0000005C   0xE0910000         ADDS     R0,R1,R0
   \   00000060   0xE5D00017         LDRB     R0,[R0, #+23]
   \   00000064   0xE3500000         CMP      R0,#+0
   \   00000068   0x1A000001         BNE      ??XDMAD_PrepareChannel_1
    254          		return XDMAD_ERROR;
   \   0000006C   0xE3A00004         MOV      R0,#+4
   \   00000070   0xEA00004D         B        ??XDMAD_PrepareChannel_2
    255          	else if (pXdmad->XdmaChannels[_iController][iChannel].state ==
    256          		 XDMAD_STATE_START)
   \                     ??XDMAD_PrepareChannel_1:
   \   00000074   0xE1B00008         MOVS     R0,R8
   \   00000078   0xE6EF0070         UXTB     R0,R0
   \   0000007C   0xE1B00400         LSLS     R0,R0,#+8
   \   00000080   0xE0900004         ADDS     R0,R0,R4
   \   00000084   0xE1B01006         MOVS     R1,R6
   \   00000088   0xE6EF1071         UXTB     R1,R1
   \   0000008C   0xE1B01201         LSLS     R1,R1,#+4
   \   00000090   0xE0910000         ADDS     R0,R1,R0
   \   00000094   0xE5D00017         LDRB     R0,[R0, #+23]
   \   00000098   0xE3500002         CMP      R0,#+2
   \   0000009C   0x1A000001         BNE      ??XDMAD_PrepareChannel_3
    257          		return XDMAD_BUSY;
   \   000000A0   0xE3A00003         MOV      R0,#+3
   \   000000A4   0xEA000040         B        ??XDMAD_PrepareChannel_2
    258          	/* Clear dummy status */
    259          	XDMAC_GetGlobalChStatus(pXdmac);
   \                     ??XDMAD_PrepareChannel_3:
   \   000000A8   0xE1B00009         MOVS     R0,R9
   \   000000AC   0x........         BL       XDMAC_GetGlobalChStatus
    260          	XDMAC_GetGIsr(pXdmac);
   \   000000B0   0xE1B00009         MOVS     R0,R9
   \   000000B4   0x........         BL       XDMAC_GetGIsr
    261          	_dwdmaId = (_iController == 0) ? ID_XDMAC0 : ID_XDMAC1;
   \   000000B8   0xE1B00008         MOVS     R0,R8
   \   000000BC   0xE6EF0070         UXTB     R0,R0
   \   000000C0   0xE3500000         CMP      R0,#+0
   \   000000C4   0x1A000001         BNE      ??XDMAD_PrepareChannel_4
   \   000000C8   0xE3A07006         MOV      R7,#+6
   \   000000CC   0xEA000000         B        ??XDMAD_PrepareChannel_5
   \                     ??XDMAD_PrepareChannel_4:
   \   000000D0   0xE3A07007         MOV      R7,#+7
    262          	/* Enable clock of the DMA peripheral */
    263          	if (!pmc_is_peripheral_enabled(_dwdmaId)) {
   \                     ??XDMAD_PrepareChannel_5:
   \   000000D4   0xE1B00007         MOVS     R0,R7
   \   000000D8   0x........         BL       pmc_is_peripheral_enabled
   \   000000DC   0xE3500000         CMP      R0,#+0
   \   000000E0   0x1A000001         BNE      ??XDMAD_PrepareChannel_6
    264          		pmc_enable_peripheral(_dwdmaId);
   \   000000E4   0xE1B00007         MOVS     R0,R7
   \   000000E8   0x........         BL       pmc_enable_peripheral
    265          	}
    266          	/* Clear dummy status */
    267          	XDMAC_GetChannelIsr(pXdmac, iChannel);
   \                     ??XDMAD_PrepareChannel_6:
   \   000000EC   0xE1B01006         MOVS     R1,R6
   \   000000F0   0xE6EF1071         UXTB     R1,R1
   \   000000F4   0xE1B00009         MOVS     R0,R9
   \   000000F8   0x........         BL       XDMAC_GetChannelIsr
    268          	/* Disables XDMAC interrupt for the given channel. */
    269          	XDMAC_DisableGIt(pXdmac, -1);
   \   000000FC   0xE3E01000         MVN      R1,#+0
   \   00000100   0xE1B00009         MOVS     R0,R9
   \   00000104   0x........         BL       XDMAC_DisableGIt
    270          	XDMAC_DisableChannelIt(pXdmac, iChannel, -1);
   \   00000108   0xE3E02000         MVN      R2,#+0
   \   0000010C   0xE1B01006         MOVS     R1,R6
   \   00000110   0xE6EF1071         UXTB     R1,R1
   \   00000114   0xE1B00009         MOVS     R0,R9
   \   00000118   0x........         BL       XDMAC_DisableChannelIt
    271          	/* Disable the given dma channel. */
    272          	XDMAC_DisableChannel(pXdmac, iChannel);
   \   0000011C   0xE1B01006         MOVS     R1,R6
   \   00000120   0xE6EF1071         UXTB     R1,R1
   \   00000124   0xE1B00009         MOVS     R0,R9
   \   00000128   0x........         BL       XDMAC_DisableChannel
    273          	XDMAC_SetSourceAddr(pXdmac, iChannel, 0);
   \   0000012C   0xE3A02000         MOV      R2,#+0
   \   00000130   0xE1B01006         MOVS     R1,R6
   \   00000134   0xE6EF1071         UXTB     R1,R1
   \   00000138   0xE1B00009         MOVS     R0,R9
   \   0000013C   0x........         BL       XDMAC_SetSourceAddr
    274          	XDMAC_SetDestinationAddr(pXdmac, iChannel, 0);
   \   00000140   0xE3A02000         MOV      R2,#+0
   \   00000144   0xE1B01006         MOVS     R1,R6
   \   00000148   0xE6EF1071         UXTB     R1,R1
   \   0000014C   0xE1B00009         MOVS     R0,R9
   \   00000150   0x........         BL       XDMAC_SetDestinationAddr
    275          	XDMAC_SetBlockControl(pXdmac, iChannel, 0);
   \   00000154   0xE3A02000         MOV      R2,#+0
   \   00000158   0xE1B01006         MOVS     R1,R6
   \   0000015C   0xE6EF1071         UXTB     R1,R1
   \   00000160   0xE1B00009         MOVS     R0,R9
   \   00000164   0x........         BL       XDMAC_SetBlockControl
    276          	XDMAC_SetChannelConfig(pXdmac, iChannel, 0x20);
   \   00000168   0xE3A02020         MOV      R2,#+32
   \   0000016C   0xE1B01006         MOVS     R1,R6
   \   00000170   0xE6EF1071         UXTB     R1,R1
   \   00000174   0xE1B00009         MOVS     R0,R9
   \   00000178   0x........         BL       XDMAC_SetChannelConfig
    277          	XDMAC_SetDescriptorAddr(pXdmac, iChannel, 0, 0);
   \   0000017C   0xE3A03000         MOV      R3,#+0
   \   00000180   0xE3A02000         MOV      R2,#+0
   \   00000184   0xE1B01006         MOVS     R1,R6
   \   00000188   0xE6EF1071         UXTB     R1,R1
   \   0000018C   0xE1B00009         MOVS     R0,R9
   \   00000190   0x........         BL       XDMAC_SetDescriptorAddr
    278          	XDMAC_SetDescriptorControl(pXdmac, iChannel, 0);
   \   00000194   0xE3A02000         MOV      R2,#+0
   \   00000198   0xE1B01006         MOVS     R1,R6
   \   0000019C   0xE6EF1071         UXTB     R1,R1
   \   000001A0   0xE1B00009         MOVS     R0,R9
   \   000001A4   0x........         BL       XDMAC_SetDescriptorControl
    279          	return XDMAD_OK;
   \   000001A8   0xE3A00000         MOV      R0,#+0
   \                     ??XDMAD_PrepareChannel_2:
   \   000001AC   0xE8BD83F2         POP      {R1,R4-R9,PC}    ;; return
    280          }
    281          
    282          /**
    283           * \brief xDMA interrupt handler
    284           * \param pXdmad Pointer to DMA driver instance.
    285           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    286          void XDMAD_Handler(sXdmad * pXdmad)
    287          {
   \                     XDMAD_Handler:
   \   00000000   0xE92D4FF8         PUSH     {R3-R11,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    288          	Xdmac *pXdmac;
    289          	sXdmadChannel *pCh;
    290          	uint32_t xdmaChannelIntStatus, xdmaGlobaIntStatus, xdmaGlobalChStatus;
    291          	uint8_t bExec = 0;
   \   00000008   0xE3A09000         MOV      R9,#+0
    292          	uint8_t _iController, _iChannel;
    293          	assert(pXdmad != NULL);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??XDMAD_Handler_0
   \   00000014   0xE3002125         MOVW     R2,#+293
   \   00000018   0x........         LDR      R1,??DataTable6
   \   0000001C   0x........         LDR      R0,??DataTable6_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    294          
    295          	for (_iController = 0; _iController < pXdmad->numControllers;
   \                     ??XDMAD_Handler_0:
   \   00000028   0xE3A00000         MOV      R0,#+0
   \   0000002C   0xE1B0A000         MOVS     R10,R0
   \                     ??XDMAD_Handler_1:
   \   00000030   0xE5D40208         LDRB     R0,[R4, #+520]
   \   00000034   0xE6EFA07A         UXTB     R10,R10
   \   00000038   0xE15A0000         CMP      R10,R0
   \   0000003C   0x2A000057         BCS      ??XDMAD_Handler_2
    296          	     _iController++) {
    297          		pXdmac = pXdmad->pXdmacs[_iController];
   \   00000040   0xE1B0000A         MOVS     R0,R10
   \   00000044   0xE6EF0070         UXTB     R0,R0
   \   00000048   0xE1B00100         LSLS     R0,R0,#+2
   \   0000004C   0xE7900004         LDR      R0,[R0, +R4]
   \   00000050   0xE1B05000         MOVS     R5,R0
    298          		xdmaGlobaIntStatus = XDMAC_GetGIsr(pXdmac);
   \   00000054   0xE1B00005         MOVS     R0,R5
   \   00000058   0x........         BL       XDMAC_GetGIsr
   \   0000005C   0xE1B08000         MOVS     R8,R0
    299          		if ((xdmaGlobaIntStatus & 0xFFFF) == 0)
   \   00000060   0xE1B00808         LSLS     R0,R8,#+16
   \   00000064   0xE1B00820         LSRS     R0,R0,#+16
   \   00000068   0xE3500000         CMP      R0,#+0
   \   0000006C   0x0A000049         BEQ      ??XDMAD_Handler_3
    300          			continue;
    301          		xdmaGlobalChStatus = XDMAC_GetGlobalChStatus(pXdmac);
   \                     ??XDMAD_Handler_4:
   \   00000070   0xE1B00005         MOVS     R0,R5
   \   00000074   0x........         BL       XDMAC_GetGlobalChStatus
   \   00000078   0xE58D0000         STR      R0,[SP, #+0]
    302          		for (_iChannel = 0; _iChannel < pXdmad->numChannels; _iChannel++) {
   \   0000007C   0xE3A00000         MOV      R0,#+0
   \   00000080   0xE1B0B000         MOVS     R11,R0
   \                     ??XDMAD_Handler_5:
   \   00000084   0xE5D40209         LDRB     R0,[R4, #+521]
   \   00000088   0xE6EFB07B         UXTB     R11,R11
   \   0000008C   0xE15B0000         CMP      R11,R0
   \   00000090   0x2A000040         BCS      ??XDMAD_Handler_3
    303          			if (!(xdmaGlobaIntStatus & (1 << _iChannel)))
   \   00000094   0xE3A00001         MOV      R0,#+1
   \   00000098   0xE1100B38         TST      R0,R8, LSR R11
   \   0000009C   0x0A00003B         BEQ      ??XDMAD_Handler_6
    304          				continue;
    305          			pCh = &pXdmad->XdmaChannels[_iController][_iChannel];
   \                     ??XDMAD_Handler_7:
   \   000000A0   0xE1B0000A         MOVS     R0,R10
   \   000000A4   0xE6EF0070         UXTB     R0,R0
   \   000000A8   0xE1B00400         LSLS     R0,R0,#+8
   \   000000AC   0xE0900004         ADDS     R0,R0,R4
   \   000000B0   0xE1B0100B         MOVS     R1,R11
   \   000000B4   0xE6EF1071         UXTB     R1,R1
   \   000000B8   0xE1B01201         LSLS     R1,R1,#+4
   \   000000BC   0xE0910000         ADDS     R0,R1,R0
   \   000000C0   0xE2900008         ADDS     R0,R0,#+8
   \   000000C4   0xE1B06000         MOVS     R6,R0
    306          			if (pCh->state == XDMAD_STATE_FREE)
   \   000000C8   0xE5D6000F         LDRB     R0,[R6, #+15]
   \   000000CC   0xE3500000         CMP      R0,#+0
   \   000000D0   0x0A000032         BEQ      ??XDMAD_Handler_8
    307          				return;
    308          			if ((xdmaGlobalChStatus & (XDMAC_GS_ST0 << _iChannel))
    309          			    == 0) {
   \                     ??XDMAD_Handler_9:
   \   000000D4   0xE59D0000         LDR      R0,[SP, #+0]
   \   000000D8   0xE3A01001         MOV      R1,#+1
   \   000000DC   0xE1110B30         TST      R1,R0, LSR R11
   \   000000E0   0x1A00001E         BNE      ??XDMAD_Handler_10
    310          				bExec = 0;
   \   000000E4   0xE3A00000         MOV      R0,#+0
   \   000000E8   0xE1B09000         MOVS     R9,R0
    311          				xdmaChannelIntStatus =
    312          				    XDMAC_GetChannelIsr(pXdmac, _iChannel);
   \   000000EC   0xE1B0100B         MOVS     R1,R11
   \   000000F0   0xE6EF1071         UXTB     R1,R1
   \   000000F4   0xE1B00005         MOVS     R0,R5
   \   000000F8   0x........         BL       XDMAC_GetChannelIsr
   \   000000FC   0xE1B07000         MOVS     R7,R0
    313          				if (xdmaChannelIntStatus & XDMAC_CIS_BIS) {
   \   00000100   0xE3170001         TST      R7,#0x1
   \   00000104   0x0A000009         BEQ      ??XDMAD_Handler_11
    314          					if ((XDMAC_GetChannelItMask
    315          					     (pXdmac,
    316          					      _iChannel) & XDMAC_CIM_LIM) ==
    317          					    0) {
   \   00000108   0xE1B0100B         MOVS     R1,R11
   \   0000010C   0xE6EF1071         UXTB     R1,R1
   \   00000110   0xE1B00005         MOVS     R0,R5
   \   00000114   0x........         BL       XDMAC_GetChannelItMask
   \   00000118   0xE3100002         TST      R0,#0x2
   \   0000011C   0x1A000003         BNE      ??XDMAD_Handler_11
    318          						pCh->state = XDMAD_STATE_DONE;
   \   00000120   0xE3A00004         MOV      R0,#+4
   \   00000124   0xE5C6000F         STRB     R0,[R6, #+15]
    319          						bExec = 1;
   \   00000128   0xE3A00001         MOV      R0,#+1
   \   0000012C   0xE1B09000         MOVS     R9,R0
    320          					}
    321          					//printf("XDMAC_CIS_BIS\n\r");
    322          				}
    323          				if (xdmaChannelIntStatus & XDMAC_CIS_FIS) {
    324          					// printf("XDMAC_CIS_FIS\n\r");
    325          				}
    326          				if (xdmaChannelIntStatus & XDMAC_CIS_RBEIS) {
    327          					//printf("XDMAC_CIS_RBEIS\n\r");
    328          				}
    329          				if (xdmaChannelIntStatus & XDMAC_CIS_WBEIS) {
    330          					// printf("XDMAC_CIS_WBEIS\n\r");
    331          				}
    332          				if (xdmaChannelIntStatus & XDMAC_CIS_ROIS) {
    333          					// printf("XDMAC_CIS_ROIS\n\r");
    334          				}
    335          				if (xdmaChannelIntStatus & XDMAC_CIS_LIS) {
   \                     ??XDMAD_Handler_11:
   \   00000130   0xE3170002         TST      R7,#0x2
   \   00000134   0x0A000003         BEQ      ??XDMAD_Handler_12
    336          					//printf("XDMAC_CIS_LIS\n\r");
    337          
    338          					pCh->state = XDMAD_STATE_DONE;
   \   00000138   0xE3A00004         MOV      R0,#+4
   \   0000013C   0xE5C6000F         STRB     R0,[R6, #+15]
    339          					bExec = 1;
   \   00000140   0xE3A00001         MOV      R0,#+1
   \   00000144   0xE1B09000         MOVS     R9,R0
    340          				}
    341          				if (xdmaChannelIntStatus & XDMAC_CIS_DIS) {
   \                     ??XDMAD_Handler_12:
   \   00000148   0xE3170004         TST      R7,#0x4
   \   0000014C   0x0A000003         BEQ      ??XDMAD_Handler_10
    342          					pCh->state = XDMAD_STATE_DONE;
   \   00000150   0xE3A00004         MOV      R0,#+4
   \   00000154   0xE5C6000F         STRB     R0,[R6, #+15]
    343          					bExec = 1;
   \   00000158   0xE3A00001         MOV      R0,#+1
   \   0000015C   0xE1B09000         MOVS     R9,R0
    344          				}
    345          			}
    346          			// printf("bExec =%d, _iChannel=%d \n\r",bExec,_iChannel);
    347          			/* Execute callback */
    348          			if (bExec && pCh->fCallback) {
   \                     ??XDMAD_Handler_10:
   \   00000160   0xE1B00009         MOVS     R0,R9
   \   00000164   0xE6EF0070         UXTB     R0,R0
   \   00000168   0xE3500000         CMP      R0,#+0
   \   0000016C   0x0A000007         BEQ      ??XDMAD_Handler_6
   \   00000170   0xE5960000         LDR      R0,[R6, #+0]
   \   00000174   0xE3500000         CMP      R0,#+0
   \   00000178   0x0A000004         BEQ      ??XDMAD_Handler_6
    349          				//XDMAC_DisableGIt( pXdmac,1 << _iChannel);
    350          				pCh->fCallback(_iChannel, pCh->pArg);
   \   0000017C   0xE5961004         LDR      R1,[R6, #+4]
   \   00000180   0xE1B0000B         MOVS     R0,R11
   \   00000184   0xE6EF0070         UXTB     R0,R0
   \   00000188   0xE5962000         LDR      R2,[R6, #+0]
   \   0000018C   0xE12FFF32         BLX      R2
    351          			}
    352          		}
   \                     ??XDMAD_Handler_6:
   \   00000190   0xE29BB001         ADDS     R11,R11,#+1
   \   00000194   0xEAFFFFBA         B        ??XDMAD_Handler_5
    353          	}
   \                     ??XDMAD_Handler_3:
   \   00000198   0xE29AA001         ADDS     R10,R10,#+1
   \   0000019C   0xEAFFFFA3         B        ??XDMAD_Handler_1
    354          }
   \                     ??XDMAD_Handler_2:
   \                     ??XDMAD_Handler_8:
   \   000001A0   0xE8BD8FF1         POP      {R0,R4-R11,PC}   ;; return
    355          
    356          /**
    357           * \brief Check if DMA transfer is finished.
    358           *        In polling mode XDMAD_Handler() is polled.
    359           * \param pXdmad    Pointer to DMA driver instance.
    360           * \param dwChannel ControllerNumber << 8 | ChannelNumber.
    361           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    362          eXdmadRC XDMAD_IsTransferDone(sXdmad * pXdmad, uint32_t dwChannel)
    363          {
   \                     XDMAD_IsTransferDone:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    364          	uint8_t _iController = (dwChannel >> 8);
   \   0000000C   0xE1B06425         LSRS     R6,R5,#+8
    365          	uint8_t iChannel = (dwChannel) & 0xFF;
   \   00000010   0xE1B08005         MOVS     R8,R5
    366          	uint8_t state;
    367          	state = pXdmad->XdmaChannels[_iController][iChannel].state;
   \   00000014   0xE1B00006         MOVS     R0,R6
   \   00000018   0xE6EF0070         UXTB     R0,R0
   \   0000001C   0xE1B00400         LSLS     R0,R0,#+8
   \   00000020   0xE0900004         ADDS     R0,R0,R4
   \   00000024   0xE1B01008         MOVS     R1,R8
   \   00000028   0xE6EF1071         UXTB     R1,R1
   \   0000002C   0xE1B01201         LSLS     R1,R1,#+4
   \   00000030   0xE0910000         ADDS     R0,R1,R0
   \   00000034   0xE5D00017         LDRB     R0,[R0, #+23]
   \   00000038   0xE1B07000         MOVS     R7,R0
    368          	assert(pXdmad != NULL);
   \   0000003C   0xE3540000         CMP      R4,#+0
   \   00000040   0x1A000004         BNE      ??XDMAD_IsTransferDone_0
   \   00000044   0xE3A02F5C         MOV      R2,#+368
   \   00000048   0x........         LDR      R1,??DataTable6
   \   0000004C   0x........         LDR      R0,??DataTable6_1
   \   00000050   0x........         BL       __aeabi_assert
   \   00000054   0x........         BL       __iar_EmptyStepPoint
    369          	if (state == XDMAD_STATE_ALLOCATED)
   \                     ??XDMAD_IsTransferDone_0:
   \   00000058   0xE1B00007         MOVS     R0,R7
   \   0000005C   0xE6EF0070         UXTB     R0,R0
   \   00000060   0xE3500001         CMP      R0,#+1
   \   00000064   0x1A000001         BNE      ??XDMAD_IsTransferDone_1
    370          		return XDMAD_OK;
   \   00000068   0xE3A00000         MOV      R0,#+0
   \   0000006C   0xEA000011         B        ??XDMAD_IsTransferDone_2
    371          	if (state == XDMAD_STATE_FREE)
   \                     ??XDMAD_IsTransferDone_1:
   \   00000070   0xE1B00007         MOVS     R0,R7
   \   00000074   0xE6EF0070         UXTB     R0,R0
   \   00000078   0xE3500000         CMP      R0,#+0
   \   0000007C   0x1A000001         BNE      ??XDMAD_IsTransferDone_3
    372          		return XDMAD_ERROR;
   \   00000080   0xE3A00004         MOV      R0,#+4
   \   00000084   0xEA00000B         B        ??XDMAD_IsTransferDone_2
    373          	else if (state != XDMAD_STATE_DONE) {
   \                     ??XDMAD_IsTransferDone_3:
   \   00000088   0xE1B00007         MOVS     R0,R7
   \   0000008C   0xE6EF0070         UXTB     R0,R0
   \   00000090   0xE3500004         CMP      R0,#+4
   \   00000094   0x0A000006         BEQ      ??XDMAD_IsTransferDone_4
    374          		if (pXdmad->pollingMode)
   \   00000098   0xE5D4020A         LDRB     R0,[R4, #+522]
   \   0000009C   0xE3500000         CMP      R0,#+0
   \   000000A0   0x0A000001         BEQ      ??XDMAD_IsTransferDone_5
    375          			XDMAD_Handler(pXdmad);
   \   000000A4   0xE1B00004         MOVS     R0,R4
   \   000000A8   0x........         BL       XDMAD_Handler
    376          		return XDMAD_BUSY;
   \                     ??XDMAD_IsTransferDone_5:
   \   000000AC   0xE3A00003         MOV      R0,#+3
   \   000000B0   0xEA000000         B        ??XDMAD_IsTransferDone_2
    377          	}
    378          	return XDMAD_OK;
   \                     ??XDMAD_IsTransferDone_4:
   \   000000B4   0xE3A00000         MOV      R0,#+0
   \                     ??XDMAD_IsTransferDone_2:
   \   000000B8   0xE8BD81F0         POP      {R4-R8,PC}       ;; return
    379          }
    380          
    381          /**
    382           * \brief Configure DMA for a single transfer.
    383           * \param pXdmad     Pointer to xDMA driver instance.
    384           * \param dwChannel ControllerNumber << 8 | ChannelNumber.
    385           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    386          eXdmadRC XDMAD_ConfigureTransfer(sXdmad * pXdmad, uint32_t dwChannel,
    387          			sXdmadCfg * pXdmaParam, uint32_t dwXdmaDescCfg,
    388          			uint32_t dwXdmaDescAddr)
    389          {
   \                     XDMAD_ConfigureTransfer:
   \   00000000   0xE92D4FF8         PUSH     {R3-R11,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
   \   00000014   0xE59D8028         LDR      R8,[SP, #+40]
    390          	uint8_t _iController = (dwChannel >> 8);
   \   00000018   0xE1B0A425         LSRS     R10,R5,#+8
    391          	uint8_t iChannel = (dwChannel) & 0xFF;
   \   0000001C   0xE1B09005         MOVS     R9,R5
    392          	Xdmac *pXdmac = pXdmad->pXdmacs[_iController];
   \   00000020   0xE1B0000A         MOVS     R0,R10
   \   00000024   0xE6EF0070         UXTB     R0,R0
   \   00000028   0xE1B00100         LSLS     R0,R0,#+2
   \   0000002C   0xE790B004         LDR      R11,[R0, +R4]
    393          	XDMAC_GetGIsr(pXdmac);
   \   00000030   0xE1B0000B         MOVS     R0,R11
   \   00000034   0x........         BL       XDMAC_GetGIsr
    394          	XDMAC_GetChannelIsr(pXdmac, iChannel);
   \   00000038   0xE1B01009         MOVS     R1,R9
   \   0000003C   0xE6EF1071         UXTB     R1,R1
   \   00000040   0xE1B0000B         MOVS     R0,R11
   \   00000044   0x........         BL       XDMAC_GetChannelIsr
    395          	if (pXdmad->XdmaChannels[_iController][iChannel].state ==
    396          	    XDMAD_STATE_FREE)
   \   00000048   0xE1B0000A         MOVS     R0,R10
   \   0000004C   0xE6EF0070         UXTB     R0,R0
   \   00000050   0xE1B00400         LSLS     R0,R0,#+8
   \   00000054   0xE0900004         ADDS     R0,R0,R4
   \   00000058   0xE1B01009         MOVS     R1,R9
   \   0000005C   0xE6EF1071         UXTB     R1,R1
   \   00000060   0xE1B01201         LSLS     R1,R1,#+4
   \   00000064   0xE0910000         ADDS     R0,R1,R0
   \   00000068   0xE5D00017         LDRB     R0,[R0, #+23]
   \   0000006C   0xE3500000         CMP      R0,#+0
   \   00000070   0x1A000001         BNE      ??XDMAD_ConfigureTransfer_0
    397          		return XDMAD_ERROR;
   \   00000074   0xE3A00004         MOV      R0,#+4
   \   00000078   0xEA000076         B        ??XDMAD_ConfigureTransfer_1
    398          	if (pXdmad->XdmaChannels[_iController][iChannel].state ==
    399          	    XDMAD_STATE_START)
   \                     ??XDMAD_ConfigureTransfer_0:
   \   0000007C   0xE1B0000A         MOVS     R0,R10
   \   00000080   0xE6EF0070         UXTB     R0,R0
   \   00000084   0xE1B00400         LSLS     R0,R0,#+8
   \   00000088   0xE0900004         ADDS     R0,R0,R4
   \   0000008C   0xE1B01009         MOVS     R1,R9
   \   00000090   0xE6EF1071         UXTB     R1,R1
   \   00000094   0xE1B01201         LSLS     R1,R1,#+4
   \   00000098   0xE0910000         ADDS     R0,R1,R0
   \   0000009C   0xE5D00017         LDRB     R0,[R0, #+23]
   \   000000A0   0xE3500002         CMP      R0,#+2
   \   000000A4   0x1A000001         BNE      ??XDMAD_ConfigureTransfer_2
    400          		return XDMAD_BUSY;
   \   000000A8   0xE3A00003         MOV      R0,#+3
   \   000000AC   0xEA000069         B        ??XDMAD_ConfigureTransfer_1
    401          	/* Linked List is enabled */
    402          	if ((dwXdmaDescCfg & XDMAC_CNDC_NDE) == XDMAC_CNDC_NDE_DSCR_FETCH_EN) {
   \                     ??XDMAD_ConfigureTransfer_2:
   \   000000B0   0xE3170001         TST      R7,#0x1
   \   000000B4   0x0A00002E         BEQ      ??XDMAD_ConfigureTransfer_3
    403          		if ((dwXdmaDescCfg & XDMAC_CNDC_NDVIEW_Msk) ==
    404          		    XDMAC_CNDC_NDVIEW_NDV0) {
   \   000000B8   0xE3170018         TST      R7,#0x18
   \   000000BC   0x1A00000E         BNE      ??XDMAD_ConfigureTransfer_4
    405          			XDMAC_SetChannelConfig(pXdmac, iChannel,
    406          					       pXdmaParam->mbr_cfg);
   \   000000C0   0xE596200C         LDR      R2,[R6, #+12]
   \   000000C4   0xE1B01009         MOVS     R1,R9
   \   000000C8   0xE6EF1071         UXTB     R1,R1
   \   000000CC   0xE1B0000B         MOVS     R0,R11
   \   000000D0   0x........         BL       XDMAC_SetChannelConfig
    407          			XDMAC_SetSourceAddr(pXdmac, iChannel,
    408          					    pXdmaParam->mbr_sa);
   \   000000D4   0xE5962004         LDR      R2,[R6, #+4]
   \   000000D8   0xE1B01009         MOVS     R1,R9
   \   000000DC   0xE6EF1071         UXTB     R1,R1
   \   000000E0   0xE1B0000B         MOVS     R0,R11
   \   000000E4   0x........         BL       XDMAC_SetSourceAddr
    409          			XDMAC_SetDestinationAddr(pXdmac, iChannel,
    410          						 pXdmaParam->mbr_da);
   \   000000E8   0xE5962008         LDR      R2,[R6, #+8]
   \   000000EC   0xE1B01009         MOVS     R1,R9
   \   000000F0   0xE6EF1071         UXTB     R1,R1
   \   000000F4   0xE1B0000B         MOVS     R0,R11
   \   000000F8   0x........         BL       XDMAC_SetDestinationAddr
    411          		}
    412          		if ((dwXdmaDescCfg & XDMAC_CNDC_NDVIEW_Msk) ==
    413          		    XDMAC_CNDC_NDVIEW_NDV1) {
   \                     ??XDMAD_ConfigureTransfer_4:
   \   000000FC   0xE2170018         ANDS     R0,R7,#0x18
   \   00000100   0xE3500008         CMP      R0,#+8
   \   00000104   0x1A000004         BNE      ??XDMAD_ConfigureTransfer_5
    414          			XDMAC_SetChannelConfig(pXdmac, iChannel,
    415          					       pXdmaParam->mbr_cfg);
   \   00000108   0xE596200C         LDR      R2,[R6, #+12]
   \   0000010C   0xE1B01009         MOVS     R1,R9
   \   00000110   0xE6EF1071         UXTB     R1,R1
   \   00000114   0xE1B0000B         MOVS     R0,R11
   \   00000118   0x........         BL       XDMAC_SetChannelConfig
    416          		}
    417          		XDMAC_SetDescriptorAddr(pXdmac, iChannel, dwXdmaDescAddr, 0);
   \                     ??XDMAD_ConfigureTransfer_5:
   \   0000011C   0xE3A03000         MOV      R3,#+0
   \   00000120   0xE1B02008         MOVS     R2,R8
   \   00000124   0xE1B01009         MOVS     R1,R9
   \   00000128   0xE6EF1071         UXTB     R1,R1
   \   0000012C   0xE1B0000B         MOVS     R0,R11
   \   00000130   0x........         BL       XDMAC_SetDescriptorAddr
    418          		XDMAC_SetDescriptorControl(pXdmac, iChannel, dwXdmaDescCfg);
   \   00000134   0xE1B02007         MOVS     R2,R7
   \   00000138   0xE1B01009         MOVS     R1,R9
   \   0000013C   0xE6EF1071         UXTB     R1,R1
   \   00000140   0xE1B0000B         MOVS     R0,R11
   \   00000144   0x........         BL       XDMAC_SetDescriptorControl
    419          		XDMAC_DisableChannelIt(pXdmac, iChannel, -1);
   \   00000148   0xE3E02000         MVN      R2,#+0
   \   0000014C   0xE1B01009         MOVS     R1,R9
   \   00000150   0xE6EF1071         UXTB     R1,R1
   \   00000154   0xE1B0000B         MOVS     R0,R11
   \   00000158   0x........         BL       XDMAC_DisableChannelIt
    420          		XDMAC_EnableChannelIt(pXdmac, iChannel, XDMAC_CIE_LIE);
   \   0000015C   0xE3A02002         MOV      R2,#+2
   \   00000160   0xE1B01009         MOVS     R1,R9
   \   00000164   0xE6EF1071         UXTB     R1,R1
   \   00000168   0xE1B0000B         MOVS     R0,R11
   \   0000016C   0x........         BL       XDMAC_EnableChannelIt
   \   00000170   0xEA000037         B        ??XDMAD_ConfigureTransfer_6
    421          	}
    422          	/* LLI is disabled. */
    423          	else {
    424          		XDMAC_SetSourceAddr(pXdmac, iChannel, pXdmaParam->mbr_sa);
   \                     ??XDMAD_ConfigureTransfer_3:
   \   00000174   0xE5962004         LDR      R2,[R6, #+4]
   \   00000178   0xE1B01009         MOVS     R1,R9
   \   0000017C   0xE6EF1071         UXTB     R1,R1
   \   00000180   0xE1B0000B         MOVS     R0,R11
   \   00000184   0x........         BL       XDMAC_SetSourceAddr
    425          		XDMAC_SetDestinationAddr(pXdmac, iChannel, pXdmaParam->mbr_da);
   \   00000188   0xE5962008         LDR      R2,[R6, #+8]
   \   0000018C   0xE1B01009         MOVS     R1,R9
   \   00000190   0xE6EF1071         UXTB     R1,R1
   \   00000194   0xE1B0000B         MOVS     R0,R11
   \   00000198   0x........         BL       XDMAC_SetDestinationAddr
    426          		XDMAC_SetMicroblockControl(pXdmac, iChannel,
    427          					   pXdmaParam->mbr_ubc);
   \   0000019C   0xE5962000         LDR      R2,[R6, #+0]
   \   000001A0   0xE1B01009         MOVS     R1,R9
   \   000001A4   0xE6EF1071         UXTB     R1,R1
   \   000001A8   0xE1B0000B         MOVS     R0,R11
   \   000001AC   0x........         BL       XDMAC_SetMicroblockControl
    428          		XDMAC_SetBlockControl(pXdmac, iChannel, pXdmaParam->mbr_bc);
   \   000001B0   0xE5962010         LDR      R2,[R6, #+16]
   \   000001B4   0xE1B01009         MOVS     R1,R9
   \   000001B8   0xE6EF1071         UXTB     R1,R1
   \   000001BC   0xE1B0000B         MOVS     R0,R11
   \   000001C0   0x........         BL       XDMAC_SetBlockControl
    429          		XDMAC_SetDataStride_MemPattern(pXdmac, iChannel,
    430          					       pXdmaParam->mbr_ds);
   \   000001C4   0xE5962014         LDR      R2,[R6, #+20]
   \   000001C8   0xE1B01009         MOVS     R1,R9
   \   000001CC   0xE6EF1071         UXTB     R1,R1
   \   000001D0   0xE1B0000B         MOVS     R0,R11
   \   000001D4   0x........         BL       XDMAC_SetDataStride_MemPattern
    431          		XDMAC_SetSourceMicroBlockStride(pXdmac, iChannel,
    432          						pXdmaParam->mbr_sus);
   \   000001D8   0xE5962018         LDR      R2,[R6, #+24]
   \   000001DC   0xE1B01009         MOVS     R1,R9
   \   000001E0   0xE6EF1071         UXTB     R1,R1
   \   000001E4   0xE1B0000B         MOVS     R0,R11
   \   000001E8   0x........         BL       XDMAC_SetSourceMicroBlockStride
    433          		XDMAC_SetDestinationMicroBlockStride(pXdmac, iChannel,
    434          						     pXdmaParam->mbr_dus);
   \   000001EC   0xE596201C         LDR      R2,[R6, #+28]
   \   000001F0   0xE1B01009         MOVS     R1,R9
   \   000001F4   0xE6EF1071         UXTB     R1,R1
   \   000001F8   0xE1B0000B         MOVS     R0,R11
   \   000001FC   0x........         BL       XDMAC_SetDestinationMicroBlockStride
    435          		XDMAC_SetChannelConfig(pXdmac, iChannel, pXdmaParam->mbr_cfg);
   \   00000200   0xE596200C         LDR      R2,[R6, #+12]
   \   00000204   0xE1B01009         MOVS     R1,R9
   \   00000208   0xE6EF1071         UXTB     R1,R1
   \   0000020C   0xE1B0000B         MOVS     R0,R11
   \   00000210   0x........         BL       XDMAC_SetChannelConfig
    436          		XDMAC_SetDescriptorAddr(pXdmac, iChannel, 0, 0);
   \   00000214   0xE3A03000         MOV      R3,#+0
   \   00000218   0xE3A02000         MOV      R2,#+0
   \   0000021C   0xE1B01009         MOVS     R1,R9
   \   00000220   0xE6EF1071         UXTB     R1,R1
   \   00000224   0xE1B0000B         MOVS     R0,R11
   \   00000228   0x........         BL       XDMAC_SetDescriptorAddr
    437          		XDMAC_SetDescriptorControl(pXdmac, iChannel, 0);
   \   0000022C   0xE3A02000         MOV      R2,#+0
   \   00000230   0xE1B01009         MOVS     R1,R9
   \   00000234   0xE6EF1071         UXTB     R1,R1
   \   00000238   0xE1B0000B         MOVS     R0,R11
   \   0000023C   0x........         BL       XDMAC_SetDescriptorControl
    438          		XDMAC_EnableChannelIt(pXdmac,
    439          				      iChannel,
    440          				      XDMAC_CIE_BIE |
    441          				      XDMAC_CIE_DIE |
    442          				      XDMAC_CIE_FIE |
    443          				      XDMAC_CIE_RBIE |
    444          				      XDMAC_CIE_WBIE | XDMAC_CIE_ROIE);
   \   00000240   0xE3A0207D         MOV      R2,#+125
   \   00000244   0xE1B01009         MOVS     R1,R9
   \   00000248   0xE6EF1071         UXTB     R1,R1
   \   0000024C   0xE1B0000B         MOVS     R0,R11
   \   00000250   0x........         BL       XDMAC_EnableChannelIt
    445          	}
    446          	return XDMAD_OK;
   \                     ??XDMAD_ConfigureTransfer_6:
   \   00000254   0xE3A00000         MOV      R0,#+0
   \                     ??XDMAD_ConfigureTransfer_1:
   \   00000258   0xE8BD8FF2         POP      {R1,R4-R11,PC}   ;; return
    447          }
    448          
    449          /**
    450           * \brief Start xDMA transfer.
    451           * \param pXdmad     Pointer to XDMA driver instance.
    452           * \param dwChannel ControllerNumber << 8 | ChannelNumber.
    453           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    454          eXdmadRC XDMAD_StartTransfer(sXdmad * pXdmad, uint32_t dwChannel)
    455          {
   \                     XDMAD_StartTransfer:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    456          	uint8_t _iController = (dwChannel >> 8);
   \   0000000C   0xE1B06425         LSRS     R6,R5,#+8
    457          	uint8_t iChannel = (dwChannel) & 0xFF;
   \   00000010   0xE1B07005         MOVS     R7,R5
    458          	Xdmac *pXdmac = pXdmad->pXdmacs[_iController];
   \   00000014   0xE1B00006         MOVS     R0,R6
   \   00000018   0xE6EF0070         UXTB     R0,R0
   \   0000001C   0xE1B00100         LSLS     R0,R0,#+2
   \   00000020   0xE7908004         LDR      R8,[R0, +R4]
    459          	if (pXdmad->XdmaChannels[_iController][iChannel].state ==
    460          	    XDMAD_STATE_FREE) {
   \   00000024   0xE1B00006         MOVS     R0,R6
   \   00000028   0xE6EF0070         UXTB     R0,R0
   \   0000002C   0xE1B00400         LSLS     R0,R0,#+8
   \   00000030   0xE0900004         ADDS     R0,R0,R4
   \   00000034   0xE1B01007         MOVS     R1,R7
   \   00000038   0xE6EF1071         UXTB     R1,R1
   \   0000003C   0xE1B01201         LSLS     R1,R1,#+4
   \   00000040   0xE0910000         ADDS     R0,R1,R0
   \   00000044   0xE5D00017         LDRB     R0,[R0, #+23]
   \   00000048   0xE3500000         CMP      R0,#+0
   \   0000004C   0x1A000003         BNE      ??XDMAD_StartTransfer_0
    461          		printf("-E- XDMAD_STATE_FREE \n\r");
   \   00000050   0x........         LDR      R0,??DataTable6_2
   \   00000054   0x........         BL       printf
    462          		return XDMAD_ERROR;
   \   00000058   0xE3A00004         MOV      R0,#+4
   \   0000005C   0xEA000024         B        ??XDMAD_StartTransfer_1
    463          	} else if (pXdmad->XdmaChannels[_iController][iChannel].state ==
    464          		   XDMAD_STATE_START) {
   \                     ??XDMAD_StartTransfer_0:
   \   00000060   0xE1B00006         MOVS     R0,R6
   \   00000064   0xE6EF0070         UXTB     R0,R0
   \   00000068   0xE1B00400         LSLS     R0,R0,#+8
   \   0000006C   0xE0900004         ADDS     R0,R0,R4
   \   00000070   0xE1B01007         MOVS     R1,R7
   \   00000074   0xE6EF1071         UXTB     R1,R1
   \   00000078   0xE1B01201         LSLS     R1,R1,#+4
   \   0000007C   0xE0910000         ADDS     R0,R1,R0
   \   00000080   0xE5D00017         LDRB     R0,[R0, #+23]
   \   00000084   0xE3500002         CMP      R0,#+2
   \   00000088   0x1A000003         BNE      ??XDMAD_StartTransfer_2
    465          		printf("-E- XDMAD_STATE_START \n\r");
   \   0000008C   0x........         LDR      R0,??DataTable6_3
   \   00000090   0x........         BL       printf
    466          		return XDMAD_BUSY;
   \   00000094   0xE3A00003         MOV      R0,#+3
   \   00000098   0xEA000015         B        ??XDMAD_StartTransfer_1
    467          	}
    468          	/* Change state to transferring */
    469          	pXdmad->XdmaChannels[_iController][iChannel].state = XDMAD_STATE_START;
   \                     ??XDMAD_StartTransfer_2:
   \   0000009C   0xE1B00006         MOVS     R0,R6
   \   000000A0   0xE6EF0070         UXTB     R0,R0
   \   000000A4   0xE1B00400         LSLS     R0,R0,#+8
   \   000000A8   0xE0900004         ADDS     R0,R0,R4
   \   000000AC   0xE1B01007         MOVS     R1,R7
   \   000000B0   0xE6EF1071         UXTB     R1,R1
   \   000000B4   0xE1B01201         LSLS     R1,R1,#+4
   \   000000B8   0xE0910000         ADDS     R0,R1,R0
   \   000000BC   0xE3A01002         MOV      R1,#+2
   \   000000C0   0xE5C01017         STRB     R1,[R0, #+23]
    470          	XDMAC_EnableChannel(pXdmac, iChannel);
   \   000000C4   0xE1B01007         MOVS     R1,R7
   \   000000C8   0xE6EF1071         UXTB     R1,R1
   \   000000CC   0xE1B00008         MOVS     R0,R8
   \   000000D0   0x........         BL       XDMAC_EnableChannel
    471          	if (pXdmad->pollingMode == 0) {
   \   000000D4   0xE5D4020A         LDRB     R0,[R4, #+522]
   \   000000D8   0xE3500000         CMP      R0,#+0
   \   000000DC   0x1A000003         BNE      ??XDMAD_StartTransfer_3
    472          		XDMAC_EnableGIt(pXdmac, 1 << iChannel);
   \   000000E0   0xE3A00001         MOV      R0,#+1
   \   000000E4   0xE1B01710         LSLS     R1,R0,R7
   \   000000E8   0xE1B00008         MOVS     R0,R8
   \   000000EC   0x........         BL       XDMAC_EnableGIt
    473          	}
    474          	return XDMAD_OK;
   \                     ??XDMAD_StartTransfer_3:
   \   000000F0   0xE3A00000         MOV      R0,#+0
   \                     ??XDMAD_StartTransfer_1:
   \   000000F4   0xE8BD81F0         POP      {R4-R8,PC}       ;; return
    475          }
    476          
    477          /**
    478           * \brief Stop DMA transfer.
    479           * \param pXdmad     Pointer to DMA driver instance.
    480           * \param dwChannel ControllerNumber << 8 | ChannelNumber.
    481           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    482          eXdmadRC XDMAD_StopTransfer(sXdmad * pXdmad, uint32_t dwChannel)
    483          {
   \                     XDMAD_StopTransfer:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    484          	uint8_t _iController = (dwChannel >> 8);
   \   0000000C   0xE1B06425         LSRS     R6,R5,#+8
    485          	uint8_t _iChannel = (dwChannel) & 0xFF;
   \   00000010   0xE1B07005         MOVS     R7,R5
    486          	Xdmac *pXdmac = pXdmad->pXdmacs[_iController];
   \   00000014   0xE1B00006         MOVS     R0,R6
   \   00000018   0xE6EF0070         UXTB     R0,R0
   \   0000001C   0xE1B00100         LSLS     R0,R0,#+2
   \   00000020   0xE7908004         LDR      R8,[R0, +R4]
    487          
    488          	pXdmad->XdmaChannels[_iController][_iChannel].state =
    489          	    XDMAD_STATE_ALLOCATED;
   \   00000024   0xE1B00006         MOVS     R0,R6
   \   00000028   0xE6EF0070         UXTB     R0,R0
   \   0000002C   0xE1B00400         LSLS     R0,R0,#+8
   \   00000030   0xE0900004         ADDS     R0,R0,R4
   \   00000034   0xE1B01007         MOVS     R1,R7
   \   00000038   0xE6EF1071         UXTB     R1,R1
   \   0000003C   0xE1B01201         LSLS     R1,R1,#+4
   \   00000040   0xE0910000         ADDS     R0,R1,R0
   \   00000044   0xE3A01001         MOV      R1,#+1
   \   00000048   0xE5C01017         STRB     R1,[R0, #+23]
    490          	/* Disable channel */
    491          	XDMAC_DisableChannel(pXdmac, _iChannel);
   \   0000004C   0xE1B01007         MOVS     R1,R7
   \   00000050   0xE6EF1071         UXTB     R1,R1
   \   00000054   0xE1B00008         MOVS     R0,R8
   \   00000058   0x........         BL       XDMAC_DisableChannel
    492          	/* Disable interrupts */
    493          	XDMAC_DisableChannelIt(pXdmac, _iChannel, -1);
   \   0000005C   0xE3E02000         MVN      R2,#+0
   \   00000060   0xE1B01007         MOVS     R1,R7
   \   00000064   0xE6EF1071         UXTB     R1,R1
   \   00000068   0xE1B00008         MOVS     R0,R8
   \   0000006C   0x........         BL       XDMAC_DisableChannelIt
    494          	/* Clear pending status */
    495          	XDMAC_GetChannelIsr(pXdmac, _iChannel);
   \   00000070   0xE1B01007         MOVS     R1,R7
   \   00000074   0xE6EF1071         UXTB     R1,R1
   \   00000078   0xE1B00008         MOVS     R0,R8
   \   0000007C   0x........         BL       XDMAC_GetChannelIsr
    496          	XDMAC_GetGlobalChStatus(pXdmac);
   \   00000080   0xE1B00008         MOVS     R0,R8
   \   00000084   0x........         BL       XDMAC_GetGlobalChStatus
    497          
    498          	return XDMAD_OK;
   \   00000088   0xE3A00000         MOV      R0,#+0
   \   0000008C   0xE8BD81F0         POP      {R4-R8,PC}       ;; return
    499          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x70 0x58          DC8 "pXdmad != NULL"
   \              0x64 0x6D    
   \              0x61 0x64    
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 62H, 75H, 73H, 5CH
   \              0x73 0x5C    
   \              0x62 0x75    
   \              0x73 0x5C    
   \   00000038   0x78 0x64          DC8 78H, 64H, 6DH, 61H, 64H, 2EH, 63H, 0
   \              0x6D 0x61    
   \              0x64 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x2D 0x45          DC8 "-E- XDMAD_STATE_FREE \012\015"
   \              0x2D 0x20    
   \              0x58 0x44    
   \              0x4D 0x41    
   \              0x44 0x5F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x45 0x5F    
   \              0x46 0x52    
   \              0x45 0x45    
   \              0x20 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x2D 0x45          DC8 "-E- XDMAD_STATE_START \012\015"
   \              0x2D 0x20    
   \              0x58 0x44    
   \              0x4D 0x41    
   \              0x44 0x5F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x45 0x5F    
   \              0x53 0x54    
   \              0x41 0x52    
   \              0x54 0x20    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    500          
    501          /**@}*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   XDMAD_AllocateChannel
        24   -> XDMAD_AllocateXdmacChannel
      32   XDMAD_AllocateXdmacChannel
        32   -> XDMAIF_Get_ChannelNumber
        32   -> XDMAIF_IsValidatedPeripherOnDma
      40   XDMAD_ConfigureTransfer
        40   -> XDMAC_DisableChannelIt
        40   -> XDMAC_EnableChannelIt
        40   -> XDMAC_GetChannelIsr
        40   -> XDMAC_GetGIsr
        40   -> XDMAC_SetBlockControl
        40   -> XDMAC_SetChannelConfig
        40   -> XDMAC_SetDataStride_MemPattern
        40   -> XDMAC_SetDescriptorAddr
        40   -> XDMAC_SetDescriptorControl
        40   -> XDMAC_SetDestinationAddr
        40   -> XDMAC_SetDestinationMicroBlockStride
        40   -> XDMAC_SetMicroblockControl
        40   -> XDMAC_SetSourceAddr
        40   -> XDMAC_SetSourceMicroBlockStride
      24   XDMAD_FreeChannel
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      40   XDMAD_Handler
        40   -- Indirect call
        40   -> XDMAC_GetChannelIsr
        40   -> XDMAC_GetChannelItMask
        40   -> XDMAC_GetGIsr
        40   -> XDMAC_GetGlobalChStatus
        40   -> __aeabi_assert
        40   -> __iar_EmptyStepPoint
      24   XDMAD_Initialize
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   XDMAD_IsTransferDone
        24   -> XDMAD_Handler
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      32   XDMAD_PrepareChannel
        32   -> XDMAC_DisableChannel
        32   -> XDMAC_DisableChannelIt
        32   -> XDMAC_DisableGIt
        32   -> XDMAC_GetChannelIsr
        32   -> XDMAC_GetGIsr
        32   -> XDMAC_GetGlobalChStatus
        32   -> XDMAC_SetBlockControl
        32   -> XDMAC_SetChannelConfig
        32   -> XDMAC_SetDescriptorAddr
        32   -> XDMAC_SetDescriptorControl
        32   -> XDMAC_SetDestinationAddr
        32   -> XDMAC_SetSourceAddr
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
        32   -> pmc_enable_peripheral
        32   -> pmc_is_peripheral_enabled
      32   XDMAD_SetCallback
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
      24   XDMAD_StartTransfer
        24   -> XDMAC_EnableChannel
        24   -> XDMAC_EnableGIt
        24   -> printf
      24   XDMAD_StopTransfer
        24   -> XDMAC_DisableChannel
        24   -> XDMAC_DisableChannelIt
        24   -> XDMAC_GetChannelIsr
        24   -> XDMAC_GetGlobalChStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
      16  ?_0
      64  ?_1
      24  ?_2
      28  ?_3
     112  XDMAD_AllocateChannel
     564  XDMAD_AllocateXdmacChannel
     604  XDMAD_ConfigureTransfer
     168  XDMAD_FreeChannel
     420  XDMAD_Handler
     384  XDMAD_Initialize
     188  XDMAD_IsTransferDone
     432  XDMAD_PrepareChannel
     240  XDMAD_SetCallback
     248  XDMAD_StartTransfer
     144  XDMAD_StopTransfer
      56  _id_h64_matrix

 
   188 bytes in section .rodata
 3 520 bytes in section SOFTPACK
 
 3 520 bytes of CODE  memory
   188 bytes of CONST memory

Errors: none
Warnings: 1
