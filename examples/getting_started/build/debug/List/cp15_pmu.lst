###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\cp15_pmu.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\cp15_pmu.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\cp15_pmu.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\cp15_pmu.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\core\cp15_pmu.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \file */
     31          
     32          /*----------------------------------------------------------------------------
     33           *        Headers
     34           *----------------------------------------------------------------------------*/
     35          
     36          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     37          
     38          #if defined(__ICCARM__)
     39          #include <intrinsics.h>
     40          #endif
     41          
     42          #include "core/cp15_pmu.h"
     43          #include "core/l2cc.h"
     44          
     45          /*----------------------------------------------------------------------------
     46           *        Global functions
     47           *----------------------------------------------------------------------------*/
     48          
     49          /**
     50           * \brief Resets the counter and enables/disables all counters including PMCCNTR.
     51           * \param ResetCounterType  CounterType: Performance or Cycle counter
     52           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     53          static void cp15_pmu_control(uint8_t ResetCounterType, uint8_t EnableCounter)
     54          {
     55          	uint32_t PMU_Value = 0;
   \                     cp15_pmu_control:
   \   00000000   0xE3A02000         MOV      R2,#+0
     56          
     57          	asm("mrc     p15, 0, %0, c9, c12, 0":"=r"(PMU_Value));
   \   00000004   0xEE193F1C         mrc     p15, 0, R3, c9, c12, 0
   \   00000008   0xE1B02003         MOVS     R2,R3
     58          	PMU_Value |= ((ResetCounterType << 1) | EnableCounter);
   \   0000000C   0xE1B03000         MOVS     R3,R0
   \   00000010   0xE6EF3073         UXTB     R3,R3
   \   00000014   0xE1B0C001         MOVS     R12,R1
   \   00000018   0xE6EFC07C         UXTB     R12,R12
   \   0000001C   0xE19C3083         ORRS     R3,R12,R3, LSL #+1
   \   00000020   0xE1932002         ORRS     R2,R3,R2
     59              asm("mcr     p15, 0, %0, c9, c12, 0": :"r"(PMU_Value));
   \   00000024   0xEE092F1C         mcr     p15, 0, R2, c9, c12, 0
     60          }
   \   00000028   0xE12FFF1E         BX       LR               ;; return
     61          
     62          /**
     63           * \brief Select Cycle Count divider
     64           * \param Divider  0 for increment of counter at every single cycle or 1 for at every 64th cycle
     65           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     66          static void cp15_cycle_count_divider(uint8_t Divider)
     67          {
   \                     cp15_cycle_count_divider:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     68          	uint32_t PMU_Value = 0;
   \   00000008   0xE3A05000         MOV      R5,#+0
     69          	assert((Divider > 1 ? 0 : 1));
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0xE6EF0070         UXTB     R0,R0
   \   00000014   0xE3500002         CMP      R0,#+2
   \   00000018   0xBA000004         BLT      ??cp15_cycle_count_divider_0
   \   0000001C   0xE3A02045         MOV      R2,#+69
   \   00000020   0x........         LDR      R1,??DataTable1
   \   00000024   0x........         LDR      R0,??DataTable1_1
   \   00000028   0x........         BL       __aeabi_assert
   \   0000002C   0x........         BL       __iar_EmptyStepPoint
     70              asm("mrc     p15, 0, %0, c9, c12, 0":"=r"(PMU_Value));
   \                     ??cp15_cycle_count_divider_0:
   \   00000030   0xEE190F1C         mrc     p15, 0, R0, c9, c12, 0
   \   00000034   0xE1B05000         MOVS     R5,R0
     71          	PMU_Value |= (Divider << 3);
   \   00000038   0xE1B00004         MOVS     R0,R4
   \   0000003C   0xE6EF0070         UXTB     R0,R0
   \   00000040   0xE1955180         ORRS     R5,R5,R0, LSL #+3
     72              asm("mcr     p15, 0, %0, c9, c12, 0": :"r"(PMU_Value));
   \   00000044   0xEE095F1C         mcr     p15, 0, R5, c9, c12, 0
     73          }
   \   00000048   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
     74          
     75          /**
     76           * \brief Enables PMCCNTR.
     77           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     78          static void cp15_enable_PMCNT(void)
     79          {
     80          	uint32_t CNT_Value = 0;
   \                     cp15_enable_PMCNT:
   \   00000000   0xE3A00000         MOV      R0,#+0
     81              asm("mrc     p15, 0, %0, c9, c12, 1":"=r"(CNT_Value));
   \   00000004   0xEE191F3C         mrc     p15, 0, R1, c9, c12, 1
   \   00000008   0xE1B00001         MOVS     R0,R1
     82          	CNT_Value |= (uint32_t) ((1 << CP15_PMCNTENSET));
   \   0000000C   0xE3900480         ORRS     R0,R0,#0x80000000
     83              asm("mcr     p15, 0, %0, c9, c12, 1": :"r"(CNT_Value));
   \   00000010   0xEE090F3C         mcr     p15, 0, R0, c9, c12, 1
     84          }
   \   00000014   0xE12FFF1E         BX       LR               ;; return
     85          
     86          /**
     87           * \brief Enables PMCCNTR.
     88           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     89          static void cp15_enable_counter(uint8_t Counter)
     90          {
     91          	uint32_t CNT_Value = 0;
   \                     cp15_enable_counter:
   \   00000000   0xE3A01000         MOV      R1,#+0
     92              asm("mrc     p15, 0, %0, c9, c12, 1":"=r"(CNT_Value));
   \   00000004   0xEE192F3C         mrc     p15, 0, R2, c9, c12, 1
   \   00000008   0xE1B01002         MOVS     R1,R2
     93          	CNT_Value |= Counter;
   \   0000000C   0xE1B02000         MOVS     R2,R0
   \   00000010   0xE6EF2072         UXTB     R2,R2
   \   00000014   0xE1921001         ORRS     R1,R2,R1
     94              asm("mcr     p15, 0, %0, c9, c12, 1": :"r"(CNT_Value));
   \   00000018   0xEE091F3C         mcr     p15, 0, R1, c9, c12, 1
     95          }
   \   0000001C   0xE12FFF1E         BX       LR               ;; return
     96          
     97          /**
     98           * \brief Disables/clear PMCCNTR.
     99           * \param Counter  0 or 1 to selct counter
    100           */
    101          

   \                                 In section SOFTPACK, align 4, keep-with-next
    102          static void cp15_clear_PMCNT(void)
    103          {
    104          	uint32_t CNT_Value = 0;
   \                     cp15_clear_PMCNT:
   \   00000000   0xE3A00000         MOV      R0,#+0
    105              asm("mrc     p15, 0, %0, c9, c12, 2":"=r"(CNT_Value));
   \   00000004   0xEE191F5C         mrc     p15, 0, R1, c9, c12, 2
   \   00000008   0xE1B00001         MOVS     R0,R1
    106          	CNT_Value |= (uint32_t) (1 << CP15_PMCNTENCLEAR);
   \   0000000C   0xE3900480         ORRS     R0,R0,#0x80000000
    107              asm("mcr     p15, 0, %0, c9, c12, 2": :"r"(CNT_Value));
   \   00000010   0xEE090F5C         mcr     p15, 0, R0, c9, c12, 2
    108          }
   \   00000014   0xE12FFF1E         BX       LR               ;; return
    109          
    110          /**
    111           * \brief Disables/Enables overflow flag.
    112           * \param Enable  Enables or disables the flag option
    113           * \param ClearCounterFlag  selects the counter flag to clear
    114           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    115          void cp15_overflow_status(uint8_t Enable, uint8_t ClearCounterFlag)
    116          {
    117          	uint32_t OFW_Value = 0;
   \                     cp15_overflow_status:
   \   00000000   0xE3A02000         MOV      R2,#+0
    118              asm("mrc     p15, 0, %0, c9, c12, 3":"=r"(OFW_Value));
   \   00000004   0xEE193F7C         mrc     p15, 0, R3, c9, c12, 3
   \   00000008   0xE1B02003         MOVS     R2,R3
    119          	OFW_Value |= ((Enable << 31) | ClearCounterFlag);
   \   0000000C   0xE1B03000         MOVS     R3,R0
   \   00000010   0xE6EF3073         UXTB     R3,R3
   \   00000014   0xE1B0C001         MOVS     R12,R1
   \   00000018   0xE6EFC07C         UXTB     R12,R12
   \   0000001C   0xE19C3F83         ORRS     R3,R12,R3, LSL #+31
   \   00000020   0xE1932002         ORRS     R2,R3,R2
    120              asm("mcr     p15, 0, %0, c9, c12, 3": :"r"(OFW_Value));
   \   00000024   0xEE092F7C         mcr     p15, 0, R2, c9, c12, 3
    121          }
   \   00000028   0xE12FFF1E         BX       LR               ;; return
    122          
    123          /**
    124           * \brief Disables/Enables overflow flag.
    125           * \param EventCounter  Counter of the events
    126           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    127          uint32_t cp15_read_overflow_status(uint8_t EventCounter)
    128          {
   \                     cp15_read_overflow_status:
   \   00000000   0xE1B01000         MOVS     R1,R0
    129          	uint32_t OFW_Value = 0;
   \   00000004   0xE3A00000         MOV      R0,#+0
    130              asm("mrc     p15, 0, %0, c9, c12, 3":"=r"(OFW_Value));
   \   00000008   0xEE192F7C         mrc     p15, 0, R2, c9, c12, 3
   \   0000000C   0xE1B00002         MOVS     R0,R2
    131          	OFW_Value = ((OFW_Value & EventCounter) >> (EventCounter - 1));
   \   00000010   0xE1B02001         MOVS     R2,R1
   \   00000014   0xE6EF2072         UXTB     R2,R2
   \   00000018   0xE0120000         ANDS     R0,R2,R0
   \   0000001C   0xE2512001         SUBS     R2,R1,#+1
   \   00000020   0xE1B00230         LSRS     R0,R0,R2
    132          	return OFW_Value;
   \   00000024   0xE12FFF1E         BX       LR               ;; return
    133          }
    134          
    135          /**
    136           * \brief Increments the count of a performance monitor count register.
    137           * \param IncrCounter  0 or 1  counters
    138           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    139          void cp15_soft_incr(uint8_t IncrCounter)
    140          {
    141          	uint32_t INRC_Value = 0;
   \                     cp15_soft_incr:
   \   00000000   0xE3A01000         MOV      R1,#+0
    142              asm("mrc     p15, 0, %0, c9, c12, 4":"=r"(INRC_Value));
   \   00000004   0xEE192F9C         mrc     p15, 0, R2, c9, c12, 4
   \   00000008   0xE1B01002         MOVS     R1,R2
    143          	INRC_Value |= IncrCounter;
   \   0000000C   0xE1B02000         MOVS     R2,R0
   \   00000010   0xE6EF2072         UXTB     R2,R2
   \   00000014   0xE1921001         ORRS     R1,R2,R1
    144              asm("mcr     p15, 0, %0, c9, c12, 4": :"r"(INRC_Value));
   \   00000018   0xEE091F9C         mcr     p15, 0, R1, c9, c12, 4
    145          }
   \   0000001C   0xE12FFF1E         BX       LR               ;; return
    146          
    147          /**
    148           * \brief Increments the count of a performance monitor count register.
    149           * \param EventType  Select Event Type
    150           * \param Counter  0 or 1  counters
    151           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    152          static void cp15_select_event(PerfEventType EventType, uint8_t Counter)
    153          {
   \                     cp15_select_event:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B06000         MOVS     R6,R0
   \   00000008   0xE1B04001         MOVS     R4,R1
    154          	uint32_t CounterSelect = 0;
   \   0000000C   0xE3A05000         MOV      R5,#+0
    155          	assert((Counter == 1) || (Counter == 2));
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0xE6EF0070         UXTB     R0,R0
   \   00000018   0xE3500001         CMP      R0,#+1
   \   0000001C   0x0A000008         BEQ      ??cp15_select_event_0
   \   00000020   0xE1B00004         MOVS     R0,R4
   \   00000024   0xE6EF0070         UXTB     R0,R0
   \   00000028   0xE3500002         CMP      R0,#+2
   \   0000002C   0x0A000004         BEQ      ??cp15_select_event_0
   \   00000030   0xE3A0209B         MOV      R2,#+155
   \   00000034   0x........         LDR      R1,??DataTable1
   \   00000038   0x........         LDR      R0,??DataTable1_2
   \   0000003C   0x........         BL       __aeabi_assert
   \   00000040   0x........         BL       __iar_EmptyStepPoint
    156          	CounterSelect = (Counter & 0x1F);
   \                     ??cp15_select_event_0:
   \   00000044   0xE1B00004         MOVS     R0,R4
   \   00000048   0xE6EF0070         UXTB     R0,R0
   \   0000004C   0xE210001F         ANDS     R0,R0,#0x1F
   \   00000050   0xE1B05000         MOVS     R5,R0
    157              asm("mcr     p15, 0, %0, c9, c12, 5": :"r"(CounterSelect));
   \   00000054   0xEE095FBC         mcr     p15, 0, R5, c9, c12, 5
    158          	CounterSelect = (EventType & 0xFF);
   \   00000058   0xE1B00006         MOVS     R0,R6
   \   0000005C   0xE6EF0070         UXTB     R0,R0
   \   00000060   0xE1B05000         MOVS     R5,R0
    159              asm("mcr     p15, 0, %0, c9, c13, 1": :"r"(CounterSelect));
   \   00000064   0xEE095F3D         mcr     p15, 0, R5, c9, c13, 1
    160          	// PMXEVTYPER
    161              asm("mrc     p15, 0, %0, c9, c13, 1":"=r"(CounterSelect));
   \   00000068   0xEE190F3D         mrc     p15, 0, R0, c9, c13, 1
   \   0000006C   0xE1B05000         MOVS     R5,R0
    162          	// PMXEVTYPER
    163          }
   \   00000070   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    164          
    165          /**
    166           * \brief Enables USER mode
    167           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    168          void cp15_enable_user_mode(void)
    169          {
    170          	uint8_t Value = 1;
   \                     cp15_enable_user_mode:
   \   00000000   0xE3A00001         MOV      R0,#+1
    171              asm("mcr     p15, 0, %0, c9, c14, 0": :"r"(Value));
   \   00000004   0xEE090F1E         mcr     p15, 0, R0, c9, c14, 0
    172          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    173          
    174          /**
    175           * \brief Enables Oveflows interrupt
    176           * \param Enable  Enables the Interrupt
    177           * \param Counter  0 or 1  counters
    178           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    179          void cp15_enable_interrupt(uint8_t Enable, uint8_t Counter)
    180          {
    181          	uint32_t ITE_Value = 0;
   \                     cp15_enable_interrupt:
   \   00000000   0xE3A02000         MOV      R2,#+0
    182          	ITE_Value |= ((Enable << 31) | Counter);
   \   00000004   0xE1B03000         MOVS     R3,R0
   \   00000008   0xE6EF3073         UXTB     R3,R3
   \   0000000C   0xE1B0C001         MOVS     R12,R1
   \   00000010   0xE6EFC07C         UXTB     R12,R12
   \   00000014   0xE19C3F83         ORRS     R3,R12,R3, LSL #+31
   \   00000018   0xE1932002         ORRS     R2,R3,R2
    183              asm("mcr     p15, 0, %0, c9, c14, 1": :"r"(ITE_Value));
   \   0000001C   0xEE092F3E         mcr     p15, 0, R2, c9, c14, 1
    184          }
   \   00000020   0xE12FFF1E         BX       LR               ;; return
    185          
    186          /**
    187           * \brief Disables Oveflows interrupt
    188           * \param Disable  Disables the Interrupt
    189           * \param Counter  0 or 1  counters
    190           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    191          void cp15_disable_interrupt(uint8_t Disable, uint8_t Counter)
    192          {
    193          	uint32_t ITE_Value = 0;
   \                     cp15_disable_interrupt:
   \   00000000   0xE3A02000         MOV      R2,#+0
    194          	ITE_Value |= ((Disable << 31) | Counter);
   \   00000004   0xE1B03000         MOVS     R3,R0
   \   00000008   0xE6EF3073         UXTB     R3,R3
   \   0000000C   0xE1B0C001         MOVS     R12,R1
   \   00000010   0xE6EFC07C         UXTB     R12,R12
   \   00000014   0xE19C3F83         ORRS     R3,R12,R3, LSL #+31
   \   00000018   0xE1932002         ORRS     R2,R3,R2
    195              asm("mcr     p15, 0, %0, c9, c14, 2": :"r"(ITE_Value));
   \   0000001C   0xEE092F5E         mcr     p15, 0, R2, c9, c14, 2
    196          }
   \   00000020   0xE12FFF1E         BX       LR               ;; return
    197          
    198          /**
    199           * \brief Initialize Cycle counter with Divider 64
    200           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    201          uint32_t cp15_init_cycle_counter(void)
    202          {
   \                     cp15_init_cycle_counter:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
    203          	uint32_t value;
    204          	cp15_clear_PMCNT();
   \   00000004   0x........         BL       cp15_clear_PMCNT
    205          	cp15_enable_PMCNT();
   \   00000008   0x........         BL       cp15_enable_PMCNT
    206          	cp15_overflow_status(ENABLE, CP15_BothCounter);
   \   0000000C   0xE3A01003         MOV      R1,#+3
   \   00000010   0xE3A00001         MOV      R0,#+1
   \   00000014   0x........         BL       cp15_overflow_status
    207          	cp15_cycle_count_divider(CP15_CountDivider64);
   \   00000018   0xE3A00001         MOV      R0,#+1
   \   0000001C   0x........         BL       cp15_cycle_count_divider
    208          	cp15_pmu_control(CP15_ResetCycCounter, ENABLE);
   \   00000020   0xE3A01001         MOV      R1,#+1
   \   00000024   0xE3A00002         MOV      R0,#+2
   \   00000028   0x........         BL       cp15_pmu_control
    209          
    210              asm("mrc     p15, 0, %0, c9, c13, 0":"=r"(value));
   \   0000002C   0xEE190F1D         mrc     p15, 0, R0, c9, c13, 0
   \   00000030   0xE1B04000         MOVS     R4,R0
    211          	return value;
   \   00000034   0xE1B00004         MOVS     R0,R4
   \   00000038   0xE8BD8010         POP      {R4,PC}          ;; return
    212          
    213          }
    214          
    215          /**
    216           * \brief Initialize Performance monitor counter with Divider 64
    217           * \param Event  Event type
    218           * \param Counter  0 or 1  counters
    219           */
    220          

   \                                 In section SOFTPACK, align 4, keep-with-next
    221          void cp15_init_perf_counter(PerfEventType Event, uint8_t Counter)
    222          {
   \                     cp15_init_perf_counter:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    223          	cp15_pmu_control(CP15_ResetPerCounter, ENABLE);
   \   0000000C   0xE3A01001         MOV      R1,#+1
   \   00000010   0xE3A00001         MOV      R0,#+1
   \   00000014   0x........         BL       cp15_pmu_control
    224          	cp15_select_event(Event, Counter);
   \   00000018   0xE1B01005         MOVS     R1,R5
   \   0000001C   0xE6EF1071         UXTB     R1,R1
   \   00000020   0xE1B00004         MOVS     R0,R4
   \   00000024   0xE6EF0070         UXTB     R0,R0
   \   00000028   0x........         BL       cp15_select_event
    225          	cp15_overflow_status(DISABLE, CP15_BothCounter);
   \   0000002C   0xE3A01003         MOV      R1,#+3
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0x........         BL       cp15_overflow_status
    226          	cp15_enable_counter(Counter);
   \   00000038   0xE1B00005         MOVS     R0,R5
   \   0000003C   0xE6EF0070         UXTB     R0,R0
   \   00000040   0x........         BL       cp15_enable_counter
    227          }
   \   00000044   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    228          
    229          /**
    230           * \brief gives total number of event count
    231           * \param Counter  0 or 1  counters
    232           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    233          uint32_t cp15_count_evt(uint8_t Counter)
    234          {
   \                     cp15_count_evt:
   \   00000000   0xE1B01000         MOVS     R1,R0
    235          	uint32_t value;
    236              asm("mcr     p15, 0, %0, c9, c12, 5": :"r"(Counter));
   \   00000004   0xEE091FBC         mcr     p15, 0, R1, c9, c12, 5
    237              asm("mrc     p15, 0, %0, c9, c13, 2":"=r"(value));
   \   00000008   0xEE192F5D         mrc     p15, 0, R2, c9, c13, 2
   \   0000000C   0xE1B00002         MOVS     R0,R2
    238          	// PMXEVTYPER
    239          	return (value);
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    240          }
    241          
    242          /**
    243           * \brief gives total number of cycle count
    244          
    245           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    246          uint32_t cp15_get_cycle_counter(void)
    247          {
    248          	uint32_t value;
    249              asm("mrc     p15, 0, %0, c9, c13, 0":"=r"(value));
   \                     cp15_get_cycle_counter:
   \   00000000   0xEE191F1D         mrc     p15, 0, R1, c9, c13, 0
   \   00000004   0xE1B00001         MOVS     R0,R1
    250          	return value;
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    251          
    252          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x28 0x44          DC8 "(Divider > 1 ? 0 : 1)"
   \              0x69 0x76    
   \              0x69 0x64    
   \              0x65 0x72    
   \              0x20 0x3E    
   \              0x20 0x31    
   \              0x20 0x3F    
   \              0x20 0x30    
   \              0x20 0x3A    
   \              0x20 0x31    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 63H, 6FH, 72H, 65H
   \              0x73 0x5C    
   \              0x63 0x6F    
   \              0x72 0x65    
   \   00000038   0x5C 0x63          DC8 5CH, 63H, 70H, 31H, 35H, 5FH, 70H, 6DH
   \              0x70 0x31    
   \              0x35 0x5F    
   \              0x70 0x6D    
   \   00000040   0x75 0x2E          DC8 75H, 2EH, 63H, 0
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x28 0x43          DC8 "(Counter == 1) || (Counter == 2)"
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x31 0x29    
   \              0x20 0x7C    
   \              0x7C 0x20    
   \              0x28 0x43    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x32 0x29    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   cp15_clear_PMCNT
       0   cp15_count_evt
      16   cp15_cycle_count_divider
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   cp15_disable_interrupt
       0   cp15_enable_PMCNT
       0   cp15_enable_counter
       0   cp15_enable_interrupt
       0   cp15_enable_user_mode
       0   cp15_get_cycle_counter
       8   cp15_init_cycle_counter
         8   -> cp15_clear_PMCNT
         8   -> cp15_cycle_count_divider
         8   -> cp15_enable_PMCNT
         8   -> cp15_overflow_status
         8   -> cp15_pmu_control
      16   cp15_init_perf_counter
        16   -> cp15_enable_counter
        16   -> cp15_overflow_status
        16   -> cp15_pmu_control
        16   -> cp15_select_event
       0   cp15_overflow_status
       0   cp15_pmu_control
       0   cp15_read_overflow_status
      16   cp15_select_event
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   cp15_soft_incr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      24  ?_0
      68  ?_1
      36  ?_2
      56  _id_h64_matrix
      24  cp15_clear_PMCNT
      20  cp15_count_evt
      76  cp15_cycle_count_divider
      36  cp15_disable_interrupt
      24  cp15_enable_PMCNT
      32  cp15_enable_counter
      36  cp15_enable_interrupt
      12  cp15_enable_user_mode
      12  cp15_get_cycle_counter
      60  cp15_init_cycle_counter
      72  cp15_init_perf_counter
      44  cp15_overflow_status
      44  cp15_pmu_control
      40  cp15_read_overflow_status
     116  cp15_select_event
      32  cp15_soft_incr

 
 184 bytes in section .rodata
 692 bytes in section SOFTPACK
 
 692 bytes of CODE  memory
 184 bytes of CONST memory

Errors: none
Warnings: 1
