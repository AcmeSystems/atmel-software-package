###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\l2cc.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\l2cc.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\l2cc.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\l2cc.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\core\l2cc.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2011, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \file */
     31          
     32          /*----------------------------------------------------------------------------
     33           *        Headers
     34           *----------------------------------------------------------------------------*/
     35          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     36          #include "core/l2cc.h"
     37          #include "core/cp15.h"
     38          #include "utils/trace.h"
     39          #include <assert.h>
     40          
     41          /**
     42           * \brief Check if Level 2 cache is enable.
     43           * \param pL2CC Pointer to the L2CC peripheral.
     44           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     45          unsigned int
     46          L2CC_IsEnabled(L2cc * pL2CC)
     47          {
     48          	return ((pL2CC->L2CC_CR) & L2CC_CR_L2CEN);
   \                     L2CC_IsEnabled:
   \   00000000   0xE5900100         LDR      R0,[R0, #+256]
   \   00000004   0xE2100001         ANDS     R0,R0,#0x1
   \   00000008   0xE12FFF1E         BX       LR               ;; return
     49          }
     50          
     51          /**
     52           * \brief Enable Level 2 cache.
     53           * \param pL2CC Pointer to the L2CC peripheral.
     54           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     55          void
     56          L2CC_Enable(L2cc * pL2CC)
     57          {
   \                     L2CC_Enable:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     58          	pL2CC->L2CC_CR |= L2CC_CR_L2CEN;
   \   00000008   0xE5940100         LDR      R0,[R4, #+256]
   \   0000000C   0xE3900001         ORRS     R0,R0,#0x1
   \   00000010   0xE5840100         STR      R0,[R4, #+256]
     59          	TRACE_INFO("L2 cache is enabled");
   \   00000014   0x........         LDR      R0,??DataTable11
   \   00000018   0x........         BL       printf
     60          }
   \   0000001C   0xE8BD8010         POP      {R4,PC}          ;; return
     61          
     62          /**
     63           * \brief Disable Level 2 cache.
     64           * \param pL2CC Pointer to the L2CC peripheral.
     65           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     66          void
     67          L2CC_Disable(L2cc * pL2CC)
     68          {
   \                     L2CC_Disable:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     69          	pL2CC->L2CC_CR &= (!L2CC_CR_L2CEN);
   \   00000008   0xE5940100         LDR      R0,[R4, #+256]
   \   0000000C   0xE3A00000         MOV      R0,#+0
   \   00000010   0xE5840100         STR      R0,[R4, #+256]
     70          	TRACE_INFO("L2 cache is Disabled");
   \   00000014   0x........         LDR      R0,??DataTable11_1
   \   00000018   0x........         BL       printf
     71          }
   \   0000001C   0xE8BD8010         POP      {R4,PC}          ;; return
     72          
     73          /**
     74           * \brief Configures Level 2 cache as exclusive cache.
     75           * \param pL2CC Pointer to the L2CC peripheral.
     76           * \param Enable Enable/disable exclusive cache.
     77           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     78          void
     79          L2CC_ExclusiveCache(L2cc * pL2CC, uint8_t Enable)
     80          {
   \                     L2CC_ExclusiveCache:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
     81          	uint32_t Aux_Cfg;
     82          	if (L2CC_IsEnabled(pL2CC)) {
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       L2CC_IsEnabled
   \   00000014   0xE3500000         CMP      R0,#+0
   \   00000018   0x0A000001         BEQ      ??L2CC_ExclusiveCache_0
     83          		pL2CC->L2CC_CR = DISABLE;
   \   0000001C   0xE3A00000         MOV      R0,#+0
   \   00000020   0xE5840100         STR      R0,[R4, #+256]
     84          	}
     85          	Aux_Cfg = pL2CC->L2CC_ACR;
   \                     ??L2CC_ExclusiveCache_0:
   \   00000024   0xE5940104         LDR      R0,[R4, #+260]
   \   00000028   0xE1B06000         MOVS     R6,R0
     86          	if (Enable) {
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500000         CMP      R0,#+0
   \   00000038   0x0A000004         BEQ      ??L2CC_ExclusiveCache_1
     87          		cp15_exclusive_cache();
   \   0000003C   0x........         BL       cp15_exclusive_cache
     88          		Aux_Cfg |= L2CC_ACR_EXCC;
   \   00000040   0xE3966D40         ORRS     R6,R6,#0x1000
     89          		TRACE_INFO("L2 Exclusive mode Enabled\n\r");
   \   00000044   0x........         LDR      R0,??DataTable11_2
   \   00000048   0x........         BL       printf
   \   0000004C   0xEA000003         B        ??L2CC_ExclusiveCache_2
     90          	} else {
     91          		cp15_non_exclusive_cache();
   \                     ??L2CC_ExclusiveCache_1:
   \   00000050   0x........         BL       cp15_non_exclusive_cache
     92          		Aux_Cfg &= ~L2CC_ACR_EXCC;
   \   00000054   0xE3D66D40         BICS     R6,R6,#0x1000
     93          		TRACE_INFO("L2 Exclusive mode Disabled\n\r");
   \   00000058   0x........         LDR      R0,??DataTable11_3
   \   0000005C   0x........         BL       printf
     94          	}
     95          
     96          	pL2CC->L2CC_ACR |= Aux_Cfg;
   \                     ??L2CC_ExclusiveCache_2:
   \   00000060   0xE5940104         LDR      R0,[R4, #+260]
   \   00000064   0xE1960000         ORRS     R0,R6,R0
   \   00000068   0xE5840104         STR      R0,[R4, #+260]
     97          
     98          }
   \   0000006C   0xE8BD8070         POP      {R4-R6,PC}       ;; return
     99          
    100          /**
    101           * \brief Configures Level 2 cache RAM Latency (Tag and Data).
    102           * \param pL2CC Pointer to the L2CC peripheral.
    103           * \param pLat  Structure containing RAM Tag and Data latencies
    104           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    105          void
    106          L2CC_ConfigLatRAM(L2cc * pL2CC, RAMLatencyControl * pLat)
    107          {
   \                     L2CC_ConfigLatRAM:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    108          	if (L2CC_IsEnabled(pL2CC)) {
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       L2CC_IsEnabled
   \   00000014   0xE3500000         CMP      R0,#+0
   \   00000018   0x0A000001         BEQ      ??L2CC_ConfigLatRAM_0
    109          		pL2CC->L2CC_CR = DISABLE;
   \   0000001C   0xE3A00000         MOV      R0,#+0
   \   00000020   0xE5840100         STR      R0,[R4, #+256]
    110          	}
    111          
    112          	pL2CC->L2CC_TRCR =
    113          	    (L2CC_TRCR_TSETLAT(pLat->TagRAM.SetupLAT) |
    114          	     L2CC_TRCR_TRDLAT(pLat->TagRAM.ReadLAT) | L2CC_TRCR_TWRLAT(pLat->
    115          								       TagRAM.
    116          								       WriteLAT));
   \                     ??L2CC_ConfigLatRAM_0:
   \   00000024   0xE5D50000         LDRB     R0,[R5, #+0]
   \   00000028   0xE2100007         ANDS     R0,R0,#0x7
   \   0000002C   0xE5D51001         LDRB     R1,[R5, #+1]
   \   00000030   0xE3A02070         MOV      R2,#+112
   \   00000034   0xE0121201         ANDS     R1,R2,R1, LSL #+4
   \   00000038   0xE1910000         ORRS     R0,R1,R0
   \   0000003C   0xE5D51002         LDRB     R1,[R5, #+2]
   \   00000040   0xE3A02E70         MOV      R2,#+1792
   \   00000044   0xE0121401         ANDS     R1,R2,R1, LSL #+8
   \   00000048   0xE1910000         ORRS     R0,R1,R0
   \   0000004C   0xE5840108         STR      R0,[R4, #+264]
    117          	pL2CC->L2CC_DRCR =
    118          	    (L2CC_DRCR_DSETLAT(pLat->DataRAM.SetupLAT) |
    119          	     L2CC_DRCR_DRDLAT(pLat->DataRAM.ReadLAT) | L2CC_DRCR_DWRLAT(pLat->
    120          									DataRAM.
    121          									WriteLAT));
   \   00000050   0xE5D50003         LDRB     R0,[R5, #+3]
   \   00000054   0xE2100007         ANDS     R0,R0,#0x7
   \   00000058   0xE5D51004         LDRB     R1,[R5, #+4]
   \   0000005C   0xE3A02070         MOV      R2,#+112
   \   00000060   0xE0121201         ANDS     R1,R2,R1, LSL #+4
   \   00000064   0xE1910000         ORRS     R0,R1,R0
   \   00000068   0xE5D51005         LDRB     R1,[R5, #+5]
   \   0000006C   0xE3A02E70         MOV      R2,#+1792
   \   00000070   0xE0121401         ANDS     R1,R2,R1, LSL #+8
   \   00000074   0xE1910000         ORRS     R0,R1,R0
   \   00000078   0xE584010C         STR      R0,[R4, #+268]
    122          
    123          }
   \   0000007C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    124          
    125          /**
    126           * \brief Configures Level 2 cache.
    127           * \param pL2CC Pointer to the L2CC peripheral.
    128           * \param L2cc_Config  Configuration values to put in Auxiliary, prefetch, debug and powercontrol registers
    129           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    130          void
    131          L2CC_Config(L2cc * pL2CC, L2CC_Control L2cc_Config)
    132          {
   \                     L2CC_Config:
   \   00000000   0xE92D000E         PUSH     {R1-R3}
   \   00000004   0xE92D41F8         PUSH     {R3-R8,LR}
   \   00000008   0xE1B04000         MOVS     R4,R0
    133          	uint32_t AuxiliaryControl, DebugControl, PrefetchControl, PowerControl;
    134          
    135          	if (L2cc_Config.OFFSET_Val > 31) {
   \   0000000C   0xE59D004C         LDR      R0,[SP, #+76]
   \   00000010   0xE3500020         CMP      R0,#+32
   \   00000014   0x3A000004         BCC      ??L2CC_Config_0
    136          		assert(0);
   \   00000018   0xE3A02088         MOV      R2,#+136
   \   0000001C   0x........         LDR      R1,??DataTable11_4
   \   00000020   0x........         ADR      R0,??DataTable6  ;; "0"
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    137          	}
    138          	if ((L2cc_Config.OFFSET_Val > 7) && (L2cc_Config.OFFSET_Val < 15)) {
   \                     ??L2CC_Config_0:
   \   0000002C   0xE59D004C         LDR      R0,[SP, #+76]
   \   00000030   0xE3500008         CMP      R0,#+8
   \   00000034   0x3A000007         BCC      ??L2CC_Config_1
   \   00000038   0xE59D004C         LDR      R0,[SP, #+76]
   \   0000003C   0xE350000F         CMP      R0,#+15
   \   00000040   0x2A000004         BCS      ??L2CC_Config_1
    139          		assert(0);
   \   00000044   0xE3A0208B         MOV      R2,#+139
   \   00000048   0x........         LDR      R1,??DataTable11_4
   \   0000004C   0x........         ADR      R0,??DataTable6  ;; "0"
   \   00000050   0x........         BL       __aeabi_assert
   \   00000054   0x........         BL       __iar_EmptyStepPoint
    140          	}
    141          	if ((L2cc_Config.OFFSET_Val > 15) && (L2cc_Config.OFFSET_Val < 23)) {
   \                     ??L2CC_Config_1:
   \   00000058   0xE59D004C         LDR      R0,[SP, #+76]
   \   0000005C   0xE3500010         CMP      R0,#+16
   \   00000060   0x3A000007         BCC      ??L2CC_Config_2
   \   00000064   0xE59D004C         LDR      R0,[SP, #+76]
   \   00000068   0xE3500017         CMP      R0,#+23
   \   0000006C   0x2A000004         BCS      ??L2CC_Config_2
    142          		assert(0);
   \   00000070   0xE3A0208E         MOV      R2,#+142
   \   00000074   0x........         LDR      R1,??DataTable11_4
   \   00000078   0x........         ADR      R0,??DataTable6  ;; "0"
   \   0000007C   0x........         BL       __aeabi_assert
   \   00000080   0x........         BL       __iar_EmptyStepPoint
    143          	}
    144          	if ((L2cc_Config.OFFSET_Val > 23) && (L2cc_Config.OFFSET_Val < 31)) {
   \                     ??L2CC_Config_2:
   \   00000084   0xE59D004C         LDR      R0,[SP, #+76]
   \   00000088   0xE3500018         CMP      R0,#+24
   \   0000008C   0x3A000007         BCC      ??L2CC_Config_3
   \   00000090   0xE59D004C         LDR      R0,[SP, #+76]
   \   00000094   0xE350001F         CMP      R0,#+31
   \   00000098   0x2A000004         BCS      ??L2CC_Config_3
    145          		assert(0);
   \   0000009C   0xE3A02091         MOV      R2,#+145
   \   000000A0   0x........         LDR      R1,??DataTable11_4
   \   000000A4   0x........         ADR      R0,??DataTable6  ;; "0"
   \   000000A8   0x........         BL       __aeabi_assert
   \   000000AC   0x........         BL       __iar_EmptyStepPoint
    146          	}
    147          //  if( ((L2cc_Config.IDLEN_Val==1) || (L2cc_Config.DLFWRDIS_Val==0)) && L2cc_Config.DLEN_Val==0)
    148          //  {
    149          //    TRACE_ERROR(" DLEN is not enabled for Double Line fill");
    150          //    assert(0);
    151          //  }
    152          
    153          	if (L2CC_IsEnabled(pL2CC)) {
   \                     ??L2CC_Config_3:
   \   000000B0   0xE1B00004         MOVS     R0,R4
   \   000000B4   0x........         BL       L2CC_IsEnabled
   \   000000B8   0xE3500000         CMP      R0,#+0
   \   000000BC   0x0A000001         BEQ      ??L2CC_Config_4
    154          		pL2CC->L2CC_CR = DISABLE;
   \   000000C0   0xE3A00000         MOV      R0,#+0
   \   000000C4   0xE5840100         STR      R0,[R4, #+256]
    155          	}
    156          
    157          	AuxiliaryControl = ((L2cc_Config.HPSO_Val << 10) |
    158          			    (L2cc_Config.SBDLE_Val << 11) |
    159          			    (L2cc_Config.SAIE_Val << 13) |
    160          			    (L2cc_Config.EMBEN_Val << 20) |
    161          			    (L2cc_Config.PEN_Val << 21) |
    162          			    (L2cc_Config.SAOEN_Val << 22) |
    163          			    (L2CC_ACR_FWA(L2cc_Config.FWA_Val)) |
    164          			    (L2cc_Config.CRPOL_Val << 25) |
    165          			    (L2cc_Config.NSLEN_Val << 26) |
    166          			    (L2cc_Config.NSIAC_Val << 27) |
    167          			    (L2cc_Config.DPEN_Val << 28) |
    168          			    (L2cc_Config.IPEN_Val << 29));
   \                     ??L2CC_Config_4:
   \   000000C8   0xE59D001C         LDR      R0,[SP, #+28]
   \   000000CC   0xE59D1020         LDR      R1,[SP, #+32]
   \   000000D0   0xE1B01581         LSLS     R1,R1,#+11
   \   000000D4   0xE1910500         ORRS     R0,R1,R0, LSL #+10
   \   000000D8   0xE59D1024         LDR      R1,[SP, #+36]
   \   000000DC   0xE1900681         ORRS     R0,R0,R1, LSL #+13
   \   000000E0   0xE59D1028         LDR      R1,[SP, #+40]
   \   000000E4   0xE1900A01         ORRS     R0,R0,R1, LSL #+20
   \   000000E8   0xE59D102C         LDR      R1,[SP, #+44]
   \   000000EC   0xE1900A81         ORRS     R0,R0,R1, LSL #+21
   \   000000F0   0xE59D1030         LDR      R1,[SP, #+48]
   \   000000F4   0xE1900B01         ORRS     R0,R0,R1, LSL #+22
   \   000000F8   0xE59D1034         LDR      R1,[SP, #+52]
   \   000000FC   0xE3A02760         MOV      R2,#+25165824
   \   00000100   0xE0121B81         ANDS     R1,R2,R1, LSL #+23
   \   00000104   0xE1910000         ORRS     R0,R1,R0
   \   00000108   0xE59D1038         LDR      R1,[SP, #+56]
   \   0000010C   0xE1900C81         ORRS     R0,R0,R1, LSL #+25
   \   00000110   0xE59D103C         LDR      R1,[SP, #+60]
   \   00000114   0xE1900D01         ORRS     R0,R0,R1, LSL #+26
   \   00000118   0xE59D1040         LDR      R1,[SP, #+64]
   \   0000011C   0xE1900D81         ORRS     R0,R0,R1, LSL #+27
   \   00000120   0xE59D1044         LDR      R1,[SP, #+68]
   \   00000124   0xE1900E01         ORRS     R0,R0,R1, LSL #+28
   \   00000128   0xE59D1048         LDR      R1,[SP, #+72]
   \   0000012C   0xE1900E81         ORRS     R0,R0,R1, LSL #+29
   \   00000130   0xE1B05000         MOVS     R5,R0
    169          
    170          	DebugControl = ((L2cc_Config.DCL_Val << 0) |
    171          			(L2cc_Config.DWB_Val << 1));
   \   00000134   0xE59D006C         LDR      R0,[SP, #+108]
   \   00000138   0xE59D1070         LDR      R1,[SP, #+112]
   \   0000013C   0xE1900081         ORRS     R0,R0,R1, LSL #+1
   \   00000140   0xE1B06000         MOVS     R6,R0
    172          
    173          	PrefetchControl = ((L2cc_Config.OFFSET_Val << 0) |
    174          			   (L2cc_Config.NSIDEN_Val << 21) |
    175          			   (L2cc_Config.IDLEN_Val << 23) |
    176          			   (L2cc_Config.PDEN_Val << 24) |
    177          			   (L2cc_Config.DLFWRDIS_Val << 27) |
    178          			   (L2cc_Config.DPEN_Val << 28) |
    179          			   (L2cc_Config.IPEN_Val << 29) |
    180          			   (L2cc_Config.DLEN_Val << 30));
   \   00000144   0xE59D004C         LDR      R0,[SP, #+76]
   \   00000148   0xE59D1050         LDR      R1,[SP, #+80]
   \   0000014C   0xE1900A81         ORRS     R0,R0,R1, LSL #+21
   \   00000150   0xE59D1054         LDR      R1,[SP, #+84]
   \   00000154   0xE1900B81         ORRS     R0,R0,R1, LSL #+23
   \   00000158   0xE59D1058         LDR      R1,[SP, #+88]
   \   0000015C   0xE1900C01         ORRS     R0,R0,R1, LSL #+24
   \   00000160   0xE59D105C         LDR      R1,[SP, #+92]
   \   00000164   0xE1900D81         ORRS     R0,R0,R1, LSL #+27
   \   00000168   0xE59D1044         LDR      R1,[SP, #+68]
   \   0000016C   0xE1900E01         ORRS     R0,R0,R1, LSL #+28
   \   00000170   0xE59D1048         LDR      R1,[SP, #+72]
   \   00000174   0xE1900E81         ORRS     R0,R0,R1, LSL #+29
   \   00000178   0xE59D1060         LDR      R1,[SP, #+96]
   \   0000017C   0xE1900F01         ORRS     R0,R0,R1, LSL #+30
   \   00000180   0xE1B07000         MOVS     R7,R0
    181          
    182          	PowerControl = ((L2cc_Config.DCL_Val << 0) |
    183          			(L2cc_Config.DWB_Val << 1));
   \   00000184   0xE59D006C         LDR      R0,[SP, #+108]
   \   00000188   0xE59D1070         LDR      R1,[SP, #+112]
   \   0000018C   0xE1900081         ORRS     R0,R0,R1, LSL #+1
   \   00000190   0xE1B08000         MOVS     R8,R0
    184          
    185          	pL2CC->L2CC_ACR = AuxiliaryControl;
   \   00000194   0xE5845104         STR      R5,[R4, #+260]
    186          
    187          	pL2CC->L2CC_DCR = DebugControl;
   \   00000198   0xE5846F40         STR      R6,[R4, #+3904]
    188          
    189          	pL2CC->L2CC_PCR = PrefetchControl;
   \   0000019C   0xE5847F60         STR      R7,[R4, #+3936]
    190          
    191          	pL2CC->L2CC_POWCR = PowerControl;
   \   000001A0   0xE5848F80         STR      R8,[R4, #+3968]
    192          
    193          }
   \   000001A4   0xE8BD01F1         POP      {R0,R4-R8}
   \   000001A8   0xE49DF010         LDR      PC,[SP], #+16    ;; return
    194          
    195          /**
    196           * \brief Enables Data prefetch on L2
    197           * \param pL2CC Pointer to the L2CC peripheral.
    198           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    199          void
    200          L2CC_DataPrefetchEnable(L2cc * pL2CC)
    201          {
    202          
    203          	pL2CC->L2CC_PCR |= L2CC_PCR_DATPEN;
   \                     L2CC_DataPrefetchEnable:
   \   00000000   0xE5901F60         LDR      R1,[R0, #+3936]
   \   00000004   0xE3911540         ORRS     R1,R1,#0x10000000
   \   00000008   0xE5801F60         STR      R1,[R0, #+3936]
    204          
    205          }
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    206          
    207          /**
    208           * \brief Enables instruction prefetch on L2
    209           * \param pL2CC Pointer to the L2CC peripheral.
    210           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    211          void
    212          L2CC_InstPrefetchEnable(L2cc * pL2CC)
    213          {
    214          
    215          	pL2CC->L2CC_PCR |= L2CC_PCR_INSPEN;
   \                     L2CC_InstPrefetchEnable:
   \   00000000   0xE5901F60         LDR      R1,[R0, #+3936]
   \   00000004   0xE3911580         ORRS     R1,R1,#0x20000000
   \   00000008   0xE5801F60         STR      R1,[R0, #+3936]
    216          
    217          }
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    218          
    219          /**
    220           * \brief Enables instruction prefetch on L2
    221           * \param pL2CC Pointer to the L2CC peripheral.
    222           * \param EventCounter Counter of the events.
    223           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    224          void
    225          L2CC_EnableResetCounter(L2cc * pL2CC, uint8_t EventCounter)
    226          {
   \                     L2CC_EnableResetCounter:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    227          
    228          	assert((EventCounter > 3) ? 0 : 1);
   \   0000000C   0xE1B00005         MOVS     R0,R5
   \   00000010   0xE6EF0070         UXTB     R0,R0
   \   00000014   0xE3500004         CMP      R0,#+4
   \   00000018   0xBA000004         BLT      ??L2CC_EnableResetCounter_0
   \   0000001C   0xE3A020E4         MOV      R2,#+228
   \   00000020   0x........         LDR      R1,??DataTable11_4
   \   00000024   0x........         LDR      R0,??DataTable11_5
   \   00000028   0x........         BL       __aeabi_assert
   \   0000002C   0x........         BL       __iar_EmptyStepPoint
    229          
    230          	pL2CC->L2CC_ECR = (L2CC_ECR_EVCEN | (EventCounter << 1));
   \                     ??L2CC_EnableResetCounter_0:
   \   00000030   0xE1B00005         MOVS     R0,R5
   \   00000034   0xE6EF0070         UXTB     R0,R0
   \   00000038   0xE3A01001         MOV      R1,#+1
   \   0000003C   0xE1910080         ORRS     R0,R1,R0, LSL #+1
   \   00000040   0xE5840200         STR      R0,[R4, #+512]
    231          
    232          }
   \   00000044   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    233          
    234          /**
    235           * \brief Configures Event of Level 2 cache.
    236           * \param pL2CC Pointer to the L2CC peripheral.
    237           * \param EventCounter  Eventcounter 1 or 0
    238           * \param Source  Event Genration source
    239           * \param IntGen  Event Counter Interrupt Generation condition
    240           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    241          void
    242          L2CC_EventConfig(L2cc * pL2CC, uint8_t EventCounter, uint8_t Source,
    243          		 uint8_t IntGen)
    244          {
   \                     L2CC_EventConfig:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    245          	if (L2CC_IsEnabled(pL2CC)) {
   \   00000014   0xE1B00004         MOVS     R0,R4
   \   00000018   0x........         BL       L2CC_IsEnabled
   \   0000001C   0xE3500000         CMP      R0,#+0
   \   00000020   0x0A000001         BEQ      ??L2CC_EventConfig_0
    246          		pL2CC->L2CC_CR = DISABLE;
   \   00000024   0xE3A00000         MOV      R0,#+0
   \   00000028   0xE5840100         STR      R0,[R4, #+256]
    247          	}
    248          
    249          	assert((EventCounter > 1) ? 0 : 1);
   \                     ??L2CC_EventConfig_0:
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE6EF0070         UXTB     R0,R0
   \   00000034   0xE3500002         CMP      R0,#+2
   \   00000038   0xBA000004         BLT      ??L2CC_EventConfig_1
   \   0000003C   0xE3A020F9         MOV      R2,#+249
   \   00000040   0x........         LDR      R1,??DataTable11_4
   \   00000044   0x........         LDR      R0,??DataTable11_6
   \   00000048   0x........         BL       __aeabi_assert
   \   0000004C   0x........         BL       __iar_EmptyStepPoint
    250          
    251          	if (!EventCounter) {
   \                     ??L2CC_EventConfig_1:
   \   00000050   0xE1B00005         MOVS     R0,R5
   \   00000054   0xE6EF0070         UXTB     R0,R0
   \   00000058   0xE3500000         CMP      R0,#+0
   \   0000005C   0x1A000006         BNE      ??L2CC_EventConfig_2
    252          		pL2CC->L2CC_ECFGR0 = (Source | IntGen);
   \   00000060   0xE1B00006         MOVS     R0,R6
   \   00000064   0xE6EF0070         UXTB     R0,R0
   \   00000068   0xE1B01007         MOVS     R1,R7
   \   0000006C   0xE6EF1071         UXTB     R1,R1
   \   00000070   0xE1910000         ORRS     R0,R1,R0
   \   00000074   0xE5840208         STR      R0,[R4, #+520]
   \   00000078   0xEA000005         B        ??L2CC_EventConfig_3
    253          	} else {
    254          		pL2CC->L2CC_ECFGR1 = (Source | IntGen);
   \                     ??L2CC_EventConfig_2:
   \   0000007C   0xE1B00006         MOVS     R0,R6
   \   00000080   0xE6EF0070         UXTB     R0,R0
   \   00000084   0xE1B01007         MOVS     R1,R7
   \   00000088   0xE6EF1071         UXTB     R1,R1
   \   0000008C   0xE1910000         ORRS     R0,R1,R0
   \   00000090   0xE5840204         STR      R0,[R4, #+516]
    255          	}
    256          
    257          }
   \                     ??L2CC_EventConfig_3:
   \   00000094   0xE8BD80F1         POP      {R0,R4-R7,PC}    ;; return
    258          
    259          /**
    260           * \brief Reads Eventcounter value.
    261           * \param pL2CC Pointer to the L2CC peripheral.
    262           * \param EventCounter  choose Eventcounter 1 or 0
    263           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    264          unsigned int
    265          L2CC_EventCounterValue(L2cc * pL2CC, uint8_t EventCounter)
    266          {
   \                     L2CC_EventCounterValue:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    267          
    268          	assert((EventCounter > 1) ? 0 : 1);
   \   0000000C   0xE1B00005         MOVS     R0,R5
   \   00000010   0xE6EF0070         UXTB     R0,R0
   \   00000014   0xE3500002         CMP      R0,#+2
   \   00000018   0xBA000004         BLT      ??L2CC_EventCounterValue_0
   \   0000001C   0xE3A02F43         MOV      R2,#+268
   \   00000020   0x........         LDR      R1,??DataTable11_4
   \   00000024   0x........         LDR      R0,??DataTable11_6
   \   00000028   0x........         BL       __aeabi_assert
   \   0000002C   0x........         BL       __iar_EmptyStepPoint
    269          
    270          	if (!EventCounter) {
   \                     ??L2CC_EventCounterValue_0:
   \   00000030   0xE1B00005         MOVS     R0,R5
   \   00000034   0xE6EF0070         UXTB     R0,R0
   \   00000038   0xE3500000         CMP      R0,#+0
   \   0000003C   0x1A000001         BNE      ??L2CC_EventCounterValue_1
    271          		return pL2CC->L2CC_EVR0;
   \   00000040   0xE5940210         LDR      R0,[R4, #+528]
   \   00000044   0xEA000000         B        ??L2CC_EventCounterValue_2
    272          	} else {
    273          		return pL2CC->L2CC_EVR1;
   \                     ??L2CC_EventCounterValue_1:
   \   00000048   0xE594020C         LDR      R0,[R4, #+524]
   \                     ??L2CC_EventCounterValue_2:
   \   0000004C   0xE8BD8032         POP      {R1,R4,R5,PC}    ;; return
    274          	}
    275          
    276          }
    277          
    278          /**
    279           * \brief Enable interrupts
    280           * \param pL2CC Pointer to the L2CC peripheral.
    281           * \param ITSource  Interrupt source
    282           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    283          void
    284          L2CC_EnableIT(L2cc * pL2CC, uint16_t ITSource)
    285          {
    286          	pL2CC->L2CC_IMR |= ITSource;
   \                     L2CC_EnableIT:
   \   00000000   0xE5902214         LDR      R2,[R0, #+532]
   \   00000004   0xE1B03001         MOVS     R3,R1
   \   00000008   0xE6FF3073         UXTH     R3,R3
   \   0000000C   0xE1932002         ORRS     R2,R3,R2
   \   00000010   0xE5802214         STR      R2,[R0, #+532]
    287          }
   \   00000014   0xE12FFF1E         BX       LR               ;; return
    288          
    289          /**
    290           * \brief Disable interrupts
    291           * \param pL2CC Pointer to the L2CC peripheral.
    292           * \param ITSource  Interrupt source
    293           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    294          void
    295          L2CC_DisableIT(L2cc * pL2CC, uint16_t ITSource)
    296          {
    297          	pL2CC->L2CC_IMR &= (!ITSource);
   \                     L2CC_DisableIT:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6FF2072         UXTH     R2,R2
   \   00000008   0xE3520000         CMP      R2,#+0
   \   0000000C   0x1A000001         BNE      ??L2CC_DisableIT_0
   \   00000010   0xE3A02001         MOV      R2,#+1
   \   00000014   0xEA000000         B        ??L2CC_DisableIT_1
   \                     ??L2CC_DisableIT_0:
   \   00000018   0xE3A02000         MOV      R2,#+0
   \                     ??L2CC_DisableIT_1:
   \   0000001C   0xE5903214         LDR      R3,[R0, #+532]
   \   00000020   0xE6EF2072         UXTB     R2,R2
   \   00000024   0xE0122003         ANDS     R2,R2,R3
   \   00000028   0xE5802214         STR      R2,[R0, #+532]
    298          }
   \   0000002C   0xE12FFF1E         BX       LR               ;; return
    299          
    300          /**
    301           * \brief Enabled interrupt's raw status
    302           * \param pL2CC Pointer to the L2CC peripheral.
    303           * \param ITSource  Interrupt source
    304           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    305          unsigned short
    306          L2CC_ITStatusRaw(L2cc * pL2CC, uint16_t ITSource)
    307          {
    308          	return ((pL2CC->L2CC_RISR) & ITSource) ? 1 : 0;
   \                     L2CC_ITStatusRaw:
   \   00000000   0xE590021C         LDR      R0,[R0, #+540]
   \   00000004   0xE6FF1071         UXTH     R1,R1
   \   00000008   0xE1110000         TST      R1,R0
   \   0000000C   0x0A000001         BEQ      ??L2CC_ITStatusRaw_0
   \   00000010   0xE3A00001         MOV      R0,#+1
   \   00000014   0xEA000000         B        ??L2CC_ITStatusRaw_1
   \                     ??L2CC_ITStatusRaw_0:
   \   00000018   0xE3A00000         MOV      R0,#+0
   \                     ??L2CC_ITStatusRaw_1:
   \   0000001C   0xE6FF0070         UXTH     R0,R0
   \   00000020   0xE12FFF1E         BX       LR               ;; return
    309          }
    310          
    311          /**
    312           * \brief Status of masked interrupts
    313           * \param pL2CC Pointer to the L2CC peripheral.
    314           * \param ITSource  Interrupt source
    315           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    316          unsigned short
    317          L2CC_ITStatusMask(L2cc * pL2CC, uint16_t ITSource)
    318          {
    319          	return ((pL2CC->L2CC_MISR) & ITSource) ? 1 : 0;
   \                     L2CC_ITStatusMask:
   \   00000000   0xE5900218         LDR      R0,[R0, #+536]
   \   00000004   0xE6FF1071         UXTH     R1,R1
   \   00000008   0xE1110000         TST      R1,R0
   \   0000000C   0x0A000001         BEQ      ??L2CC_ITStatusMask_0
   \   00000010   0xE3A00001         MOV      R0,#+1
   \   00000014   0xEA000000         B        ??L2CC_ITStatusMask_1
   \                     ??L2CC_ITStatusMask_0:
   \   00000018   0xE3A00000         MOV      R0,#+0
   \                     ??L2CC_ITStatusMask_1:
   \   0000001C   0xE6FF0070         UXTH     R0,R0
   \   00000020   0xE12FFF1E         BX       LR               ;; return
    320          }
    321          
    322          /**
    323           * \brief Clear interrupts
    324           * \param pL2CC Pointer to the L2CC peripheral.
    325           * \param ITSource  Interrupt source
    326           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    327          void
    328          L2CC_ITClear(L2cc * pL2CC, uint16_t ITSource)
    329          {
    330          	pL2CC->L2CC_ICR |= ITSource;
   \                     L2CC_ITClear:
   \   00000000   0xE5902220         LDR      R2,[R0, #+544]
   \   00000004   0xE1B03001         MOVS     R3,R1
   \   00000008   0xE6FF3073         UXTH     R3,R3
   \   0000000C   0xE1932002         ORRS     R2,R3,R2
   \   00000010   0xE5802220         STR      R2,[R0, #+544]
    331          }
   \   00000014   0xE12FFF1E         BX       LR               ;; return
    332          
    333          /**
    334           * \brief Poll SPNIDEN signal
    335           * \param pL2CC Pointer to the L2CC peripheral.
    336           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    337          uint8_t
    338          L2CC_PollSPNIDEN(L2cc * pL2CC)
    339          {
    340          	return ((pL2CC->L2CC_DCR & L2CC_DCR_SPNIDEN) >> 2);
   \                     L2CC_PollSPNIDEN:
   \   00000000   0xE5900F40         LDR      R0,[R0, #+3904]
   \   00000004   0xE7E00150         UBFX     R0,R0,#+2,#+1
   \   00000008   0xE6EF0070         UXTB     R0,R0
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    341          }
    342          
    343          /**
    344           * \brief Synchronizes the L2 cache
    345           * \param pL2CC Pointer to the L2CC peripheral.
    346           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    347          void
    348          L2CC_CacheSync(L2cc * pL2CC)
    349          {
    350          	while ((pL2CC->L2CC_CSR) & L2CC_CSR_C) ;
   \                     L2CC_CacheSync:
   \                     ??L2CC_CacheSync_0:
   \   00000000   0xE5901730         LDR      R1,[R0, #+1840]
   \   00000004   0xE3110001         TST      R1,#0x1
   \   00000008   0x1AFFFFFC         BNE      ??L2CC_CacheSync_0
    351          	pL2CC->L2CC_CSR = L2CC_CSR_C;
   \   0000000C   0xE3A01001         MOV      R1,#+1
   \   00000010   0xE5801730         STR      R1,[R0, #+1840]
    352          	while ((pL2CC->L2CC_CSR) & L2CC_CSR_C) ;
   \                     ??L2CC_CacheSync_1:
   \   00000014   0xE5901730         LDR      R1,[R0, #+1840]
   \   00000018   0xE3110001         TST      R1,#0x1
   \   0000001C   0x1AFFFFFC         BNE      ??L2CC_CacheSync_1
    353          }
   \   00000020   0xE12FFF1E         BX       LR               ;; return
    354          
    355          /**
    356           * \brief Invalidate cache by Physical addersse
    357           * \param pL2CC Pointer to the L2CC peripheral.
    358           * \param P_Address  Physical addresse
    359           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    360          void
    361          L2CC_InvalidatePAL(L2cc * pL2CC, uint32_t P_Address)
    362          {
    363          	static uint32_t Tag;
    364          	static uint16_t Index;
    365          	Tag = (P_Address >> (OFFSET_BIT + INDEX_BIT));
   \                     L2CC_InvalidatePAL:
   \   00000000   0xE1B02721         LSRS     R2,R1,#+14
   \   00000004   0x........         LDR      R3,??DataTable11_7
   \   00000008   0xE5832000         STR      R2,[R3, #+0]
    366          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
   \   0000000C   0xE7E822D1         UBFX     R2,R1,#+5,#+9
   \   00000010   0x........         LDR      R3,??DataTable11_8
   \   00000014   0xE1C320B0         STRH     R2,[R3, #+0]
    367          
    368          	pL2CC->L2CC_IPALR =
    369          	    (L2CC_IPALR_TAG(Tag) | L2CC_IPALR_IDX(Index) | L2CC_IPALR_C);
   \   00000018   0x........         LDR      R2,??DataTable11_7
   \   0000001C   0xE5922000         LDR      R2,[R2, #+0]
   \   00000020   0x........         LDR      R3,??DataTable11_8
   \   00000024   0xE1D330B0         LDRH     R3,[R3, #+0]
   \   00000028   0xE303CFE0         MOVW     R12,#+16352
   \   0000002C   0xE01C3283         ANDS     R3,R12,R3, LSL #+5
   \   00000030   0xE1932702         ORRS     R2,R3,R2, LSL #+14
   \   00000034   0xE3922001         ORRS     R2,R2,#0x1
   \   00000038   0xE5802770         STR      R2,[R0, #+1904]
    370          
    371          	while ((pL2CC->L2CC_IPALR) & L2CC_IPALR_C) ;
   \                     ??L2CC_InvalidatePAL_0:
   \   0000003C   0xE5902770         LDR      R2,[R0, #+1904]
   \   00000040   0xE3120001         TST      R2,#0x1
   \   00000044   0x1AFFFFFC         BNE      ??L2CC_InvalidatePAL_0
    372          }
   \   00000048   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .bss, align 4
   \                     ??Tag:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
   \                     ??Index:
   \   00000000                      DS8 2
    373          
    374          /**
    375           * \brief Clean cache by Physical addersse
    376           * \param pL2CC Pointer to the L2CC peripheral.
    377           * \param P_Address  Physical addresse
    378           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    379          void
    380          L2CC_CleanPAL(L2cc * pL2CC, uint32_t P_Address)
    381          {
    382          	static uint32_t Tag;
    383          	static uint16_t Index;
    384          	Tag = (P_Address >> (OFFSET_BIT + INDEX_BIT));
   \                     L2CC_CleanPAL:
   \   00000000   0xE1B02721         LSRS     R2,R1,#+14
   \   00000004   0x........         LDR      R3,??DataTable11_9
   \   00000008   0xE5832000         STR      R2,[R3, #+0]
    385          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
   \   0000000C   0xE7E822D1         UBFX     R2,R1,#+5,#+9
   \   00000010   0x........         LDR      R3,??DataTable11_10
   \   00000014   0xE1C320B0         STRH     R2,[R3, #+0]
    386          
    387          	pL2CC->L2CC_CPALR =
    388          	    (L2CC_CPALR_TAG(Tag) | L2CC_CPALR_IDX(Index) | L2CC_CPALR_C);
   \   00000018   0x........         LDR      R2,??DataTable11_9
   \   0000001C   0xE5922000         LDR      R2,[R2, #+0]
   \   00000020   0x........         LDR      R3,??DataTable11_10
   \   00000024   0xE1D330B0         LDRH     R3,[R3, #+0]
   \   00000028   0xE303CFE0         MOVW     R12,#+16352
   \   0000002C   0xE01C3283         ANDS     R3,R12,R3, LSL #+5
   \   00000030   0xE1932702         ORRS     R2,R3,R2, LSL #+14
   \   00000034   0xE3922001         ORRS     R2,R2,#0x1
   \   00000038   0xE58027B0         STR      R2,[R0, #+1968]
    389          
    390          	while ((pL2CC->L2CC_CPALR) & L2CC_CPALR_C) ;
   \                     ??L2CC_CleanPAL_0:
   \   0000003C   0xE59027B0         LDR      R2,[R0, #+1968]
   \   00000040   0xE3120001         TST      R2,#0x1
   \   00000044   0x1AFFFFFC         BNE      ??L2CC_CleanPAL_0
    391          }
   \   00000048   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .bss, align 4
   \                     ??Tag_1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
   \                     ??Index_1:
   \   00000000                      DS8 2
    392          
    393          /**
    394           * \brief Clean index cache by Physical addersse
    395           * \param pL2CC Pointer to the L2CC peripheral.
    396           * \param P_Address  Physical addresse
    397           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    398          void
    399          L2CC_CleanIx(L2cc * pL2CC, uint32_t P_Address)
    400          {
    401          	static uint32_t Tag;
    402          	static uint16_t Index;
    403          	Tag = (P_Address >> (OFFSET_BIT + INDEX_BIT));
   \                     L2CC_CleanIx:
   \   00000000   0xE1B02721         LSRS     R2,R1,#+14
   \   00000004   0x........         LDR      R3,??DataTable11_11
   \   00000008   0xE5832000         STR      R2,[R3, #+0]
    404          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
   \   0000000C   0xE7E822D1         UBFX     R2,R1,#+5,#+9
   \   00000010   0x........         LDR      R3,??DataTable11_12
   \   00000014   0xE1C320B0         STRH     R2,[R3, #+0]
    405          
    406          	pL2CC->L2CC_CIPALR =
    407          	    (L2CC_CIPALR_TAG(Tag) | L2CC_CIPALR_IDX(Index) | L2CC_CIPALR_C);
   \   00000018   0x........         LDR      R2,??DataTable11_11
   \   0000001C   0xE5922000         LDR      R2,[R2, #+0]
   \   00000020   0x........         LDR      R3,??DataTable11_12
   \   00000024   0xE1D330B0         LDRH     R3,[R3, #+0]
   \   00000028   0xE303CFE0         MOVW     R12,#+16352
   \   0000002C   0xE01C3283         ANDS     R3,R12,R3, LSL #+5
   \   00000030   0xE1932702         ORRS     R2,R3,R2, LSL #+14
   \   00000034   0xE3922001         ORRS     R2,R2,#0x1
   \   00000038   0xE58027F0         STR      R2,[R0, #+2032]
    408          
    409          	while ((pL2CC->L2CC_CIPALR) & L2CC_CIPALR_C) ;
   \                     ??L2CC_CleanIx_0:
   \   0000003C   0xE59027F0         LDR      R2,[R0, #+2032]
   \   00000040   0xE3120001         TST      R2,#0x1
   \   00000044   0x1AFFFFFC         BNE      ??L2CC_CleanIx_0
    410          }
   \   00000048   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .bss, align 4
   \                     ??Tag_2:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
   \                     ??Index_2:
   \   00000000                      DS8 2
    411          
    412          /**
    413           * \brief Invalidate cache by way
    414           * \param pL2CC Pointer to the L2CC peripheral.
    415           * \param Way  Way number
    416           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    417          void
    418          L2CC_InvalidateWay(L2cc * pL2CC, uint8_t Way)
    419          {
    420          	pL2CC->L2CC_IWR = Way;
   \                     L2CC_InvalidateWay:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE580277C         STR      R2,[R0, #+1916]
    421          
    422          	while (pL2CC->L2CC_IWR) ;
   \                     ??L2CC_InvalidateWay_0:
   \   0000000C   0xE590277C         LDR      R2,[R0, #+1916]
   \   00000010   0xE3520000         CMP      R2,#+0
   \   00000014   0x1AFFFFFC         BNE      ??L2CC_InvalidateWay_0
    423          	while (pL2CC->L2CC_CSR) ;
   \                     ??L2CC_InvalidateWay_1:
   \   00000018   0xE5902730         LDR      R2,[R0, #+1840]
   \   0000001C   0xE3520000         CMP      R2,#+0
   \   00000020   0x1AFFFFFC         BNE      ??L2CC_InvalidateWay_1
    424          
    425          }
   \   00000024   0xE12FFF1E         BX       LR               ;; return
    426          
    427          /**
    428           * \brief Clean cache by way
    429           * \param pL2CC Pointer to the L2CC peripheral.
    430           * \param Way  Way number
    431           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    432          void
    433          L2CC_CleanWay(L2cc * pL2CC, uint8_t Way)
    434          {
    435          	pL2CC->L2CC_CWR = Way;
   \                     L2CC_CleanWay:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE58027BC         STR      R2,[R0, #+1980]
    436          
    437          	while (pL2CC->L2CC_CWR) ;
   \                     ??L2CC_CleanWay_0:
   \   0000000C   0xE59027BC         LDR      R2,[R0, #+1980]
   \   00000010   0xE3520000         CMP      R2,#+0
   \   00000014   0x1AFFFFFC         BNE      ??L2CC_CleanWay_0
    438          	while (pL2CC->L2CC_CSR) ;
   \                     ??L2CC_CleanWay_1:
   \   00000018   0xE5902730         LDR      R2,[R0, #+1840]
   \   0000001C   0xE3520000         CMP      R2,#+0
   \   00000020   0x1AFFFFFC         BNE      ??L2CC_CleanWay_1
    439          
    440          }
   \   00000024   0xE12FFF1E         BX       LR               ;; return
    441          
    442          /**
    443           * \brief Clean Invalidate cache by way
    444           * \param pL2CC Pointer to the L2CC peripheral.
    445           * \param Way  Way number
    446           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    447          static void
    448          L2CC_CleanInvalidateWay(L2cc * pL2CC, uint8_t Way)
    449          {
    450          	pL2CC->L2CC_CIWR = Way;
   \                     L2CC_CleanInvalidateWay:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE58027FC         STR      R2,[R0, #+2044]
    451          
    452          	while (pL2CC->L2CC_CSR) ;
   \                     ??L2CC_CleanInvalidateWay_0:
   \   0000000C   0xE5902730         LDR      R2,[R0, #+1840]
   \   00000010   0xE3520000         CMP      R2,#+0
   \   00000014   0x1AFFFFFC         BNE      ??L2CC_CleanInvalidateWay_0
    453          
    454          }
   \   00000018   0xE12FFF1E         BX       LR               ;; return
    455          
    456          /**
    457           * \brief Clean cache by Index
    458           * \param pL2CC Pointer to the L2CC peripheral.
    459           * \param P_Address  Physical addresse
    460           * \param Way  Way number
    461           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    462          void
    463          L2CC_CleanIndex(L2cc * pL2CC, uint32_t P_Address, uint8_t Way)
    464          {
   \                     L2CC_CleanIndex:
   \   00000000   0xE92D4000         PUSH     {LR}
    465          	static uint16_t Index;
    466          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
   \   00000004   0xE7E832D1         UBFX     R3,R1,#+5,#+9
   \   00000008   0x........         LDR      R12,??DataTable11_13
   \   0000000C   0xE1CC30B0         STRH     R3,[R12, #+0]
    467          
    468          	pL2CC->L2CC_CIR =
    469          	    (L2CC_CIR_IDX(Index) | L2CC_CIR_WAY(Way) | L2CC_CIR_C);
   \   00000010   0x........         LDR      R3,??DataTable11_13
   \   00000014   0xE1D330B0         LDRH     R3,[R3, #+0]
   \   00000018   0xE303CFE0         MOVW     R12,#+16352
   \   0000001C   0xE01C3283         ANDS     R3,R12,R3, LSL #+5
   \   00000020   0xE1B0C002         MOVS     R12,R2
   \   00000024   0xE6EFC07C         UXTB     R12,R12
   \   00000028   0xE3A0E470         MOV      LR,#+1879048192
   \   0000002C   0xE01ECE0C         ANDS     R12,LR,R12, LSL #+28
   \   00000030   0xE19C3003         ORRS     R3,R12,R3
   \   00000034   0xE3933001         ORRS     R3,R3,#0x1
   \   00000038   0xE58037B8         STR      R3,[R0, #+1976]
    470          
    471          	while ((pL2CC->L2CC_CIR) & L2CC_CIR_C) ;
   \                     ??L2CC_CleanIndex_0:
   \   0000003C   0xE59037B8         LDR      R3,[R0, #+1976]
   \   00000040   0xE3130001         TST      R3,#0x1
   \   00000044   0x1AFFFFFC         BNE      ??L2CC_CleanIndex_0
    472          }
   \   00000048   0xE8BD8000         POP      {PC}             ;; return

   \                                 In section .bss, align 2
   \                     ??Index_3:
   \   00000000                      DS8 2
    473          
    474          /**
    475           * \brief Clean Invalidate cache by index
    476           * \param pL2CC Pointer to the L2CC peripheral.
    477           * \param P_Address  Physical address
    478           * \param Way  Way number
    479           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    480          void
    481          L2CC_CleanInvalidateIndex(L2cc * pL2CC, uint32_t P_Address, uint8_t Way)
    482          {
   \                     L2CC_CleanInvalidateIndex:
   \   00000000   0xE92D4000         PUSH     {LR}
    483          	static uint16_t Index;
    484          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
   \   00000004   0xE7E832D1         UBFX     R3,R1,#+5,#+9
   \   00000008   0x........         LDR      R12,??DataTable11_14
   \   0000000C   0xE1CC30B0         STRH     R3,[R12, #+0]
    485          
    486          	pL2CC->L2CC_CIIR =
    487          	    (L2CC_CIIR_IDX(Index) | L2CC_CIIR_WAY(Index) | L2CC_CIIR_C);
   \   00000010   0x........         LDR      R3,??DataTable11_14
   \   00000014   0xE1D330B0         LDRH     R3,[R3, #+0]
   \   00000018   0xE303CFE0         MOVW     R12,#+16352
   \   0000001C   0xE01C3283         ANDS     R3,R12,R3, LSL #+5
   \   00000020   0x........         LDR      R12,??DataTable11_14
   \   00000024   0xE1DCC0B0         LDRH     R12,[R12, #+0]
   \   00000028   0xE3A0E470         MOV      LR,#+1879048192
   \   0000002C   0xE01ECE0C         ANDS     R12,LR,R12, LSL #+28
   \   00000030   0xE19C3003         ORRS     R3,R12,R3
   \   00000034   0xE3933001         ORRS     R3,R3,#0x1
   \   00000038   0xE58037F8         STR      R3,[R0, #+2040]
    488          
    489          	while ((pL2CC->L2CC_CIIR) & L2CC_CIIR_C) ;
   \                     ??L2CC_CleanInvalidateIndex_0:
   \   0000003C   0xE59037F8         LDR      R3,[R0, #+2040]
   \   00000040   0xE3130001         TST      R3,#0x1
   \   00000044   0x1AFFFFFC         BNE      ??L2CC_CleanInvalidateIndex_0
    490          }
   \   00000048   0xE8BD8000         POP      {PC}             ;; return

   \                                 In section .bss, align 2
   \                     ??Index_4:
   \   00000000                      DS8 2
    491          
    492          /**
    493           * \brief cache Data lockdown
    494           * \param pL2CC Pointer to the L2CC peripheral.
    495           * \param Way  Way number
    496           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    497          void
    498          L2CC_DataLockdown(L2cc * pL2CC, uint8_t Way)
    499          {
    500          	pL2CC->L2CC_DLKR = Way;
   \                     L2CC_DataLockdown:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE5802900         STR      R2,[R0, #+2304]
    501          
    502          	while (pL2CC->L2CC_CSR) ;
   \                     ??L2CC_DataLockdown_0:
   \   0000000C   0xE5902730         LDR      R2,[R0, #+1840]
   \   00000010   0xE3520000         CMP      R2,#+0
   \   00000014   0x1AFFFFFC         BNE      ??L2CC_DataLockdown_0
    503          }
   \   00000018   0xE12FFF1E         BX       LR               ;; return
    504          
    505          /**
    506           * \brief cache instruction lockdown
    507           * \param pL2CC Pointer to the L2CC peripheral.
    508           * \param Way  Way number
    509           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    510          void
    511          L2CC_InstructionLockdown(L2cc * pL2CC, uint8_t Way)
    512          {
    513          	pL2CC->L2CC_ILKR = Way;
   \                     L2CC_InstructionLockdown:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE5802904         STR      R2,[R0, #+2308]
    514          
    515          	while (pL2CC->L2CC_CSR) ;
   \                     ??L2CC_InstructionLockdown_0:
   \   0000000C   0xE5902730         LDR      R2,[R0, #+1840]
   \   00000010   0xE3520000         CMP      R2,#+0
   \   00000014   0x1AFFFFFC         BNE      ??L2CC_InstructionLockdown_0
    516          }
   \   00000018   0xE12FFF1E         BX       LR               ;; return
    517          

   \                                 In section SOFTPACK, align 4, keep-with-next
    518          static void
    519          L2CC_Clean(void)
    520          {
   \                     L2CC_Clean:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    521          	cp15_cache_clean(CP15_DCache);	// Clean of L1; This is broadcast within the cluster
   \   00000004   0xE3A00000         MOV      R0,#+0
   \   00000008   0x........         BL       cp15_cache_clean
    522          	L2CC_CleanWay(L2CC, 0xFF);	// forces the address out past level 2
   \   0000000C   0xE3A010FF         MOV      R1,#+255
   \   00000010   0xE3A008A0         MOV      R0,#+10485760
   \   00000014   0x........         BL       L2CC_CleanWay
    523          	L2CC_CacheSync(L2CC);	// Ensures completion of the L2 clean
   \   00000018   0xE3A008A0         MOV      R0,#+10485760
   \   0000001C   0x........         BL       L2CC_CacheSync
    524          }
   \   00000020   0xE8BD8001         POP      {R0,PC}          ;; return
    525          

   \                                 In section SOFTPACK, align 4, keep-with-next
    526          static void
    527          L2CC_Invalidate(void)
    528          {
   \                     L2CC_Invalidate:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    529          	L2CC_InvalidateWay(L2CC, 0xFF);	// forces the address out past level 2
   \   00000004   0xE3A010FF         MOV      R1,#+255
   \   00000008   0xE3A008A0         MOV      R0,#+10485760
   \   0000000C   0x........         BL       L2CC_InvalidateWay
    530          	L2CC_CacheSync(L2CC);	// Ensures completion of the L2 inval
   \   00000010   0xE3A008A0         MOV      R0,#+10485760
   \   00000014   0x........         BL       L2CC_CacheSync
    531          	cp15_cache_invalidate(CP15_DCache);	// Inval of L1; This is broadcast within the cluster
   \   00000018   0xE3A00000         MOV      R0,#+0
   \   0000001C   0x........         BL       cp15_cache_invalidate
    532          }
   \   00000020   0xE8BD8001         POP      {R0,PC}          ;; return
    533          

   \                                 In section SOFTPACK, align 4, keep-with-next
    534          static void
    535          L2CC_CleanInvalidate(void)
    536          {
   \                     L2CC_CleanInvalidate:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    537          	cp15_cache_clean(CP15_DCache);	// Clean of L1; This is broadcast within the cluster
   \   00000004   0xE3A00000         MOV      R0,#+0
   \   00000008   0x........         BL       cp15_cache_clean
    538          	L2CC_CleanInvalidateWay(L2CC, 0xFF);	// forces the address out past level 2
   \   0000000C   0xE3A010FF         MOV      R1,#+255
   \   00000010   0xE3A008A0         MOV      R0,#+10485760
   \   00000014   0x........         BL       L2CC_CleanInvalidateWay
    539          	L2CC_CacheSync(L2CC);	// Ensures completion of the L2 inval
   \   00000018   0xE3A008A0         MOV      R0,#+10485760
   \   0000001C   0x........         BL       L2CC_CacheSync
    540          	cp15_cache_invalidate(CP15_DCache);	// Inval of L1; This is broadcast within the cluster
   \   00000020   0xE3A00000         MOV      R0,#+0
   \   00000024   0x........         BL       cp15_cache_invalidate
    541          }
   \   00000028   0xE8BD8001         POP      {R0,PC}          ;; return
    542          
    543          /**
    544           *  \brief L2 DCache maintenance (clean/invalidate/flush)
    545           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    546          void
    547          L2CC_CacheMaintenance(uint8_t Maint_Op)
    548          {
   \                     L2CC_CacheMaintenance:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    549          
    550          	switch (Maint_Op) {
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0xE6EF0070         UXTB     R0,R0
   \   00000010   0xE3500000         CMP      R0,#+0
   \   00000014   0x0A000003         BEQ      ??L2CC_CacheMaintenance_0
   \   00000018   0xE3500002         CMP      R0,#+2
   \   0000001C   0x0A000005         BEQ      ??L2CC_CacheMaintenance_1
   \   00000020   0x3A000002         BCC      ??L2CC_CacheMaintenance_2
   \   00000024   0xEA000004         B        ??L2CC_CacheMaintenance_3
    551          	case DCACHE_CLEAN:
    552          		L2CC_Clean();
   \                     ??L2CC_CacheMaintenance_0:
   \   00000028   0x........         BL       L2CC_Clean
    553          		break;
   \   0000002C   0xEA000002         B        ??L2CC_CacheMaintenance_3
    554          	case DCACHE_INVAL:
    555          		L2CC_Invalidate();
   \                     ??L2CC_CacheMaintenance_2:
   \   00000030   0x........         BL       L2CC_Invalidate
    556          		break;
   \   00000034   0xEA000000         B        ??L2CC_CacheMaintenance_3
    557          	case DCACHE_FLUSH:
    558          		L2CC_CleanInvalidate();
   \                     ??L2CC_CacheMaintenance_1:
   \   00000038   0x........         BL       L2CC_CleanInvalidate
    559          		break;
    560          	}
    561          }
   \                     ??L2CC_CacheMaintenance_3:
   \   0000003C   0xE8BD8010         POP      {R4,PC}          ;; return
    562          
    563          /**
    564           *  \brief Enable level two cache controller (L2CC)
    565           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    566          void
    567          Enable_L2CC(void)
    568          {
   \                     Enable_L2CC:
   \   00000000   0xE92D4000         PUSH     {LR}
   \   00000004   0xE24DD0A4         SUB      SP,SP,#+164
    569          	L2CC_Control L2Config;
    570          	/*****1. configure L2CC ************/
    571          	L2Config.IPEN_Val = ENABLE;	// Instruction prefetch enable
   \   00000008   0xE3A00001         MOV      R0,#+1
   \   0000000C   0xE58D0078         STR      R0,[SP, #+120]
    572          	L2Config.DPEN_Val = ENABLE;	// Data prefetch enable
   \   00000010   0xE3A00001         MOV      R0,#+1
   \   00000014   0xE58D0074         STR      R0,[SP, #+116]
    573          
    574          	L2Config.DLEN_Val = ENABLE;
   \   00000018   0xE3A00001         MOV      R0,#+1
   \   0000001C   0xE58D0090         STR      R0,[SP, #+144]
    575          	L2Config.IDLEN_Val = ENABLE;
   \   00000020   0xE3A00001         MOV      R0,#+1
   \   00000024   0xE58D0084         STR      R0,[SP, #+132]
    576          	//L2Config.DWB_Val = ENABLE;        // Disable Write back (enables write through, Use this setting if DDR2 mem is not write-back)
    577          	L2Config.FWA_Val = FWA_NO_ALLOCATE;
   \   00000028   0xE3A00001         MOV      R0,#+1
   \   0000002C   0xE58D0064         STR      R0,[SP, #+100]
    578          
    579          	L2Config.OFFSET_Val = 31;
   \   00000030   0xE3A0001F         MOV      R0,#+31
   \   00000034   0xE58D007C         STR      R0,[SP, #+124]
    580          	L2Config.PDEN_Val = ENABLE;
   \   00000038   0xE3A00001         MOV      R0,#+1
   \   0000003C   0xE58D0088         STR      R0,[SP, #+136]
    581          
    582          	L2Config.STBYEN_Val = ENABLE;
   \   00000040   0xE3A00001         MOV      R0,#+1
   \   00000044   0xE58D0094         STR      R0,[SP, #+148]
    583          	L2Config.DCKGATEN_Val = ENABLE;
   \   00000048   0xE3A00001         MOV      R0,#+1
   \   0000004C   0xE58D0098         STR      R0,[SP, #+152]
    584          
    585          	L2CC_EventConfig(L2CC, 0, L2CC_ECFGR0_ESRC_SRC_DRHIT,
    586          			 L2CC_ECFGR0_EIGEN_INT_DIS);
   \   00000050   0xE3A03000         MOV      R3,#+0
   \   00000054   0xE3A02008         MOV      R2,#+8
   \   00000058   0xE3A01000         MOV      R1,#+0
   \   0000005C   0xE3A008A0         MOV      R0,#+10485760
   \   00000060   0x........         BL       L2CC_EventConfig
    587          	L2CC_EventConfig(L2CC, 1, L2CC_ECFGR0_ESRC_SRC_DWHIT,
    588          			 L2CC_ECFGR0_EIGEN_INT_DIS);
   \   00000064   0xE3A03000         MOV      R3,#+0
   \   00000068   0xE3A02010         MOV      R2,#+16
   \   0000006C   0xE3A01001         MOV      R1,#+1
   \   00000070   0xE3A008A0         MOV      R0,#+10485760
   \   00000074   0x........         BL       L2CC_EventConfig
    589          	L2CC_EnableResetCounter(L2CC, RESET_BOTH_COUNTER);
   \   00000078   0xE3A01003         MOV      R1,#+3
   \   0000007C   0xE3A008A0         MOV      R0,#+10485760
   \   00000080   0x........         BL       L2CC_EnableResetCounter
    590          
    591          	L2CC_Config(L2CC, L2Config);
   \   00000084   0xE28D104C         ADD      R1,SP,#+76
   \   00000088   0xE24DD00C         SUB      SP,SP,#+12
   \   0000008C   0xE1B0000D         MOVS     R0,SP
   \   00000090   0xE3A02058         MOV      R2,#+88
   \   00000094   0x........         BL       __aeabi_memcpy4
   \   00000098   0xE8BD000E         POP      {R1-R3}
   \   0000009C   0xE3A008A0         MOV      R0,#+10485760
   \   000000A0   0x........         BL       L2CC_Config
    592          
    593          	/* Enable Prefetch */
    594          	L2CC_InstPrefetchEnable(L2CC);
   \   000000A4   0xE3A008A0         MOV      R0,#+10485760
   \   000000A8   0x........         BL       L2CC_InstPrefetchEnable
    595          	L2CC_DataPrefetchEnable(L2CC);
   \   000000AC   0xE3A008A0         MOV      R0,#+10485760
   \   000000B0   0x........         BL       L2CC_DataPrefetchEnable
    596          
    597          	/*2. Invalidate whole L2C     ********** */
    598          	L2CC_InvalidateWay(L2CC, 0xFF);
   \   000000B4   0xE3A010FF         MOV      R1,#+255
   \   000000B8   0xE3A008A0         MOV      R0,#+10485760
   \   000000BC   0x........         BL       L2CC_InvalidateWay
    599          	/*3. Disable all L2C Interrupt ********** */
    600          	L2CC_DisableIT(L2CC, 0x1FF);
   \   000000C0   0xE30011FF         MOVW     R1,#+511
   \   000000C4   0xE3A008A0         MOV      R0,#+10485760
   \   000000C8   0x........         BL       L2CC_DisableIT
    601          	/*4. Clear all L2C Interrupt ********** */
    602          	L2CC_ITClear(L2CC, 0);
   \   000000CC   0xE3A01000         MOV      R1,#+0
   \   000000D0   0xE3A008A0         MOV      R0,#+10485760
   \   000000D4   0x........         BL       L2CC_ITClear
    603          
    604          	L2CC_ExclusiveCache(L2CC, ENABLE);
   \   000000D8   0xE3A01001         MOV      R1,#+1
   \   000000DC   0xE3A008A0         MOV      R0,#+10485760
   \   000000E0   0x........         BL       L2CC_ExclusiveCache
    605          	L2CC_Enable(L2CC);
   \   000000E4   0xE3A008A0         MOV      R0,#+10485760
   \   000000E8   0x........         BL       L2CC_Enable
    606          }
   \   000000EC   0xE28DD0A4         ADD      SP,SP,#+164      ;; stack cleaning
   \   000000F0   0xE8BD8000         POP      {PC}             ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x30 0x00          DC8      "0",0x0,0x0
   \              0x00 0x00    

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     ?_7

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     ??Tag

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     ??Index

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     ??Tag_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     ??Index_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     ??Tag_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     ??Index_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     ??Index_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x........         DC32     ??Index_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2D 0x49          DC8 "-I- L2 cache is enabled"
   \              0x2D 0x20    
   \              0x4C 0x32    
   \              0x20 0x63    
   \              0x61 0x63    
   \              0x68 0x65    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x65 0x6E    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x2D 0x49          DC8 "-I- L2 cache is Disabled"
   \              0x2D 0x20    
   \              0x4C 0x32    
   \              0x20 0x63    
   \              0x61 0x63    
   \              0x68 0x65    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x44 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x2D 0x49          DC8 "-I- L2 Exclusive mode Enabled\012\015"
   \              0x2D 0x20    
   \              0x4C 0x32    
   \              0x20 0x45    
   \              0x78 0x63    
   \              0x6C 0x75    
   \              0x73 0x69    
   \              0x76 0x65    
   \              0x20 0x6D    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x45 0x6E    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x2D 0x49          DC8 "-I- L2 Exclusive mode Disabled\012\015"
   \              0x2D 0x20    
   \              0x4C 0x32    
   \              0x20 0x45    
   \              0x78 0x63    
   \              0x6C 0x75    
   \              0x73 0x69    
   \              0x76 0x65    
   \              0x20 0x6D    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x44 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x30 0x00          DC8 "0"

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 63H, 6FH, 72H, 65H
   \              0x73 0x5C    
   \              0x63 0x6F    
   \              0x72 0x65    
   \   00000038   0x5C 0x6C          DC8 5CH, 6CH, 32H, 63H, 63H, 2EH, 63H, 0
   \              0x32 0x63    
   \              0x63 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x28 0x45          DC8 "(EventCounter > 3) ? 0 : 1"
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x3E 0x20    
   \              0x33 0x29    
   \              0x20 0x3F    
   \              0x20 0x30    
   \              0x20 0x3A    
   \              0x20 0x31    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x28 0x45          DC8 "(EventCounter > 1) ? 0 : 1"
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x3E 0x20    
   \              0x31 0x29    
   \              0x20 0x3F    
   \              0x20 0x30    
   \              0x20 0x3A    
   \              0x20 0x31    
   \              0x00         
   \   0000001B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     180   Enable_L2CC
       168   -> L2CC_Config
       168   -> L2CC_DataPrefetchEnable
       168   -> L2CC_DisableIT
       168   -> L2CC_Enable
       168   -> L2CC_EnableResetCounter
       168   -> L2CC_EventConfig
       168   -> L2CC_ExclusiveCache
       168   -> L2CC_ITClear
       168   -> L2CC_InstPrefetchEnable
       168   -> L2CC_InvalidateWay
       180   -> __aeabi_memcpy4
       8   L2CC_CacheMaintenance
         8   -> L2CC_Clean
         8   -> L2CC_CleanInvalidate
         8   -> L2CC_Invalidate
       0   L2CC_CacheSync
       8   L2CC_Clean
         8   -> L2CC_CacheSync
         8   -> L2CC_CleanWay
         8   -> cp15_cache_clean
       4   L2CC_CleanIndex
       8   L2CC_CleanInvalidate
         8   -> L2CC_CacheSync
         8   -> L2CC_CleanInvalidateWay
         8   -> cp15_cache_clean
         8   -> cp15_cache_invalidate
       4   L2CC_CleanInvalidateIndex
       0   L2CC_CleanInvalidateWay
       0   L2CC_CleanIx
       0   L2CC_CleanPAL
       0   L2CC_CleanWay
      40   L2CC_Config
        40   -> L2CC_IsEnabled
        40   -> __aeabi_assert
        40   -> __iar_EmptyStepPoint
      16   L2CC_ConfigLatRAM
        16   -> L2CC_IsEnabled
       0   L2CC_DataLockdown
       0   L2CC_DataPrefetchEnable
       8   L2CC_Disable
         8   -> printf
       0   L2CC_DisableIT
       8   L2CC_Enable
         8   -> printf
       0   L2CC_EnableIT
      16   L2CC_EnableResetCounter
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   L2CC_EventConfig
        24   -> L2CC_IsEnabled
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      16   L2CC_EventCounterValue
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   L2CC_ExclusiveCache
        16   -> L2CC_IsEnabled
        16   -> cp15_exclusive_cache
        16   -> cp15_non_exclusive_cache
        16   -> printf
       0   L2CC_ITClear
       0   L2CC_ITStatusMask
       0   L2CC_ITStatusRaw
       0   L2CC_InstPrefetchEnable
       0   L2CC_InstructionLockdown
       8   L2CC_Invalidate
         8   -> L2CC_CacheSync
         8   -> L2CC_InvalidateWay
         8   -> cp15_cache_invalidate
       0   L2CC_InvalidatePAL
       0   L2CC_InvalidateWay
       0   L2CC_IsEnabled
       0   L2CC_PollSPNIDEN


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable6
      24  ?_0
      28  ?_1
      32  ?_2
      36  ?_3
       2  ?_4
      64  ?_5
      28  ?_6
      28  ?_7
     244  Enable_L2CC
       2  Index
       2  Index
       2  Index
       2  Index
       2  Index
      64  L2CC_CacheMaintenance
      36  L2CC_CacheSync
      36  L2CC_Clean
      76  L2CC_CleanIndex
      44  L2CC_CleanInvalidate
      76  L2CC_CleanInvalidateIndex
      28  L2CC_CleanInvalidateWay
      76  L2CC_CleanIx
      76  L2CC_CleanPAL
      40  L2CC_CleanWay
     428  L2CC_Config
     128  L2CC_ConfigLatRAM
      28  L2CC_DataLockdown
      16  L2CC_DataPrefetchEnable
      32  L2CC_Disable
      48  L2CC_DisableIT
      32  L2CC_Enable
      24  L2CC_EnableIT
      72  L2CC_EnableResetCounter
     152  L2CC_EventConfig
      80  L2CC_EventCounterValue
     112  L2CC_ExclusiveCache
      24  L2CC_ITClear
      36  L2CC_ITStatusMask
      36  L2CC_ITStatusRaw
      16  L2CC_InstPrefetchEnable
      28  L2CC_InstructionLockdown
      36  L2CC_Invalidate
      76  L2CC_InvalidatePAL
      40  L2CC_InvalidateWay
      12  L2CC_IsEnabled
      16  L2CC_PollSPNIDEN
       4  Tag
       4  Tag
       4  Tag
      56  _id_h64_matrix

 
    22 bytes in section .bss
   298 bytes in section .rodata
 2 332 bytes in section SOFTPACK
 
 2 332 bytes of CODE  memory
   298 bytes of CONST memory
    22 bytes of DATA  memory

Errors: none
Warnings: 1
