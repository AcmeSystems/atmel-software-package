###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        19/May/2015  13:45:47
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\l2cc.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\l2cc.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D24
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\l2cc.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\l2cc.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\core\l2cc.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2011, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \file */
     31          
     32          /*----------------------------------------------------------------------------
     33           *        Headers
     34           *----------------------------------------------------------------------------*/
     35          #include "chip.h"

  	if (addr == (void*)TWI0) return ID_FLEXCOM0; /**< \brief FLEXCOM 0 (FLEXCOM0) */
  	                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",178  Error[Pe020]: 
          identifier "TWI0" is undefined

  	if (id == ID_FLEXCOM0) return TWI0; /**< \brief FLEXCOM 0 (FLEXCOM0) */
  	                              ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",206  Error[Pe020]: 
          identifier "TWI0" is undefined

  	else if (addr == (void*)FCOMSPI0) return ID_FCOMSPI0;
  	                        ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",235  Error[Pe020]: 
          identifier "FCOMSPI0" is undefined

  	else if (addr == (void*)FCOMSPI1) return ID_FCOMSPI1;
  	                        ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",236  Error[Pe020]: 
          identifier "FCOMSPI1" is undefined

  	else if (addr == (void*)FCOMSPI3) return ID_FCOMSPI3;
  	                        ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",237  Error[Pe020]: 
          identifier "FCOMSPI3" is undefined

  	else if (addr == (void*)FCOMSPI4) return ID_FCOMSPI4;
  	                        ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",238  Error[Pe020]: 
          identifier "FCOMSPI4" is undefined

  	else if (id == ID_FCOMSPI0) return FCOMSPI0; /**< \brief FLEXCOM SPI 0 (FCOMSPI0) */
  	                                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",246  Error[Pe020]: 
          identifier "FCOMSPI0" is undefined

  	else if (id == ID_FCOMSPI1) return FCOMSPI1; /**< \brief FLEXCOM SPI 1 (FCOMSPI1) */
  	                                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",247  Error[Pe020]: 
          identifier "FCOMSPI1" is undefined

  	else if (id == ID_FCOMSPI3) return FCOMSPI3; /**< \brief FLEXCOM SPI 3 (FCOMSPI3) */
  	                                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",248  Error[Pe020]: 
          identifier "FCOMSPI3" is undefined

  	else if (id == ID_FCOMSPI4) return FCOMSPI4; /**< \brief FLEXCOM SPI 4 (FCOMSPI4) */
  	                                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",249  Error[Pe020]: 
          identifier "FCOMSPI4" is undefined

  	if (addr == (void*)USART0) return ID_USART0;
  	                   ^
"C:\Users\dfronek\Documents\Project\softpack\target\sama5d2\sama5d2.h",273  Error[Pe020]: 
          identifier "USART0" is undefined
     36          #include "core/l2cc.h"
     37          #include "core/cp15.h"
     38          #include "utils/trace.h"
     39          #include <assert.h>
     40          
     41          /**
     42           * \brief Check if Level 2 cache is enable.
     43           * \param pL2CC Pointer to the L2CC peripheral.
     44           */
     45          unsigned int
     46          L2CC_IsEnabled(L2cc * pL2CC)
     47          {
     48          	return ((pL2CC->L2CC_CR) & L2CC_CR_L2CEN);
     49          }
     50          
     51          /**
     52           * \brief Enable Level 2 cache.
     53           * \param pL2CC Pointer to the L2CC peripheral.
     54           */
     55          void
     56          L2CC_Enable(L2cc * pL2CC)
     57          {
     58          	pL2CC->L2CC_CR |= L2CC_CR_L2CEN;
     59          	TRACE_INFO("L2 cache is enabled");
     60          }
     61          
     62          /**
     63           * \brief Disable Level 2 cache.
     64           * \param pL2CC Pointer to the L2CC peripheral.
     65           */
     66          void
     67          L2CC_Disable(L2cc * pL2CC)
     68          {
     69          	pL2CC->L2CC_CR &= (!L2CC_CR_L2CEN);
     70          	TRACE_INFO("L2 cache is Disabled");
     71          }
     72          
     73          /**
     74           * \brief Configures Level 2 cache as exclusive cache.
     75           * \param pL2CC Pointer to the L2CC peripheral.
     76           * \param Enable Enable/disable exclusive cache.
     77           */
     78          void
     79          L2CC_ExclusiveCache(L2cc * pL2CC, uint8_t Enable)
     80          {
     81          	uint32_t Aux_Cfg;
     82          	if (L2CC_IsEnabled(pL2CC)) {
     83          		pL2CC->L2CC_CR = DISABLE;
     84          	}
     85          	Aux_Cfg = pL2CC->L2CC_ACR;
     86          	if (Enable) {
     87          		cp15_exclusive_cache();
     88          		Aux_Cfg |= L2CC_ACR_EXCC;
     89          		TRACE_INFO("L2 Exclusive mode Enabled\n\r");
     90          	} else {
     91          		cp15_non_exclusive_cache();
     92          		Aux_Cfg &= ~L2CC_ACR_EXCC;
     93          		TRACE_INFO("L2 Exclusive mode Disabled\n\r");
     94          	}
     95          
     96          	pL2CC->L2CC_ACR |= Aux_Cfg;
     97          
     98          }
     99          
    100          /**
    101           * \brief Configures Level 2 cache RAM Latency (Tag and Data).
    102           * \param pL2CC Pointer to the L2CC peripheral.
    103           * \param pLat  Structure containing RAM Tag and Data latencies
    104           */
    105          void
    106          L2CC_ConfigLatRAM(L2cc * pL2CC, RAMLatencyControl * pLat)
    107          {
    108          	if (L2CC_IsEnabled(pL2CC)) {
    109          		pL2CC->L2CC_CR = DISABLE;
    110          	}
    111          
    112          	pL2CC->L2CC_TRCR =
    113          	    (L2CC_TRCR_TSETLAT(pLat->TagRAM.SetupLAT) |
    114          	     L2CC_TRCR_TRDLAT(pLat->TagRAM.ReadLAT) | L2CC_TRCR_TWRLAT(pLat->
    115          								       TagRAM.
    116          								       WriteLAT));
    117          	pL2CC->L2CC_DRCR =
    118          	    (L2CC_DRCR_DSETLAT(pLat->DataRAM.SetupLAT) |
    119          	     L2CC_DRCR_DRDLAT(pLat->DataRAM.ReadLAT) | L2CC_DRCR_DWRLAT(pLat->
    120          									DataRAM.
    121          									WriteLAT));
    122          
    123          }
    124          
    125          /**
    126           * \brief Configures Level 2 cache.
    127           * \param pL2CC Pointer to the L2CC peripheral.
    128           * \param L2cc_Config  Configuration values to put in Auxiliary, prefetch, debug and powercontrol registers
    129           */
    130          void
    131          L2CC_Config(L2cc * pL2CC, L2CC_Control L2cc_Config)
    132          {
    133          	uint32_t AuxiliaryControl, DebugControl, PrefetchControl, PowerControl;
    134          
    135          	if (L2cc_Config.OFFSET_Val > 31) {
    136          		assert(0);
    137          	}
    138          	if ((L2cc_Config.OFFSET_Val > 7) && (L2cc_Config.OFFSET_Val < 15)) {
    139          		assert(0);
    140          	}
    141          	if ((L2cc_Config.OFFSET_Val > 15) && (L2cc_Config.OFFSET_Val < 23)) {
    142          		assert(0);
    143          	}
    144          	if ((L2cc_Config.OFFSET_Val > 23) && (L2cc_Config.OFFSET_Val < 31)) {
    145          		assert(0);
    146          	}
    147          //  if( ((L2cc_Config.IDLEN_Val==1) || (L2cc_Config.DLFWRDIS_Val==0)) && L2cc_Config.DLEN_Val==0)
    148          //  {
    149          //    TRACE_ERROR(" DLEN is not enabled for Double Line fill");
    150          //    assert(0);
    151          //  }
    152          
    153          	if (L2CC_IsEnabled(pL2CC)) {
    154          		pL2CC->L2CC_CR = DISABLE;
    155          	}
    156          
    157          	AuxiliaryControl = ((L2cc_Config.HPSO_Val << 10) |
    158          			    (L2cc_Config.SBDLE_Val << 11) |
    159          			    (L2cc_Config.SAIE_Val << 13) |
    160          			    (L2cc_Config.EMBEN_Val << 20) |
    161          			    (L2cc_Config.PEN_Val << 21) |
    162          			    (L2cc_Config.SAOEN_Val << 22) |
    163          			    (L2CC_ACR_FWA(L2cc_Config.FWA_Val)) |
    164          			    (L2cc_Config.CRPOL_Val << 25) |
    165          			    (L2cc_Config.NSLEN_Val << 26) |
    166          			    (L2cc_Config.NSIAC_Val << 27) |
    167          			    (L2cc_Config.DPEN_Val << 28) |
    168          			    (L2cc_Config.IPEN_Val << 29));
    169          
    170          	DebugControl = ((L2cc_Config.DCL_Val << 0) |
    171          			(L2cc_Config.DWB_Val << 1));
    172          
    173          	PrefetchControl = ((L2cc_Config.OFFSET_Val << 0) |
    174          			   (L2cc_Config.NSIDEN_Val << 21) |
    175          			   (L2cc_Config.IDLEN_Val << 23) |
    176          			   (L2cc_Config.PDEN_Val << 24) |
    177          			   (L2cc_Config.DLFWRDIS_Val << 27) |
    178          			   (L2cc_Config.DPEN_Val << 28) |
    179          			   (L2cc_Config.IPEN_Val << 29) |
    180          			   (L2cc_Config.DLEN_Val << 30));
    181          
    182          	PowerControl = ((L2cc_Config.DCL_Val << 0) |
    183          			(L2cc_Config.DWB_Val << 1));
    184          
    185          	pL2CC->L2CC_ACR = AuxiliaryControl;
    186          
    187          	pL2CC->L2CC_DCR = DebugControl;
    188          
    189          	pL2CC->L2CC_PCR = PrefetchControl;
    190          
    191          	pL2CC->L2CC_POWCR = PowerControl;
    192          
    193          }
    194          
    195          /**
    196           * \brief Enables Data prefetch on L2
    197           * \param pL2CC Pointer to the L2CC peripheral.
    198           */
    199          void
    200          L2CC_DataPrefetchEnable(L2cc * pL2CC)
    201          {
    202          
    203          	pL2CC->L2CC_PCR |= L2CC_PCR_DATPEN;
    204          
    205          }
    206          
    207          /**
    208           * \brief Enables instruction prefetch on L2
    209           * \param pL2CC Pointer to the L2CC peripheral.
    210           */
    211          void
    212          L2CC_InstPrefetchEnable(L2cc * pL2CC)
    213          {
    214          
    215          	pL2CC->L2CC_PCR |= L2CC_PCR_INSPEN;
    216          
    217          }
    218          
    219          /**
    220           * \brief Enables instruction prefetch on L2
    221           * \param pL2CC Pointer to the L2CC peripheral.
    222           * \param EventCounter Counter of the events.
    223           */
    224          void
    225          L2CC_EnableResetCounter(L2cc * pL2CC, uint8_t EventCounter)
    226          {
    227          
    228          	assert((EventCounter > 3) ? 0 : 1);
    229          
    230          	pL2CC->L2CC_ECR = (L2CC_ECR_EVCEN | (EventCounter << 1));
    231          
    232          }
    233          
    234          /**
    235           * \brief Configures Event of Level 2 cache.
    236           * \param pL2CC Pointer to the L2CC peripheral.
    237           * \param EventCounter  Eventcounter 1 or 0
    238           * \param Source  Event Genration source
    239           * \param IntGen  Event Counter Interrupt Generation condition
    240           */
    241          void
    242          L2CC_EventConfig(L2cc * pL2CC, uint8_t EventCounter, uint8_t Source,
    243          		 uint8_t IntGen)
    244          {
    245          	if (L2CC_IsEnabled(pL2CC)) {
    246          		pL2CC->L2CC_CR = DISABLE;
    247          	}
    248          
    249          	assert((EventCounter > 1) ? 0 : 1);
    250          
    251          	if (!EventCounter) {
    252          		pL2CC->L2CC_ECFGR0 = (Source | IntGen);
    253          	} else {
    254          		pL2CC->L2CC_ECFGR1 = (Source | IntGen);
    255          	}
    256          
    257          }
    258          
    259          /**
    260           * \brief Reads Eventcounter value.
    261           * \param pL2CC Pointer to the L2CC peripheral.
    262           * \param EventCounter  choose Eventcounter 1 or 0
    263           */
    264          unsigned int
    265          L2CC_EventCounterValue(L2cc * pL2CC, uint8_t EventCounter)
    266          {
    267          
    268          	assert((EventCounter > 1) ? 0 : 1);
    269          
    270          	if (!EventCounter) {
    271          		return pL2CC->L2CC_EVR0;
    272          	} else {
    273          		return pL2CC->L2CC_EVR1;
    274          	}
    275          
    276          }
    277          
    278          /**
    279           * \brief Enable interrupts
    280           * \param pL2CC Pointer to the L2CC peripheral.
    281           * \param ITSource  Interrupt source
    282           */
    283          void
    284          L2CC_EnableIT(L2cc * pL2CC, uint16_t ITSource)
    285          {
    286          	pL2CC->L2CC_IMR |= ITSource;
    287          }
    288          
    289          /**
    290           * \brief Disable interrupts
    291           * \param pL2CC Pointer to the L2CC peripheral.
    292           * \param ITSource  Interrupt source
    293           */
    294          void
    295          L2CC_DisableIT(L2cc * pL2CC, uint16_t ITSource)
    296          {
    297          	pL2CC->L2CC_IMR &= (!ITSource);
    298          }
    299          
    300          /**
    301           * \brief Enabled interrupt's raw status
    302           * \param pL2CC Pointer to the L2CC peripheral.
    303           * \param ITSource  Interrupt source
    304           */
    305          unsigned short
    306          L2CC_ITStatusRaw(L2cc * pL2CC, uint16_t ITSource)
    307          {
    308          	return ((pL2CC->L2CC_RISR) & ITSource) ? 1 : 0;
    309          }
    310          
    311          /**
    312           * \brief Status of masked interrupts
    313           * \param pL2CC Pointer to the L2CC peripheral.
    314           * \param ITSource  Interrupt source
    315           */
    316          unsigned short
    317          L2CC_ITStatusMask(L2cc * pL2CC, uint16_t ITSource)
    318          {
    319          	return ((pL2CC->L2CC_MISR) & ITSource) ? 1 : 0;
    320          }
    321          
    322          /**
    323           * \brief Clear interrupts
    324           * \param pL2CC Pointer to the L2CC peripheral.
    325           * \param ITSource  Interrupt source
    326           */
    327          void
    328          L2CC_ITClear(L2cc * pL2CC, uint16_t ITSource)
    329          {
    330          	pL2CC->L2CC_ICR |= ITSource;
    331          }
    332          
    333          /**
    334           * \brief Poll SPNIDEN signal
    335           * \param pL2CC Pointer to the L2CC peripheral.
    336           */
    337          uint8_t
    338          L2CC_PollSPNIDEN(L2cc * pL2CC)
    339          {
    340          	return ((pL2CC->L2CC_DCR & L2CC_DCR_SPNIDEN) >> 2);
    341          }
    342          
    343          /**
    344           * \brief Synchronizes the L2 cache
    345           * \param pL2CC Pointer to the L2CC peripheral.
    346           */
    347          void
    348          L2CC_CacheSync(L2cc * pL2CC)
    349          {
    350          	while ((pL2CC->L2CC_CSR) & L2CC_CSR_C) ;
    351          	pL2CC->L2CC_CSR = L2CC_CSR_C;
    352          	while ((pL2CC->L2CC_CSR) & L2CC_CSR_C) ;
    353          }
    354          
    355          /**
    356           * \brief Invalidate cache by Physical addersse
    357           * \param pL2CC Pointer to the L2CC peripheral.
    358           * \param P_Address  Physical addresse
    359           */
    360          void
    361          L2CC_InvalidatePAL(L2cc * pL2CC, uint32_t P_Address)
    362          {
    363          	static uint32_t Tag;
    364          	static uint16_t Index;
    365          	Tag = (P_Address >> (OFFSET_BIT + INDEX_BIT));
    366          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
    367          
    368          	pL2CC->L2CC_IPALR =
    369          	    (L2CC_IPALR_TAG(Tag) | L2CC_IPALR_IDX(Index) | L2CC_IPALR_C);
    370          
    371          	while ((pL2CC->L2CC_IPALR) & L2CC_IPALR_C) ;
    372          }
    373          
    374          /**
    375           * \brief Clean cache by Physical addersse
    376           * \param pL2CC Pointer to the L2CC peripheral.
    377           * \param P_Address  Physical addresse
    378           */
    379          void
    380          L2CC_CleanPAL(L2cc * pL2CC, uint32_t P_Address)
    381          {
    382          	static uint32_t Tag;
    383          	static uint16_t Index;
    384          	Tag = (P_Address >> (OFFSET_BIT + INDEX_BIT));
    385          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
    386          
    387          	pL2CC->L2CC_CPALR =
    388          	    (L2CC_CPALR_TAG(Tag) | L2CC_CPALR_IDX(Index) | L2CC_CPALR_C);
    389          
    390          	while ((pL2CC->L2CC_CPALR) & L2CC_CPALR_C) ;
    391          }
    392          
    393          /**
    394           * \brief Clean index cache by Physical addersse
    395           * \param pL2CC Pointer to the L2CC peripheral.
    396           * \param P_Address  Physical addresse
    397           */
    398          void
    399          L2CC_CleanIx(L2cc * pL2CC, uint32_t P_Address)
    400          {
    401          	static uint32_t Tag;
    402          	static uint16_t Index;
    403          	Tag = (P_Address >> (OFFSET_BIT + INDEX_BIT));
    404          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
    405          
    406          	pL2CC->L2CC_CIPALR =
    407          	    (L2CC_CIPALR_TAG(Tag) | L2CC_CIPALR_IDX(Index) | L2CC_CIPALR_C);
    408          
    409          	while ((pL2CC->L2CC_CIPALR) & L2CC_CIPALR_C) ;
    410          }
    411          
    412          /**
    413           * \brief Invalidate cache by way
    414           * \param pL2CC Pointer to the L2CC peripheral.
    415           * \param Way  Way number
    416           */
    417          void
    418          L2CC_InvalidateWay(L2cc * pL2CC, uint8_t Way)
    419          {
    420          	pL2CC->L2CC_IWR = Way;
    421          
    422          	while (pL2CC->L2CC_IWR) ;
    423          	while (pL2CC->L2CC_CSR) ;
    424          
    425          }
    426          
    427          /**
    428           * \brief Clean cache by way
    429           * \param pL2CC Pointer to the L2CC peripheral.
    430           * \param Way  Way number
    431           */
    432          void
    433          L2CC_CleanWay(L2cc * pL2CC, uint8_t Way)
    434          {
    435          	pL2CC->L2CC_CWR = Way;
    436          
    437          	while (pL2CC->L2CC_CWR) ;
    438          	while (pL2CC->L2CC_CSR) ;
    439          
    440          }
    441          
    442          /**
    443           * \brief Clean Invalidate cache by way
    444           * \param pL2CC Pointer to the L2CC peripheral.
    445           * \param Way  Way number
    446           */
    447          static void
    448          L2CC_CleanInvalidateWay(L2cc * pL2CC, uint8_t Way)
    449          {
    450          	pL2CC->L2CC_CIWR = Way;
    451          
    452          	while (pL2CC->L2CC_CSR) ;
    453          
    454          }
    455          
    456          /**
    457           * \brief Clean cache by Index
    458           * \param pL2CC Pointer to the L2CC peripheral.
    459           * \param P_Address  Physical addresse
    460           * \param Way  Way number
    461           */
    462          void
    463          L2CC_CleanIndex(L2cc * pL2CC, uint32_t P_Address, uint8_t Way)
    464          {
    465          	static uint16_t Index;
    466          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
    467          
    468          	pL2CC->L2CC_CIR =
    469          	    (L2CC_CIR_IDX(Index) | L2CC_CIR_WAY(Way) | L2CC_CIR_C);
    470          
    471          	while ((pL2CC->L2CC_CIR) & L2CC_CIR_C) ;
    472          }
    473          
    474          /**
    475           * \brief Clean Invalidate cache by index
    476           * \param pL2CC Pointer to the L2CC peripheral.
    477           * \param P_Address  Physical address
    478           * \param Way  Way number
    479           */
    480          void
    481          L2CC_CleanInvalidateIndex(L2cc * pL2CC, uint32_t P_Address, uint8_t Way)
    482          {
    483          	static uint16_t Index;
    484          	Index = (P_Address >> OFFSET_BIT) & ((1 << INDEX_BIT) - 1);
    485          
    486          	pL2CC->L2CC_CIIR =
    487          	    (L2CC_CIIR_IDX(Index) | L2CC_CIIR_WAY(Index) | L2CC_CIIR_C);
    488          
    489          	while ((pL2CC->L2CC_CIIR) & L2CC_CIIR_C) ;
    490          }
    491          
    492          /**
    493           * \brief cache Data lockdown
    494           * \param pL2CC Pointer to the L2CC peripheral.
    495           * \param Way  Way number
    496           */
    497          void
    498          L2CC_DataLockdown(L2cc * pL2CC, uint8_t Way)
    499          {
    500          	pL2CC->L2CC_DLKR = Way;
    501          
    502          	while (pL2CC->L2CC_CSR) ;
    503          }
    504          
    505          /**
    506           * \brief cache instruction lockdown
    507           * \param pL2CC Pointer to the L2CC peripheral.
    508           * \param Way  Way number
    509           */
    510          void
    511          L2CC_InstructionLockdown(L2cc * pL2CC, uint8_t Way)
    512          {
    513          	pL2CC->L2CC_ILKR = Way;
    514          
    515          	while (pL2CC->L2CC_CSR) ;
    516          }
    517          
    518          static void
    519          L2CC_Clean(void)
    520          {
    521          	cp15_cache_clean(CP15_DCache);	// Clean of L1; This is broadcast within the cluster
    522          	L2CC_CleanWay(L2CC, 0xFF);	// forces the address out past level 2
    523          	L2CC_CacheSync(L2CC);	// Ensures completion of the L2 clean
    524          }
    525          
    526          static void
    527          L2CC_Invalidate(void)
    528          {
    529          	L2CC_InvalidateWay(L2CC, 0xFF);	// forces the address out past level 2
    530          	L2CC_CacheSync(L2CC);	// Ensures completion of the L2 inval
    531          	cp15_cache_invalidate(CP15_DCache);	// Inval of L1; This is broadcast within the cluster
    532          }
    533          
    534          static void
    535          L2CC_CleanInvalidate(void)
    536          {
    537          	cp15_cache_clean(CP15_DCache);	// Clean of L1; This is broadcast within the cluster
    538          	L2CC_CleanInvalidateWay(L2CC, 0xFF);	// forces the address out past level 2
    539          	L2CC_CacheSync(L2CC);	// Ensures completion of the L2 inval
    540          	cp15_cache_invalidate(CP15_DCache);	// Inval of L1; This is broadcast within the cluster
    541          }
    542          
    543          /**
    544           *  \brief L2 DCache maintenance (clean/invalidate/flush)
    545           */
    546          void
    547          L2CC_CacheMaintenance(uint8_t Maint_Op)
    548          {
    549          
    550          	switch (Maint_Op) {
    551          	case DCACHE_CLEAN:
    552          		L2CC_Clean();
    553          		break;
    554          	case DCACHE_INVAL:
    555          		L2CC_Invalidate();
    556          		break;
    557          	case DCACHE_FLUSH:
    558          		L2CC_CleanInvalidate();
    559          		break;
    560          	}
    561          }
    562          
    563          /**
    564           *  \brief Enable level two cache controller (L2CC)
    565           */
    566          void
    567          Enable_L2CC(void)
    568          {
    569          	L2CC_Control L2Config;
    570          	/*****1. configure L2CC ************/
    571          	L2Config.IPEN_Val = ENABLE;	// Instruction prefetch enable
    572          	L2Config.DPEN_Val = ENABLE;	// Data prefetch enable
    573          
    574          	L2Config.DLEN_Val = ENABLE;
    575          	L2Config.IDLEN_Val = ENABLE;
    576          	//L2Config.DWB_Val = ENABLE;        // Disable Write back (enables write through, Use this setting if DDR2 mem is not write-back)
    577          	L2Config.FWA_Val = FWA_NO_ALLOCATE;
    578          
    579          	L2Config.OFFSET_Val = 31;
    580          	L2Config.PDEN_Val = ENABLE;
    581          
    582          	L2Config.STBYEN_Val = ENABLE;
    583          	L2Config.DCKGATEN_Val = ENABLE;
    584          
    585          	L2CC_EventConfig(L2CC, 0, L2CC_ECFGR0_ESRC_SRC_DRHIT,
    586          			 L2CC_ECFGR0_EIGEN_INT_DIS);
    587          	L2CC_EventConfig(L2CC, 1, L2CC_ECFGR0_ESRC_SRC_DWHIT,
    588          			 L2CC_ECFGR0_EIGEN_INT_DIS);
    589          	L2CC_EnableResetCounter(L2CC, RESET_BOTH_COUNTER);
    590          
    591          	L2CC_Config(L2CC, L2Config);
    592          
    593          	/* Enable Prefetch */
    594          	L2CC_InstPrefetchEnable(L2CC);
    595          	L2CC_DataPrefetchEnable(L2CC);
    596          
    597          	/*2. Invalidate whole L2C     ********** */
    598          	L2CC_InvalidateWay(L2CC, 0xFF);
    599          	/*3. Disable all L2C Interrupt ********** */
    600          	L2CC_DisableIT(L2CC, 0x1FF);
    601          	/*4. Clear all L2C Interrupt ********** */
    602          	L2CC_ITClear(L2CC, 0);
    603          
    604          	L2CC_ExclusiveCache(L2CC, ENABLE);
    605          	L2CC_Enable(L2CC);
    606          }

Errors: 11
Warnings: 1
