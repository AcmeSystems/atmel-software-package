###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:07
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twid.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twid.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\twid.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\twid.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twid.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \file */
     31          
     32          /*----------------------------------------------------------------------------
     33           *        Headers
     34           *----------------------------------------------------------------------------*/
     35          
     36          #include "bus/twid.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp struct <unnamed> *get_twi_addr_from_id(uint32_t const)
   \                     get_twi_addr_from_id:
   \   00000000   0xE1B01000         MOVS     R1,R0
   \   00000004   0xE3510013         CMP      R1,#+19
   \   00000008   0x1A000001         BNE      ??get_twi_addr_from_id_0
   \   0000000C   0x........         LDR      R0,??DataTable9  ;; 0xf8034600
   \   00000010   0xEA00001A         B        ??get_twi_addr_from_id_1
   \                     ??get_twi_addr_from_id_0:
   \   00000014   0xE3510014         CMP      R1,#+20
   \   00000018   0x1A000001         BNE      ??get_twi_addr_from_id_2
   \   0000001C   0x........         LDR      R0,??DataTable9_1  ;; 0xf8038600
   \   00000020   0xEA000016         B        ??get_twi_addr_from_id_1
   \                     ??get_twi_addr_from_id_2:
   \   00000024   0xE3510015         CMP      R1,#+21
   \   00000028   0x1A000001         BNE      ??get_twi_addr_from_id_3
   \   0000002C   0x........         LDR      R0,??DataTable9_2  ;; 0xfc010600
   \   00000030   0xEA000012         B        ??get_twi_addr_from_id_1
   \                     ??get_twi_addr_from_id_3:
   \   00000034   0xE3510016         CMP      R1,#+22
   \   00000038   0x1A000001         BNE      ??get_twi_addr_from_id_4
   \   0000003C   0x........         LDR      R0,??DataTable9_3  ;; 0xfc014600
   \   00000040   0xEA00000E         B        ??get_twi_addr_from_id_1
   \                     ??get_twi_addr_from_id_4:
   \   00000044   0xE3510017         CMP      R1,#+23
   \   00000048   0x1A000001         BNE      ??get_twi_addr_from_id_5
   \   0000004C   0x........         LDR      R0,??DataTable9_4  ;; 0xfc018600
   \   00000050   0xEA00000A         B        ??get_twi_addr_from_id_1
   \                     ??get_twi_addr_from_id_5:
   \   00000054   0xE351001D         CMP      R1,#+29
   \   00000058   0x1A000002         BNE      ??get_twi_addr_from_id_6
   \   0000005C   0xE3A004F8         MOV      R0,#-134217728
   \   00000060   0xE3800BA0         ORR      R0,R0,#0x28000
   \   00000064   0xEA000005         B        ??get_twi_addr_from_id_1
   \                     ??get_twi_addr_from_id_6:
   \   00000068   0xE351001E         CMP      R1,#+30
   \   0000006C   0x1A000002         BNE      ??get_twi_addr_from_id_7
   \   00000070   0xE3A004FC         MOV      R0,#-67108864
   \   00000074   0xE3800BA0         ORR      R0,R0,#0x28000
   \   00000078   0xEA000000         B        ??get_twi_addr_from_id_1
   \                     ??get_twi_addr_from_id_7:
   \   0000007C   0xE3A00000         MOV      R0,#+0
   \                     ??get_twi_addr_from_id_1:
   \   00000080   0xE12FFF1E         BX       LR               ;; return
     37          #include "bus/xdmad.h"
     38          #include "utils/trace.h"
     39          #include "bus/xdma_hardware_interface.h"
     40          #include "core/cp15.h"
     41          
     42          #include <assert.h>
     43          
     44          /*----------------------------------------------------------------------------
     45           *        Definition
     46           *----------------------------------------------------------------------------*/
     47          #define TWITIMEOUTMAX 0xfffff
     48          

   \                                 In section .bss, align 4
     49          static sXdmad twi_dma;
   \                     twi_dma:
   \   00000000                      DS8 524

   \                                 In section .bss, align 4
     50          static sXdmadCfg twi_dmaCfg;
   \                     twi_dmaCfg:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
     51          static uint32_t dmaWriteChannel, dmaReadChannel;
   \                     dmaWriteChannel:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     dmaReadChannel:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     52          static LinkedListDescriporView1 dmaWriteLinkList[1];
   \                     dmaWriteLinkList:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     53          static LinkedListDescriporView1 dmaReadLinkList[1];
   \                     dmaReadLinkList:
   \   00000000                      DS8 16
     54          
     55          /*----------------------------------------------------------------------------
     56           *        Types
     57           *----------------------------------------------------------------------------*/
     58          
     59          /** TWI driver callback function.*/
     60          typedef void (*TwiCallback) (Async *);
     61          
     62          /** \brief TWI asynchronous transfer descriptor.*/
     63          struct _async_twi {
     64          	volatile uint32_t status;	/** Asynchronous transfer status. */
     65          	TwiCallback callback;		/** Callback function to invoke when transfer completes or fails.*/
     66          	uint8_t *pData;				/** Pointer to the data buffer.*/
     67          	uint32_t num;				/** Total number of bytes to transfer.*/
     68          	uint32_t transferred; 		/** Number of already transferred bytes.*/
     69          };
     70          
     71          //struct _async_twi async_twi ;
     72          
     73          /*----------------------------------------------------------------------------
     74           *        Global functions
     75           *----------------------------------------------------------------------------*/
     76          
     77          /**
     78           * \brief Initializes a TWI DMA Read channel.
     79           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     80          static void twid_dma_initialize_read(uint8_t TWI_ID)
     81          {
   \                     twid_dma_initialize_read:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     82          	/* Allocate a XDMA channel, Read accesses into TWI_THR */
     83          	dmaReadChannel =  XDMAD_AllocateChannel(&twi_dma, TWI_ID, XDMAD_TRANSFER_MEMORY);
   \   00000008   0xE3A020FF         MOV      R2,#+255
   \   0000000C   0xE1B01004         MOVS     R1,R4
   \   00000010   0xE6EF1071         UXTB     R1,R1
   \   00000014   0x........         LDR      R0,??DataTable9_5
   \   00000018   0x........         BL       XDMAD_AllocateChannel
   \   0000001C   0x........         LDR      R1,??DataTable9_6
   \   00000020   0xE5810000         STR      R0,[R1, #+0]
     84          	if (dmaReadChannel == XDMAD_ALLOC_FAILED) {
   \   00000024   0x........         LDR      R0,??DataTable9_6
   \   00000028   0xE5900000         LDR      R0,[R0, #+0]
   \   0000002C   0xE3A010FF         MOV      R1,#+255
   \   00000030   0xE3811CFF         ORR      R1,R1,#0xFF00
   \   00000034   0xE1500001         CMP      R0,R1
   \   00000038   0x1A000001         BNE      ??twid_dma_initialize_read_0
     85          		printf("-E- Can't allocate XDMA channel\n\r");
   \   0000003C   0x........         LDR      R0,??DataTable9_7
   \   00000040   0x........         BL       printf
     86          	}
     87          	XDMAD_PrepareChannel(&twi_dma, dmaReadChannel);
   \                     ??twid_dma_initialize_read_0:
   \   00000044   0x........         LDR      R0,??DataTable9_6
   \   00000048   0xE5901000         LDR      R1,[R0, #+0]
   \   0000004C   0x........         LDR      R0,??DataTable9_5
   \   00000050   0x........         BL       XDMAD_PrepareChannel
     88          }
   \   00000054   0xE8BD8010         POP      {R4,PC}          ;; return
     89          
     90          /**
     91           * \brief Initializes a TWI DMA write channel.
     92           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     93          static void twid_dma_initialize_write(uint8_t TWI_ID)
     94          {
   \                     twid_dma_initialize_write:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     95          
     96          	/* Allocate a XDMA channel, Write accesses into TWI_THR */
     97          	dmaWriteChannel = XDMAD_AllocateChannel(&twi_dma, XDMAD_TRANSFER_MEMORY, TWI_ID);
   \   00000008   0xE1B02004         MOVS     R2,R4
   \   0000000C   0xE6EF2072         UXTB     R2,R2
   \   00000010   0xE3A010FF         MOV      R1,#+255
   \   00000014   0x........         LDR      R0,??DataTable9_5
   \   00000018   0x........         BL       XDMAD_AllocateChannel
   \   0000001C   0x........         LDR      R1,??DataTable9_8
   \   00000020   0xE5810000         STR      R0,[R1, #+0]
     98          	if (dmaWriteChannel == XDMAD_ALLOC_FAILED) {
   \   00000024   0x........         LDR      R0,??DataTable9_8
   \   00000028   0xE5900000         LDR      R0,[R0, #+0]
   \   0000002C   0xE3A010FF         MOV      R1,#+255
   \   00000030   0xE3811CFF         ORR      R1,R1,#0xFF00
   \   00000034   0xE1500001         CMP      R0,R1
   \   00000038   0x1A000001         BNE      ??twid_dma_initialize_write_0
     99          		printf("-E- Can't allocate XDMA channel\n\r");
   \   0000003C   0x........         LDR      R0,??DataTable9_7
   \   00000040   0x........         BL       printf
    100          	}
    101          	XDMAD_PrepareChannel(&twi_dma, dmaWriteChannel);
   \                     ??twid_dma_initialize_write_0:
   \   00000044   0x........         LDR      R0,??DataTable9_8
   \   00000048   0xE5901000         LDR      R1,[R0, #+0]
   \   0000004C   0x........         LDR      R0,??DataTable9_5
   \   00000050   0x........         BL       XDMAD_PrepareChannel
    102          
    103          }
   \   00000054   0xE8BD8010         POP      {R4,PC}          ;; return
    104          
    105          /**
    106           * \brief Initializes a TWI driver instance, using the given TWI peripheral.
    107           * \note The peripheral must have been initialized properly before calling this function.
    108           * \param pTwid  Pointer to the Twid instance to initialize.
    109           * \param pTwi  Pointer to the TWI peripheral to use.
    110           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    111          void twid_initialize(struct _twid* pTwid, Twi * pTwi)
    112          {
   \                     twid_initialize:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    113          	TRACE_DEBUG("twid_initialize()\n\r");
    114          	assert(pTwid != NULL);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000004         BNE      ??twid_initialize_0
   \   00000014   0xE3A02072         MOV      R2,#+114
   \   00000018   0x........         LDR      R1,??DataTable9_9
   \   0000001C   0x........         LDR      R0,??DataTable9_10
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    115          	assert(pTwi != NULL);
   \                     ??twid_initialize_0:
   \   00000028   0xE3550000         CMP      R5,#+0
   \   0000002C   0x1A000004         BNE      ??twid_initialize_1
   \   00000030   0xE3A02073         MOV      R2,#+115
   \   00000034   0x........         LDR      R1,??DataTable9_9
   \   00000038   0x........         LDR      R0,??DataTable9_11
   \   0000003C   0x........         BL       __aeabi_assert
   \   00000040   0x........         BL       __iar_EmptyStepPoint
    116          
    117          	/* Initialize driver. */
    118          	pTwid->pTwi = pTwi;
   \                     ??twid_initialize_1:
   \   00000044   0xE5845000         STR      R5,[R4, #+0]
    119          	pTwid->pTransfer = 0;
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xE5840004         STR      R0,[R4, #+4]
    120          	/* Initialize XDMA driver instance with polling mode */
    121          	XDMAD_Initialize(&twi_dma, 1);
   \   00000050   0xE3A01001         MOV      R1,#+1
   \   00000054   0x........         LDR      R0,??DataTable9_5
   \   00000058   0x........         BL       XDMAD_Initialize
    122          }
   \   0000005C   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    123          
    124          /**
    125           * \brief Configure xDMA write linker list for TWI transfer.
    126           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    127          static void _xdma_configure_write(uint8_t * buf, uint32_t len, uint8_t twi_id)
    128          {
   \                     _xdma_configure_write:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE24DD008         SUB      SP,SP,#+8
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05001         MOVS     R5,R1
   \   00000010   0xE1B06002         MOVS     R6,R2
    129          	uint32_t i;
    130          	uint32_t xdmaCndc, Thr;
    131          	Twi* twi = (Twi*)get_twi_addr_from_id(twi_id);
   \   00000014   0xE1B00006         MOVS     R0,R6
   \   00000018   0xE6EF0070         UXTB     R0,R0
   \   0000001C   0x........         BL       get_twi_addr_from_id
   \   00000020   0xE1B0A000         MOVS     R10,R0
    132          
    133          	Thr = (uint32_t) & (TWI0->TWI_THR);
   \   00000024   0x........         LDR      R0,??DataTable9_12  ;; 0xf8034634
   \   00000028   0xE1B09000         MOVS     R9,R0
    134          	if (twi)
   \   0000002C   0xE35A0000         CMP      R10,#+0
   \   00000030   0x0A000001         BEQ      ??_xdma_configure_write_0
    135          		Thr = (uint32_t) & (twi->TWI_THR);
   \   00000034   0xE29A0034         ADDS     R0,R10,#+52
   \   00000038   0xE1B09000         MOVS     R9,R0
    136          	for (i = 0; i < 1; i++) {
   \                     ??_xdma_configure_write_0:
   \   0000003C   0xE3A00000         MOV      R0,#+0
   \   00000040   0xE1B07000         MOVS     R7,R0
   \                     ??_xdma_configure_write_1:
   \   00000044   0xE3570000         CMP      R7,#+0
   \   00000048   0x1A000025         BNE      ??_xdma_configure_write_2
    137          		dmaWriteLinkList[i].mbr_ubc = XDMA_UBC_NVIEW_NDV1
    138          		    | ((i == len - 1) ? 0 : XDMA_UBC_NDE_FETCH_EN)
    139          		    | len;
   \   0000004C   0xE2550001         SUBS     R0,R5,#+1
   \   00000050   0xE1570000         CMP      R7,R0
   \   00000054   0x1A000001         BNE      ??_xdma_configure_write_3
   \   00000058   0xE3A00000         MOV      R0,#+0
   \   0000005C   0xEA000000         B        ??_xdma_configure_write_4
   \                     ??_xdma_configure_write_3:
   \   00000060   0xE3A00740         MOV      R0,#+16777216
   \                     ??_xdma_configure_write_4:
   \   00000064   0xE1950000         ORRS     R0,R5,R0
   \   00000068   0xE3900680         ORRS     R0,R0,#0x8000000
   \   0000006C   0x........         LDR      R1,??DataTable9_13
   \   00000070   0xE1B02207         LSLS     R2,R7,#+4
   \   00000074   0xE0921001         ADDS     R1,R2,R1
   \   00000078   0xE5810004         STR      R0,[R1, #+4]
    140          		dmaWriteLinkList[i].mbr_sa = (uint32_t) & buf[i];
   \   0000007C   0xE0970004         ADDS     R0,R7,R4
   \   00000080   0x........         LDR      R1,??DataTable9_13
   \   00000084   0xE1B02207         LSLS     R2,R7,#+4
   \   00000088   0xE0921001         ADDS     R1,R2,R1
   \   0000008C   0xE5810008         STR      R0,[R1, #+8]
    141          		dmaWriteLinkList[i].mbr_da = Thr;
   \   00000090   0x........         LDR      R0,??DataTable9_13
   \   00000094   0xE1B01207         LSLS     R1,R7,#+4
   \   00000098   0xE0910000         ADDS     R0,R1,R0
   \   0000009C   0xE580900C         STR      R9,[R0, #+12]
    142          		if (i == len - 1)
   \   000000A0   0xE2550001         SUBS     R0,R5,#+1
   \   000000A4   0xE1570000         CMP      R7,R0
   \   000000A8   0x1A000004         BNE      ??_xdma_configure_write_5
    143          			dmaWriteLinkList[i].mbr_nda = 0;
   \   000000AC   0xE3A00000         MOV      R0,#+0
   \   000000B0   0x........         LDR      R1,??DataTable9_13
   \   000000B4   0xE1B02207         LSLS     R2,R7,#+4
   \   000000B8   0xE7820001         STR      R0,[R2, +R1]
   \   000000BC   0xEA000006         B        ??_xdma_configure_write_6
    144          		else
    145          			dmaWriteLinkList[i].mbr_nda =
    146          			    (uint32_t) & dmaWriteLinkList[i + 1];
   \                     ??_xdma_configure_write_5:
   \   000000C0   0x........         LDR      R0,??DataTable9_13
   \   000000C4   0xE1B01207         LSLS     R1,R7,#+4
   \   000000C8   0xE0910000         ADDS     R0,R1,R0
   \   000000CC   0xE2900010         ADDS     R0,R0,#+16
   \   000000D0   0x........         LDR      R1,??DataTable9_13
   \   000000D4   0xE1B02207         LSLS     R2,R7,#+4
   \   000000D8   0xE7820001         STR      R0,[R2, +R1]
    147          	}
   \                     ??_xdma_configure_write_6:
   \   000000DC   0xE2977001         ADDS     R7,R7,#+1
   \   000000E0   0xEAFFFFD7         B        ??_xdma_configure_write_1
    148          	twi_dmaCfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN
    149          	    | XDMAC_CC_MBSIZE_SINGLE
    150          	    | XDMAC_CC_DSYNC_MEM2PER
    151          	    | XDMAC_CC_CSIZE_CHK_1
    152          	    | XDMAC_CC_DWIDTH_BYTE
    153          	    | XDMAC_CC_SIF_AHB_IF0
    154          	    | XDMAC_CC_DIF_AHB_IF1
    155          	    | XDMAC_CC_SAM_INCREMENTED_AM
    156          	    | XDMAC_CC_DAM_FIXED_AM
    157          	    |
    158          	    XDMAC_CC_PERID(XDMAIF_Get_ChannelNumber
    159          			   (0, twi_id, XDMAD_TRANSFER_TX));
   \                     ??_xdma_configure_write_2:
   \   000000E4   0xE3A02000         MOV      R2,#+0
   \   000000E8   0xE1B01006         MOVS     R1,R6
   \   000000EC   0xE6EF1071         UXTB     R1,R1
   \   000000F0   0xE3A00000         MOV      R0,#+0
   \   000000F4   0x........         BL       XDMAIF_Get_ChannelNumber
   \   000000F8   0xE3A0147F         MOV      R1,#+2130706432
   \   000000FC   0xE0110C00         ANDS     R0,R1,R0, LSL #+24
   \   00000100   0xE3A01011         MOV      R1,#+17
   \   00000104   0xE3811B50         ORR      R1,R1,#0x14000
   \   00000108   0xE1910000         ORRS     R0,R1,R0
   \   0000010C   0x........         LDR      R1,??DataTable10
   \   00000110   0xE581000C         STR      R0,[R1, #+12]
    160          	xdmaCndc =
    161          	    XDMAC_CNDC_NDVIEW_NDV1 | XDMAC_CNDC_NDE_DSCR_FETCH_EN |
    162          	    XDMAC_CNDC_NDSUP_SRC_PARAMS_UPDATED |
    163          	    XDMAC_CNDC_NDDUP_DST_PARAMS_UNCHANGED;
   \   00000114   0xE3A0000B         MOV      R0,#+11
   \   00000118   0xE1B08000         MOVS     R8,R0
    164          	cp15_coherent_dcache_for_dma((uint32_t) & dmaWriteLinkList,
    165          				     ((uint32_t) & dmaWriteLinkList +
    166          				      sizeof (LinkedListDescriporView1) * len));
   \   0000011C   0x........         LDR      R0,??DataTable9_13
   \   00000120   0xE3A02010         MOV      R2,#+16
   \   00000124   0xE0210592         MLA      R1,R2,R5,R0
   \   00000128   0x........         LDR      R0,??DataTable9_13
   \   0000012C   0x........         BL       cp15_coherent_dcache_for_dma
    167          	XDMAD_ConfigureTransfer(&twi_dma, dmaWriteChannel, &twi_dmaCfg,
    168          				xdmaCndc, (uint32_t) & dmaWriteLinkList[0]);
   \   00000130   0x........         LDR      R0,??DataTable9_13
   \   00000134   0xE58D0000         STR      R0,[SP, #+0]
   \   00000138   0xE1B03008         MOVS     R3,R8
   \   0000013C   0x........         LDR      R2,??DataTable10
   \   00000140   0x........         LDR      R0,??DataTable9_8
   \   00000144   0xE5901000         LDR      R1,[R0, #+0]
   \   00000148   0x........         LDR      R0,??DataTable9_5
   \   0000014C   0x........         BL       XDMAD_ConfigureTransfer
    169          }
   \   00000150   0xE8BD87F3         POP      {R0,R1,R4-R10,PC}  ;; return
    170          
    171          /**
    172           * \brief Configure xDMA read linker list for TWI transfer.
    173           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    174          static void _xdma_configure_read(uint8_t * buf, uint32_t len, uint8_t twi_id)
    175          {
   \                     _xdma_configure_read:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE24DD008         SUB      SP,SP,#+8
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05001         MOVS     R5,R1
   \   00000010   0xE1B06002         MOVS     R6,R2
    176          	uint32_t i;
    177          	uint32_t xdmaCndc, Rhr;
    178          	Twi* twi = get_twi_addr_from_id(twi_id);
   \   00000014   0xE1B00006         MOVS     R0,R6
   \   00000018   0xE6EF0070         UXTB     R0,R0
   \   0000001C   0x........         BL       get_twi_addr_from_id
   \   00000020   0xE1B0A000         MOVS     R10,R0
    179          
    180          	Rhr = (uint32_t) & (TWI0->TWI_RHR);
   \   00000024   0x........         LDR      R0,??DataTable10_1  ;; 0xf8034630
   \   00000028   0xE1B09000         MOVS     R9,R0
    181          	if (twi) {
   \   0000002C   0xE35A0000         CMP      R10,#+0
   \   00000030   0x0A000001         BEQ      ??_xdma_configure_read_0
    182          		Rhr = twi->TWI_RHR;
   \   00000034   0xE59A0030         LDR      R0,[R10, #+48]
   \   00000038   0xE1B09000         MOVS     R9,R0
    183          	}
    184          	/* if (twi_id == ID_TWI1) { */
    185          	/* 	Rhr = (uint32_t) & (TWI1->TWI_RHR); */
    186          	/* } */
    187          	/* if (twi_id == ID_TWI2) { */
    188          	/* 	Rhr = (uint32_t) & (TWI2->TWI_RHR); */
    189          	/* } */
    190          	for (i = 0; i < 1; i++) {
   \                     ??_xdma_configure_read_0:
   \   0000003C   0xE3A00000         MOV      R0,#+0
   \   00000040   0xE1B07000         MOVS     R7,R0
   \                     ??_xdma_configure_read_1:
   \   00000044   0xE3570000         CMP      R7,#+0
   \   00000048   0x1A000025         BNE      ??_xdma_configure_read_2
    191          		dmaReadLinkList[i].mbr_ubc = XDMA_UBC_NVIEW_NDV1
    192          		    | ((i == len - 1) ? 0 : XDMA_UBC_NDE_FETCH_EN)
    193          		    | len;
   \   0000004C   0xE2550001         SUBS     R0,R5,#+1
   \   00000050   0xE1570000         CMP      R7,R0
   \   00000054   0x1A000001         BNE      ??_xdma_configure_read_3
   \   00000058   0xE3A00000         MOV      R0,#+0
   \   0000005C   0xEA000000         B        ??_xdma_configure_read_4
   \                     ??_xdma_configure_read_3:
   \   00000060   0xE3A00740         MOV      R0,#+16777216
   \                     ??_xdma_configure_read_4:
   \   00000064   0xE1950000         ORRS     R0,R5,R0
   \   00000068   0xE3900680         ORRS     R0,R0,#0x8000000
   \   0000006C   0x........         LDR      R1,??DataTable10_2
   \   00000070   0xE1B02207         LSLS     R2,R7,#+4
   \   00000074   0xE0921001         ADDS     R1,R2,R1
   \   00000078   0xE5810004         STR      R0,[R1, #+4]
    194          		dmaReadLinkList[i].mbr_sa = Rhr;
   \   0000007C   0x........         LDR      R0,??DataTable10_2
   \   00000080   0xE1B01207         LSLS     R1,R7,#+4
   \   00000084   0xE0910000         ADDS     R0,R1,R0
   \   00000088   0xE5809008         STR      R9,[R0, #+8]
    195          		dmaReadLinkList[i].mbr_da = (uint32_t) & buf[i];
   \   0000008C   0xE0970004         ADDS     R0,R7,R4
   \   00000090   0x........         LDR      R1,??DataTable10_2
   \   00000094   0xE1B02207         LSLS     R2,R7,#+4
   \   00000098   0xE0921001         ADDS     R1,R2,R1
   \   0000009C   0xE581000C         STR      R0,[R1, #+12]
    196          		if (i == len - 1)
   \   000000A0   0xE2550001         SUBS     R0,R5,#+1
   \   000000A4   0xE1570000         CMP      R7,R0
   \   000000A8   0x1A000004         BNE      ??_xdma_configure_read_5
    197          			dmaReadLinkList[i].mbr_nda = 0;
   \   000000AC   0xE3A00000         MOV      R0,#+0
   \   000000B0   0x........         LDR      R1,??DataTable10_2
   \   000000B4   0xE1B02207         LSLS     R2,R7,#+4
   \   000000B8   0xE7820001         STR      R0,[R2, +R1]
   \   000000BC   0xEA000006         B        ??_xdma_configure_read_6
    198          		else
    199          			dmaReadLinkList[i].mbr_nda =
    200          			    (uint32_t) & dmaReadLinkList[i + 1];
   \                     ??_xdma_configure_read_5:
   \   000000C0   0x........         LDR      R0,??DataTable10_2
   \   000000C4   0xE1B01207         LSLS     R1,R7,#+4
   \   000000C8   0xE0910000         ADDS     R0,R1,R0
   \   000000CC   0xE2900010         ADDS     R0,R0,#+16
   \   000000D0   0x........         LDR      R1,??DataTable10_2
   \   000000D4   0xE1B02207         LSLS     R2,R7,#+4
   \   000000D8   0xE7820001         STR      R0,[R2, +R1]
    201          	}
   \                     ??_xdma_configure_read_6:
   \   000000DC   0xE2977001         ADDS     R7,R7,#+1
   \   000000E0   0xEAFFFFD7         B        ??_xdma_configure_read_1
    202          	twi_dmaCfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN
    203          	    | XDMAC_CC_MBSIZE_SINGLE
    204          	    | XDMAC_CC_DSYNC_PER2MEM
    205          	    | XDMAC_CC_CSIZE_CHK_1
    206          	    | XDMAC_CC_DWIDTH_BYTE
    207          	    | XDMAC_CC_SIF_AHB_IF1
    208          	    | XDMAC_CC_DIF_AHB_IF0
    209          	    | XDMAC_CC_SAM_FIXED_AM
    210          	    | XDMAC_CC_DAM_INCREMENTED_AM
    211          	    |
    212          	    XDMAC_CC_PERID(XDMAIF_Get_ChannelNumber
    213          			   (0, twi_id, XDMAD_TRANSFER_RX));
   \                     ??_xdma_configure_read_2:
   \   000000E4   0xE3A02001         MOV      R2,#+1
   \   000000E8   0xE1B01006         MOVS     R1,R6
   \   000000EC   0xE6EF1071         UXTB     R1,R1
   \   000000F0   0xE3A00000         MOV      R0,#+0
   \   000000F4   0x........         BL       XDMAIF_Get_ChannelNumber
   \   000000F8   0xE3A0147F         MOV      R1,#+2130706432
   \   000000FC   0xE0110C00         ANDS     R0,R1,R0, LSL #+24
   \   00000100   0xE3A01001         MOV      R1,#+1
   \   00000104   0xE3811A42         ORR      R1,R1,#0x42000
   \   00000108   0xE1910000         ORRS     R0,R1,R0
   \   0000010C   0x........         LDR      R1,??DataTable10
   \   00000110   0xE581000C         STR      R0,[R1, #+12]
    214          	xdmaCndc =
    215          	    XDMAC_CNDC_NDVIEW_NDV1 | XDMAC_CNDC_NDE_DSCR_FETCH_EN |
    216          	    XDMAC_CNDC_NDSUP_SRC_PARAMS_UPDATED |
    217          	    XDMAC_CNDC_NDDUP_DST_PARAMS_UPDATED;
   \   00000114   0xE3A0000F         MOV      R0,#+15
   \   00000118   0xE1B08000         MOVS     R8,R0
    218          	cp15_coherent_dcache_for_dma((uint32_t) & dmaReadLinkList,
    219          				     ((uint32_t) & dmaReadLinkList +
    220          				      sizeof (LinkedListDescriporView1) * len));
   \   0000011C   0x........         LDR      R0,??DataTable10_2
   \   00000120   0xE3A02010         MOV      R2,#+16
   \   00000124   0xE0210592         MLA      R1,R2,R5,R0
   \   00000128   0x........         LDR      R0,??DataTable10_2
   \   0000012C   0x........         BL       cp15_coherent_dcache_for_dma
    221          	XDMAD_ConfigureTransfer(&twi_dma, dmaReadChannel, &twi_dmaCfg, xdmaCndc,
    222          				(uint32_t) & dmaReadLinkList[0]);
   \   00000130   0x........         LDR      R0,??DataTable10_2
   \   00000134   0xE58D0000         STR      R0,[SP, #+0]
   \   00000138   0xE1B03008         MOVS     R3,R8
   \   0000013C   0x........         LDR      R2,??DataTable10
   \   00000140   0x........         LDR      R0,??DataTable9_6
   \   00000144   0xE5901000         LDR      R1,[R0, #+0]
   \   00000148   0x........         LDR      R0,??DataTable9_5
   \   0000014C   0x........         BL       XDMAD_ConfigureTransfer
    223          }
   \   00000150   0xE8BD87F3         POP      {R0,R1,R4-R10,PC}  ;; return
    224          
    225          /**
    226           * \brief Interrupt handler for a TWI peripheral. Manages asynchronous transfer
    227           * occuring on the bus. This function MUST be called by the interrupt service
    228           * routine of the TWI peripheral if asynchronous read/write are needed.
    229            * \param pTwid  Pointer to a Twid instance.
    230           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    231          void twid_handler(struct _twid* pTwid)
    232          {
   \                     twid_handler:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    233          	uint32_t status;
    234          	struct _async_twi* pTransfer;
    235          	Twi *pTwi;
    236          
    237          	assert(pTwid != NULL);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000004         BNE      ??twid_handler_0
   \   00000010   0xE3A020ED         MOV      R2,#+237
   \   00000014   0x........         LDR      R1,??DataTable9_9
   \   00000018   0x........         LDR      R0,??DataTable9_10
   \   0000001C   0x........         BL       __aeabi_assert
   \   00000020   0x........         BL       __iar_EmptyStepPoint
    238          
    239          	pTransfer = (struct _async_twi *) pTwid->pTransfer;
   \                     ??twid_handler_0:
   \   00000024   0xE5940004         LDR      R0,[R4, #+4]
   \   00000028   0xE1B06000         MOVS     R6,R0
    240          	assert(pTransfer != NULL);
   \   0000002C   0xE3560000         CMP      R6,#+0
   \   00000030   0x1A000004         BNE      ??twid_handler_1
   \   00000034   0xE3A020F0         MOV      R2,#+240
   \   00000038   0x........         LDR      R1,??DataTable9_9
   \   0000003C   0x........         LDR      R0,??DataTable10_3
   \   00000040   0x........         BL       __aeabi_assert
   \   00000044   0x........         BL       __iar_EmptyStepPoint
    241          	pTwi = pTwid->pTwi;
   \                     ??twid_handler_1:
   \   00000048   0xE5940000         LDR      R0,[R4, #+0]
   \   0000004C   0xE1B07000         MOVS     R7,R0
    242          	assert(pTwi != NULL);
   \   00000050   0xE3570000         CMP      R7,#+0
   \   00000054   0x1A000004         BNE      ??twid_handler_2
   \   00000058   0xE3A020F2         MOV      R2,#+242
   \   0000005C   0x........         LDR      R1,??DataTable9_9
   \   00000060   0x........         LDR      R0,??DataTable10_4
   \   00000064   0x........         BL       __aeabi_assert
   \   00000068   0x........         BL       __iar_EmptyStepPoint
    243          
    244          	/* Retrieve interrupt status */
    245          	status = twi_get_masked_status(pTwi);
   \                     ??twid_handler_2:
   \   0000006C   0xE1B00007         MOVS     R0,R7
   \   00000070   0x........         BL       twi_get_masked_status
   \   00000074   0xE1B05000         MOVS     R5,R0
    246          
    247          	/* Byte received */
    248          	if (TWI_STATUS_RXRDY(status)) {
   \   00000078   0xE3150002         TST      R5,#0x2
   \   0000007C   0x0A00001A         BEQ      ??twid_handler_3
    249          
    250          		pTransfer->pData[pTransfer->transferred] = twi_read_byte(pTwi);
   \   00000080   0xE1B00007         MOVS     R0,R7
   \   00000084   0x........         BL       twi_read_byte
   \   00000088   0xE5961008         LDR      R1,[R6, #+8]
   \   0000008C   0xE5962010         LDR      R2,[R6, #+16]
   \   00000090   0xE7C20001         STRB     R0,[R2, +R1]
    251          		pTransfer->transferred++;
   \   00000094   0xE5960010         LDR      R0,[R6, #+16]
   \   00000098   0xE2900001         ADDS     R0,R0,#+1
   \   0000009C   0xE5860010         STR      R0,[R6, #+16]
    252          
    253          		/* check for transfer finish */
    254          		if (pTransfer->transferred == pTransfer->num) {
   \   000000A0   0xE5960010         LDR      R0,[R6, #+16]
   \   000000A4   0xE596100C         LDR      R1,[R6, #+12]
   \   000000A8   0xE1500001         CMP      R0,R1
   \   000000AC   0x1A000006         BNE      ??twid_handler_4
    255          
    256          			twi_enable_it(pTwi, TWI_IDR_RXRDY);
   \   000000B0   0xE3A01002         MOV      R1,#+2
   \   000000B4   0xE1B00007         MOVS     R0,R7
   \   000000B8   0x........         BL       twi_enable_it
    257          			twi_enable_it(pTwi, TWI_IER_TXCOMP);
   \   000000BC   0xE3A01001         MOV      R1,#+1
   \   000000C0   0xE1B00007         MOVS     R0,R7
   \   000000C4   0x........         BL       twi_enable_it
   \   000000C8   0xEA00002E         B        ??twid_handler_5
    258          		}
    259          		/* Last byte? */
    260          		else if (pTransfer->transferred == (pTransfer->num - 1)) {
   \                     ??twid_handler_4:
   \   000000CC   0xE5960010         LDR      R0,[R6, #+16]
   \   000000D0   0xE596100C         LDR      R1,[R6, #+12]
   \   000000D4   0xE2511001         SUBS     R1,R1,#+1
   \   000000D8   0xE1500001         CMP      R0,R1
   \   000000DC   0x1A000029         BNE      ??twid_handler_5
    261          
    262          			twi_stop(pTwi);
   \   000000E0   0xE1B00007         MOVS     R0,R7
   \   000000E4   0x........         BL       twi_stop
   \   000000E8   0xEA000026         B        ??twid_handler_5
    263          		}
    264          	}
    265          	/* Byte sent */
    266          	else if (TWI_STATUS_TXRDY(status)) {
   \                     ??twid_handler_3:
   \   000000EC   0xE3150004         TST      R5,#0x4
   \   000000F0   0x0A000015         BEQ      ??twid_handler_6
    267          
    268          		/* Transfer finished ? */
    269          		if (pTransfer->transferred == pTransfer->num) {
   \   000000F4   0xE5960010         LDR      R0,[R6, #+16]
   \   000000F8   0xE596100C         LDR      R1,[R6, #+12]
   \   000000FC   0xE1500001         CMP      R0,R1
   \   00000100   0x1A000008         BNE      ??twid_handler_7
    270          
    271          			twi_enable_it(pTwi, TWI_IDR_TXRDY);
   \   00000104   0xE3A01004         MOV      R1,#+4
   \   00000108   0xE1B00007         MOVS     R0,R7
   \   0000010C   0x........         BL       twi_enable_it
    272          			twi_enable_it(pTwi, TWI_IER_TXCOMP);
   \   00000110   0xE3A01001         MOV      R1,#+1
   \   00000114   0xE1B00007         MOVS     R0,R7
   \   00000118   0x........         BL       twi_enable_it
    273          			twi_send_stop_condition(pTwi);
   \   0000011C   0xE1B00007         MOVS     R0,R7
   \   00000120   0x........         BL       twi_send_stop_condition
   \   00000124   0xEA000017         B        ??twid_handler_5
    274          		}
    275          		/* Bytes remaining */
    276          		else {
    277          
    278          			twi_write_byte(pTwi,
    279          				      pTransfer->pData[pTransfer->transferred]);
   \                     ??twid_handler_7:
   \   00000128   0xE5960008         LDR      R0,[R6, #+8]
   \   0000012C   0xE5961010         LDR      R1,[R6, #+16]
   \   00000130   0xE7D11000         LDRB     R1,[R1, +R0]
   \   00000134   0xE1B00007         MOVS     R0,R7
   \   00000138   0x........         BL       twi_write_byte
    280          			pTransfer->transferred++;
   \   0000013C   0xE5960010         LDR      R0,[R6, #+16]
   \   00000140   0xE2900001         ADDS     R0,R0,#+1
   \   00000144   0xE5860010         STR      R0,[R6, #+16]
   \   00000148   0xEA00000E         B        ??twid_handler_5
    281          		}
    282          	}
    283          	/* Transfer complete */
    284          	else if (TWI_STATUS_TXCOMP(status)) {
   \                     ??twid_handler_6:
   \   0000014C   0xE3150001         TST      R5,#0x1
   \   00000150   0x0A00000C         BEQ      ??twid_handler_5
    285          
    286          		twi_enable_it(pTwi, TWI_IDR_TXCOMP);
   \   00000154   0xE3A01001         MOV      R1,#+1
   \   00000158   0xE1B00007         MOVS     R0,R7
   \   0000015C   0x........         BL       twi_enable_it
    287          		pTransfer->status = 0;
   \   00000160   0xE3A00000         MOV      R0,#+0
   \   00000164   0xE5860000         STR      R0,[R6, #+0]
    288          		if (pTransfer->callback) {
   \   00000168   0xE5960004         LDR      R0,[R6, #+4]
   \   0000016C   0xE3500000         CMP      R0,#+0
   \   00000170   0x0A000002         BEQ      ??twid_handler_8
    289          			pTransfer->callback((Async *) (void *) pTransfer);
   \   00000174   0xE1B00006         MOVS     R0,R6
   \   00000178   0xE5961004         LDR      R1,[R6, #+4]
   \   0000017C   0xE12FFF31         BLX      R1
    290          		}
    291          		pTwid->pTransfer = 0;
   \                     ??twid_handler_8:
   \   00000180   0xE3A00000         MOV      R0,#+0
   \   00000184   0xE5840004         STR      R0,[R4, #+4]
    292          	}
    293          }
   \                     ??twid_handler_5:
   \   00000188   0xE8BD80F1         POP      {R0,R4-R7,PC}    ;; return
    294          
    295          /**
    296           * \brief Asynchronously reads data from a slave on the TWI bus. An optional
    297           * callback function is triggered when the transfer is complete.
    298           * \param pTwid  Pointer to a Twid instance.
    299           * \param address  TWI slave address.
    300           * \param iaddress  Optional slave internal address.
    301           * \param isize  Internal address size in bytes.
    302           * \param pData  Data buffer for storing received bytes.
    303           * \param num  Number of bytes to read.
    304           * \param pAsync  Asynchronous transfer descriptor.
    305           * \return 0 if the transfer has been started; otherwise returns a TWI error code.
    306           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    307          uint8_t twid_read(struct _twid* pTwid, uint8_t address,  uint32_t iaddress,
    308          	  uint8_t isize, uint8_t * pData, uint32_t num, Async * pAsync)
    309          {
   \                     twid_read:
   \   00000000   0xE92D4FFF         PUSH     {R0-R11,LR}
   \   00000004   0xE24DD004         SUB      SP,SP,#+4
   \   00000008   0xE59D4038         LDR      R4,[SP, #+56]
   \   0000000C   0xE59D503C         LDR      R5,[SP, #+60]
   \   00000010   0xE59D6040         LDR      R6,[SP, #+64]
    310          	Twi *pTwi;
    311          	struct _async_twi* pTransfer;
    312          	uint32_t timeout = 0;
   \   00000014   0xE3A09000         MOV      R9,#+0
    313          	uint32_t i = 0;
   \   00000018   0xE3A0A000         MOV      R10,#+0
    314          	uint32_t status;
    315          
    316          	assert(pTwid != NULL);
   \   0000001C   0xE59D0004         LDR      R0,[SP, #+4]
   \   00000020   0xE3500000         CMP      R0,#+0
   \   00000024   0x1A000004         BNE      ??twid_read_0
   \   00000028   0xE3A02F4F         MOV      R2,#+316
   \   0000002C   0x........         LDR      R1,??DataTable9_9
   \   00000030   0x........         LDR      R0,??DataTable9_10
   \   00000034   0x........         BL       __aeabi_assert
   \   00000038   0x........         BL       __iar_EmptyStepPoint
    317          	pTwi = pTwid->pTwi;
   \                     ??twid_read_0:
   \   0000003C   0xE59D0004         LDR      R0,[SP, #+4]
   \   00000040   0xE5900000         LDR      R0,[R0, #+0]
   \   00000044   0xE1B07000         MOVS     R7,R0
    318          	pTransfer = (struct _async_twi*) pTwid->pTransfer;
   \   00000048   0xE59D0004         LDR      R0,[SP, #+4]
   \   0000004C   0xE5900004         LDR      R0,[R0, #+4]
   \   00000050   0xE1B08000         MOVS     R8,R0
    319          
    320          	assert((address & 0x80) == 0);
   \   00000054   0xE5DD0008         LDRB     R0,[SP, #+8]
   \   00000058   0xE3100080         TST      R0,#0x80
   \   0000005C   0x0A000004         BEQ      ??twid_read_1
   \   00000060   0xE3A02F50         MOV      R2,#+320
   \   00000064   0x........         LDR      R1,??DataTable9_9
   \   00000068   0x........         LDR      R0,??DataTable10_5
   \   0000006C   0x........         BL       __aeabi_assert
   \   00000070   0x........         BL       __iar_EmptyStepPoint
    321          	assert((iaddress & 0xFF000000) == 0);
   \                     ??twid_read_1:
   \   00000074   0xE59D000C         LDR      R0,[SP, #+12]
   \   00000078   0xE31004FF         TST      R0,#0xFF000000
   \   0000007C   0x0A000004         BEQ      ??twid_read_2
   \   00000080   0xE3002141         MOVW     R2,#+321
   \   00000084   0x........         LDR      R1,??DataTable9_9
   \   00000088   0x........         LDR      R0,??DataTable10_6
   \   0000008C   0x........         BL       __aeabi_assert
   \   00000090   0x........         BL       __iar_EmptyStepPoint
    322          	assert(isize < 4);
   \                     ??twid_read_2:
   \   00000094   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000098   0xE3500004         CMP      R0,#+4
   \   0000009C   0xBA000004         BLT      ??twid_read_3
   \   000000A0   0xE3002142         MOVW     R2,#+322
   \   000000A4   0x........         LDR      R1,??DataTable9_9
   \   000000A8   0x........         LDR      R0,??DataTable10_7
   \   000000AC   0x........         BL       __aeabi_assert
   \   000000B0   0x........         BL       __iar_EmptyStepPoint
    323          
    324          	/* Check that no transfer is already pending */
    325          	if (pTransfer) {
   \                     ??twid_read_3:
   \   000000B4   0xE3580000         CMP      R8,#+0
   \   000000B8   0x0A000003         BEQ      ??twid_read_4
    326          
    327          		TRACE_ERROR("twid_read: A transfer is already pending\n\r");
   \   000000BC   0x........         LDR      R0,??DataTable10_8
   \   000000C0   0x........         BL       printf
    328          		return TWID_ERROR_BUSY;
   \   000000C4   0xE3A00001         MOV      R0,#+1
   \   000000C8   0xEA000079         B        ??twid_read_5
    329          	}
    330          
    331          	/* Asynchronous transfer */
    332          	if (pAsync) {
   \                     ??twid_read_4:
   \   000000CC   0xE3560000         CMP      R6,#+0
   \   000000D0   0x0A000011         BEQ      ??twid_read_6
    333          
    334          		/* Update the transfer descriptor */
    335          		pTwid->pTransfer = pAsync;
   \   000000D4   0xE59D0004         LDR      R0,[SP, #+4]
   \   000000D8   0xE5806004         STR      R6,[R0, #+4]
    336          		pTransfer = (struct _async_twi*) pAsync;
   \   000000DC   0xE1B08006         MOVS     R8,R6
    337          		pTransfer->status = ASYNC_STATUS_PENDING;
   \   000000E0   0xE3A000FF         MOV      R0,#+255
   \   000000E4   0xE5880000         STR      R0,[R8, #+0]
    338          		pTransfer->pData = pData;
   \   000000E8   0xE5884008         STR      R4,[R8, #+8]
    339          		pTransfer->num = num;
   \   000000EC   0xE588500C         STR      R5,[R8, #+12]
    340          		pTransfer->transferred = 0;
   \   000000F0   0xE3A00000         MOV      R0,#+0
   \   000000F4   0xE5880010         STR      R0,[R8, #+16]
    341          
    342          		/* Enable read interrupt and start the transfer */
    343          		twi_enable_it(pTwi, TWI_IER_RXRDY);
   \   000000F8   0xE3A01002         MOV      R1,#+2
   \   000000FC   0xE1B00007         MOVS     R0,R7
   \   00000100   0x........         BL       twi_enable_it
    344          		twi_start_read(pTwi, address, iaddress, isize);
   \   00000104   0xE5DD3010         LDRB     R3,[SP, #+16]
   \   00000108   0xE59D200C         LDR      R2,[SP, #+12]
   \   0000010C   0xE5DD1008         LDRB     R1,[SP, #+8]
   \   00000110   0xE1B00007         MOVS     R0,R7
   \   00000114   0x........         BL       twi_start_read
   \   00000118   0xEA000064         B        ??twid_read_7
    345          	}
    346          	/* Synchronous transfer */
    347          	else {
    348          
    349          		/* Start read */
    350          		twi_start_read(pTwi, address, iaddress, isize);
   \                     ??twid_read_6:
   \   0000011C   0xE5DD3010         LDRB     R3,[SP, #+16]
   \   00000120   0xE59D200C         LDR      R2,[SP, #+12]
   \   00000124   0xE5DD1008         LDRB     R1,[SP, #+8]
   \   00000128   0xE1B00007         MOVS     R0,R7
   \   0000012C   0x........         BL       twi_start_read
    351          		if (num != 1) {
   \   00000130   0xE3550001         CMP      R5,#+1
   \   00000134   0x0A000034         BEQ      ??twid_read_8
    352          			status = twi_get_status(pTwi);
   \   00000138   0xE1B00007         MOVS     R0,R7
   \   0000013C   0x........         BL       twi_get_status
   \   00000140   0xE1B0B000         MOVS     R11,R0
    353          
    354          			if (status & TWI_SR_NACK)
   \   00000144   0xE31B0F40         TST      R11,#0x100
   \   00000148   0x0A000001         BEQ      ??twid_read_9
    355          				TRACE_ERROR("TWID NACK error\n\r");
   \   0000014C   0x........         LDR      R0,??DataTable10_9
   \   00000150   0x........         BL       printf
    356          			timeout = 0;
   \                     ??twid_read_9:
   \   00000154   0xE3A00000         MOV      R0,#+0
   \   00000158   0xE1B09000         MOVS     R9,R0
    357          			while (!(status & TWI_SR_RXRDY)
    358          			       && (++timeout < TWITIMEOUTMAX)) {
   \                     ??twid_read_10:
   \   0000015C   0xE31B0002         TST      R11,#0x2
   \   00000160   0x1A000008         BNE      ??twid_read_11
   \   00000164   0xE2999001         ADDS     R9,R9,#+1
   \   00000168   0xE3E004F0         MVN      R0,#-268435456
   \   0000016C   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   00000170   0xE1590000         CMP      R9,R0
   \   00000174   0x2A000003         BCS      ??twid_read_11
    359          				status = twi_get_status(pTwi);
   \   00000178   0xE1B00007         MOVS     R0,R7
   \   0000017C   0x........         BL       twi_get_status
   \   00000180   0xE1B0B000         MOVS     R11,R0
   \   00000184   0xEAFFFFF4         B        ??twid_read_10
    360          				//TRACE_ERROR("TWID status %x\n\r",twi_get_status(pTwi));
    361          			}
    362          
    363          			pData[0] = twi_read_byte(pTwi);
   \                     ??twid_read_11:
   \   00000188   0xE1B00007         MOVS     R0,R7
   \   0000018C   0x........         BL       twi_read_byte
   \   00000190   0xE5C40000         STRB     R0,[R4, #+0]
    364          			for (i = 1; i < num - 1; i++) {
   \   00000194   0xE3A00001         MOV      R0,#+1
   \   00000198   0xE1B0A000         MOVS     R10,R0
   \                     ??twid_read_12:
   \   0000019C   0xE2550001         SUBS     R0,R5,#+1
   \   000001A0   0xE15A0000         CMP      R10,R0
   \   000001A4   0x2A000018         BCS      ??twid_read_8
    365          				status = twi_get_status(pTwi);
   \   000001A8   0xE1B00007         MOVS     R0,R7
   \   000001AC   0x........         BL       twi_get_status
   \   000001B0   0xE1B0B000         MOVS     R11,R0
    366          				if (status & TWI_SR_NACK)
   \   000001B4   0xE31B0F40         TST      R11,#0x100
   \   000001B8   0x0A000001         BEQ      ??twid_read_13
    367          					TRACE_ERROR("TWID NACK error\n\r");
   \   000001BC   0x........         LDR      R0,??DataTable10_9
   \   000001C0   0x........         BL       printf
    368          				timeout = 0;
   \                     ??twid_read_13:
   \   000001C4   0xE3A00000         MOV      R0,#+0
   \   000001C8   0xE1B09000         MOVS     R9,R0
    369          				while (!(status & TWI_SR_RXRDY)
    370          				       && (++timeout < TWITIMEOUTMAX)) {
   \                     ??twid_read_14:
   \   000001CC   0xE31B0002         TST      R11,#0x2
   \   000001D0   0x1A000008         BNE      ??twid_read_15
   \   000001D4   0xE2999001         ADDS     R9,R9,#+1
   \   000001D8   0xE3E004F0         MVN      R0,#-268435456
   \   000001DC   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   000001E0   0xE1590000         CMP      R9,R0
   \   000001E4   0x2A000003         BCS      ??twid_read_15
    371          					status = twi_get_status(pTwi);
   \   000001E8   0xE1B00007         MOVS     R0,R7
   \   000001EC   0x........         BL       twi_get_status
   \   000001F0   0xE1B0B000         MOVS     R11,R0
   \   000001F4   0xEAFFFFF4         B        ??twid_read_14
    372          					//TRACE_ERROR("TWID status %x\n\r",twi_get_status(pTwi));
    373          				}
    374          				pData[i] = twi_read_byte(pTwi);
   \                     ??twid_read_15:
   \   000001F8   0xE1B00007         MOVS     R0,R7
   \   000001FC   0x........         BL       twi_read_byte
   \   00000200   0xE7CA0004         STRB     R0,[R10, +R4]
    375          			}
   \   00000204   0xE29AA001         ADDS     R10,R10,#+1
   \   00000208   0xEAFFFFE3         B        ??twid_read_12
    376          		}
    377          		twi_stop(pTwi);
   \                     ??twid_read_8:
   \   0000020C   0xE1B00007         MOVS     R0,R7
   \   00000210   0x........         BL       twi_stop
    378          		status = twi_get_status(pTwi);
   \   00000214   0xE1B00007         MOVS     R0,R7
   \   00000218   0x........         BL       twi_get_status
   \   0000021C   0xE1B0B000         MOVS     R11,R0
    379          		if (status & TWI_SR_NACK)
   \   00000220   0xE31B0F40         TST      R11,#0x100
   \   00000224   0x0A000001         BEQ      ??twid_read_16
    380          			TRACE_ERROR("TWID NACK error\n\r");
   \   00000228   0x........         LDR      R0,??DataTable10_9
   \   0000022C   0x........         BL       printf
    381          		timeout = 0;
   \                     ??twid_read_16:
   \   00000230   0xE3A00000         MOV      R0,#+0
   \   00000234   0xE1B09000         MOVS     R9,R0
    382          		while (!(status & TWI_SR_RXRDY) && (++timeout < TWITIMEOUTMAX)) {
   \                     ??twid_read_17:
   \   00000238   0xE31B0002         TST      R11,#0x2
   \   0000023C   0x1A000008         BNE      ??twid_read_18
   \   00000240   0xE2999001         ADDS     R9,R9,#+1
   \   00000244   0xE3E004F0         MVN      R0,#-268435456
   \   00000248   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   0000024C   0xE1590000         CMP      R9,R0
   \   00000250   0x2A000003         BCS      ??twid_read_18
    383          			status = twi_get_status(pTwi);
   \   00000254   0xE1B00007         MOVS     R0,R7
   \   00000258   0x........         BL       twi_get_status
   \   0000025C   0xE1B0B000         MOVS     R11,R0
   \   00000260   0xEAFFFFF4         B        ??twid_read_17
    384          			//TRACE_ERROR("TWID status %x\n\r",twi_get_status(pTwi));
    385          		}
    386          
    387          		pData[i] = twi_read_byte(pTwi);
   \                     ??twid_read_18:
   \   00000264   0xE1B00007         MOVS     R0,R7
   \   00000268   0x........         BL       twi_read_byte
   \   0000026C   0xE7CA0004         STRB     R0,[R10, +R4]
    388          		timeout = 0;
   \   00000270   0xE3A00000         MOV      R0,#+0
   \   00000274   0xE1B09000         MOVS     R9,R0
    389          		status = twi_get_status(pTwi);
   \   00000278   0xE1B00007         MOVS     R0,R7
   \   0000027C   0x........         BL       twi_get_status
   \   00000280   0xE1B0B000         MOVS     R11,R0
    390          		while (!(status & TWI_SR_TXCOMP) && (++timeout < TWITIMEOUTMAX)) {
   \                     ??twid_read_19:
   \   00000284   0xE31B0001         TST      R11,#0x1
   \   00000288   0x1A000008         BNE      ??twid_read_7
   \   0000028C   0xE2999001         ADDS     R9,R9,#+1
   \   00000290   0xE3E004F0         MVN      R0,#-268435456
   \   00000294   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   00000298   0xE1590000         CMP      R9,R0
   \   0000029C   0x2A000003         BCS      ??twid_read_7
    391          			status = twi_get_status(pTwi);
   \   000002A0   0xE1B00007         MOVS     R0,R7
   \   000002A4   0x........         BL       twi_get_status
   \   000002A8   0xE1B0B000         MOVS     R11,R0
   \   000002AC   0xEAFFFFF4         B        ??twid_read_19
    392          			//TRACE_ERROR("TWID status %x\n\r",twi_get_status(pTwi));
    393          		}
    394          #if 0
    395          		/* Read all bytes, setting STOP before the last byte */
    396          		while (num > 0) {
    397          
    398          			/* Last byte ? */
    399          			if (num == 1) {
    400          
    401          				twi_stop(pTwi);
    402          			}
    403          
    404          			/* Wait for byte then read and store it */
    405          			timeout = 0;
    406          			while (!twi_is_byte_received(pTwi)
    407          			       && (++timeout < TWITIMEOUTMAX)) ;
    408          			if (timeout == TWITIMEOUTMAX) {
    409          				TRACE_ERROR("TWID Timeout BR\n\r");
    410          			}
    411          			*pData++ = twi_read_byte(pTwi);
    412          			num--;
    413          		}
    414          
    415          		/* Wait for transfer to be complete */
    416          		timeout = 0;
    417          		while (!twi_is_transfer_complete(pTwi)
    418          		       && (++timeout < TWITIMEOUTMAX)) ;
    419          		if (timeout == TWITIMEOUTMAX) {
    420          			TRACE_ERROR("TWID Timeout TC\n\r");
    421          		}
    422          #endif
    423          	}
    424          
    425          	return 0;
   \                     ??twid_read_7:
   \   000002B0   0xE3A00000         MOV      R0,#+0
   \                     ??twid_read_5:
   \   000002B4   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000002B8   0xE8BD8FF0         POP      {R4-R11,PC}      ;; return
    426          }
    427          
    428          /**
    429           * \brief Asynchronously reads data from a slave on the TWI bus. An optional
    430           * callback function is triggered when the transfer is complete.
    431           * \param pTwid  Pointer to a Twid instance.
    432           * \param address  TWI slave address.
    433           * \param iaddress  Optional slave internal address.
    434           * \param isize  Internal address size in bytes.
    435           * \param pData  Data buffer for storing received bytes.
    436           * \param num  Number of bytes to read.
    437           * \param pAsync  Asynchronous transfer descriptor.
    438           * \param twi_id  TWI ID for TWI0, TWI1, TWI2.
    439           * \return 0 if the transfer has been started; otherwise returns a TWI error code.
    440           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    441          uint8_t twid_dma_read(struct _twid* pTwid, uint8_t address, uint32_t iaddress,
    442          	     uint8_t isize, uint8_t * pData, uint32_t num, Async * pAsync, uint8_t twi_id)
    443          {
   \                     twid_dma_read:
   \   00000000   0xE92D4FFF         PUSH     {R0-R11,LR}
   \   00000004   0xE24DD004         SUB      SP,SP,#+4
   \   00000008   0xE59D4038         LDR      R4,[SP, #+56]
   \   0000000C   0xE59D503C         LDR      R5,[SP, #+60]
   \   00000010   0xE59D6040         LDR      R6,[SP, #+64]
   \   00000014   0xE5DD7044         LDRB     R7,[SP, #+68]
    444          	Twi *pTwi;
    445          	struct _async_twi* pTransfer;
    446          	uint32_t timeout = 0;
   \   00000018   0xE3A0A000         MOV      R10,#+0
    447          	uint32_t status;
    448          
    449          	assert(pTwid != NULL);
   \   0000001C   0xE59D0004         LDR      R0,[SP, #+4]
   \   00000020   0xE3500000         CMP      R0,#+0
   \   00000024   0x1A000004         BNE      ??twid_dma_read_0
   \   00000028   0xE30021C1         MOVW     R2,#+449
   \   0000002C   0x........         LDR      R1,??DataTable9_9
   \   00000030   0x........         LDR      R0,??DataTable9_10
   \   00000034   0x........         BL       __aeabi_assert
   \   00000038   0x........         BL       __iar_EmptyStepPoint
    450          	pTwi = pTwid->pTwi;
   \                     ??twid_dma_read_0:
   \   0000003C   0xE59D0004         LDR      R0,[SP, #+4]
   \   00000040   0xE5900000         LDR      R0,[R0, #+0]
   \   00000044   0xE1B08000         MOVS     R8,R0
    451          	pTransfer = (struct _async_twi*) pTwid->pTransfer;
   \   00000048   0xE59D0004         LDR      R0,[SP, #+4]
   \   0000004C   0xE5900004         LDR      R0,[R0, #+4]
   \   00000050   0xE1B09000         MOVS     R9,R0
    452          
    453          	assert((address & 0x80) == 0);
   \   00000054   0xE5DD0008         LDRB     R0,[SP, #+8]
   \   00000058   0xE3100080         TST      R0,#0x80
   \   0000005C   0x0A000004         BEQ      ??twid_dma_read_1
   \   00000060   0xE30021C5         MOVW     R2,#+453
   \   00000064   0x........         LDR      R1,??DataTable9_9
   \   00000068   0x........         LDR      R0,??DataTable10_5
   \   0000006C   0x........         BL       __aeabi_assert
   \   00000070   0x........         BL       __iar_EmptyStepPoint
    454          	assert((iaddress & 0xFF000000) == 0);
   \                     ??twid_dma_read_1:
   \   00000074   0xE59D000C         LDR      R0,[SP, #+12]
   \   00000078   0xE31004FF         TST      R0,#0xFF000000
   \   0000007C   0x0A000004         BEQ      ??twid_dma_read_2
   \   00000080   0xE30021C6         MOVW     R2,#+454
   \   00000084   0x........         LDR      R1,??DataTable9_9
   \   00000088   0x........         LDR      R0,??DataTable10_6
   \   0000008C   0x........         BL       __aeabi_assert
   \   00000090   0x........         BL       __iar_EmptyStepPoint
    455          	assert(isize < 4);
   \                     ??twid_dma_read_2:
   \   00000094   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000098   0xE3500004         CMP      R0,#+4
   \   0000009C   0xBA000004         BLT      ??twid_dma_read_3
   \   000000A0   0xE30021C7         MOVW     R2,#+455
   \   000000A4   0x........         LDR      R1,??DataTable9_9
   \   000000A8   0x........         LDR      R0,??DataTable10_7
   \   000000AC   0x........         BL       __aeabi_assert
   \   000000B0   0x........         BL       __iar_EmptyStepPoint
    456          
    457          	/* Check that no transfer is already pending */
    458          	if (pTransfer) {
   \                     ??twid_dma_read_3:
   \   000000B4   0xE3590000         CMP      R9,#+0
   \   000000B8   0x0A000003         BEQ      ??twid_dma_read_4
    459          
    460          		TRACE_ERROR("twid_read: A transfer is already pending\n\r");
   \   000000BC   0x........         LDR      R0,??DataTable10_8
   \   000000C0   0x........         BL       printf
    461          		return TWID_ERROR_BUSY;
   \   000000C4   0xE3A00001         MOV      R0,#+1
   \   000000C8   0xEA000068         B        ??twid_dma_read_5
    462          	}
    463          
    464          	/* Asynchronous transfer */
    465          	if (pAsync) {
   \                     ??twid_dma_read_4:
   \   000000CC   0xE3560000         CMP      R6,#+0
   \   000000D0   0x0A000011         BEQ      ??twid_dma_read_6
    466          
    467          		/* Update the transfer descriptor */
    468          		pTwid->pTransfer = pAsync;
   \   000000D4   0xE59D0004         LDR      R0,[SP, #+4]
   \   000000D8   0xE5806004         STR      R6,[R0, #+4]
    469          		pTransfer = (struct _async_twi*) pAsync;
   \   000000DC   0xE1B09006         MOVS     R9,R6
    470          		pTransfer->status = ASYNC_STATUS_PENDING;
   \   000000E0   0xE3A000FF         MOV      R0,#+255
   \   000000E4   0xE5890000         STR      R0,[R9, #+0]
    471          		pTransfer->pData = pData;
   \   000000E8   0xE5894008         STR      R4,[R9, #+8]
    472          		pTransfer->num = num;
   \   000000EC   0xE589500C         STR      R5,[R9, #+12]
    473          		pTransfer->transferred = 0;
   \   000000F0   0xE3A00000         MOV      R0,#+0
   \   000000F4   0xE5890010         STR      R0,[R9, #+16]
    474          
    475          		/* Enable read interrupt and start the transfer */
    476          		twi_enable_it(pTwi, TWI_IER_RXRDY);
   \   000000F8   0xE3A01002         MOV      R1,#+2
   \   000000FC   0xE1B00008         MOVS     R0,R8
   \   00000100   0x........         BL       twi_enable_it
    477          		twi_start_read(pTwi, address, iaddress, isize);
   \   00000104   0xE5DD3010         LDRB     R3,[SP, #+16]
   \   00000108   0xE59D200C         LDR      R2,[SP, #+12]
   \   0000010C   0xE5DD1008         LDRB     R1,[SP, #+8]
   \   00000110   0xE1B00008         MOVS     R0,R8
   \   00000114   0x........         BL       twi_start_read
   \   00000118   0xEA000053         B        ??twid_dma_read_7
    478          	}
    479          	/* Synchronous transfer */
    480          	else {
    481          
    482          		twid_dma_initialize_read(twi_id);
   \                     ??twid_dma_read_6:
   \   0000011C   0xE1B00007         MOVS     R0,R7
   \   00000120   0xE6EF0070         UXTB     R0,R0
   \   00000124   0x........         BL       twid_dma_initialize_read
    483          		_xdma_configure_read(pData, num, twi_id);
   \   00000128   0xE1B02007         MOVS     R2,R7
   \   0000012C   0xE6EF2072         UXTB     R2,R2
   \   00000130   0xE1B01005         MOVS     R1,R5
   \   00000134   0xE1B00004         MOVS     R0,R4
   \   00000138   0x........         BL       _xdma_configure_read
    484          		/* Start read */
    485          		XDMAD_StartTransfer(&twi_dma, dmaReadChannel);
   \   0000013C   0x........         LDR      R0,??DataTable9_6
   \   00000140   0xE5901000         LDR      R1,[R0, #+0]
   \   00000144   0x........         LDR      R0,??DataTable9_5
   \   00000148   0x........         BL       XDMAD_StartTransfer
    486          
    487          		twi_start_read(pTwi, address, iaddress, isize);
   \   0000014C   0xE5DD3010         LDRB     R3,[SP, #+16]
   \   00000150   0xE59D200C         LDR      R2,[SP, #+12]
   \   00000154   0xE5DD1008         LDRB     R1,[SP, #+8]
   \   00000158   0xE1B00008         MOVS     R0,R8
   \   0000015C   0x........         BL       twi_start_read
    488          
    489          		while ((XDMAD_IsTransferDone(&twi_dma, dmaReadChannel))
    490          		       && (++timeout < TWITIMEOUTMAX)) ;
   \                     ??twid_dma_read_8:
   \   00000160   0x........         LDR      R0,??DataTable9_6
   \   00000164   0xE5901000         LDR      R1,[R0, #+0]
   \   00000168   0x........         LDR      R0,??DataTable9_5
   \   0000016C   0x........         BL       XDMAD_IsTransferDone
   \   00000170   0xE3500000         CMP      R0,#+0
   \   00000174   0x0A000004         BEQ      ??twid_dma_read_9
   \   00000178   0xE29AA001         ADDS     R10,R10,#+1
   \   0000017C   0xE3E004F0         MVN      R0,#-268435456
   \   00000180   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   00000184   0xE15A0000         CMP      R10,R0
   \   00000188   0x3AFFFFF4         BCC      ??twid_dma_read_8
    491          
    492          		XDMAD_StopTransfer(&twi_dma, dmaReadChannel);
   \                     ??twid_dma_read_9:
   \   0000018C   0x........         LDR      R0,??DataTable9_6
   \   00000190   0xE5901000         LDR      R1,[R0, #+0]
   \   00000194   0x........         LDR      R0,??DataTable9_5
   \   00000198   0x........         BL       XDMAD_StopTransfer
    493          
    494          		status = twi_get_status(pTwi);
   \   0000019C   0xE1B00008         MOVS     R0,R8
   \   000001A0   0x........         BL       twi_get_status
   \   000001A4   0xE1B0B000         MOVS     R11,R0
    495          		timeout = 0;
   \   000001A8   0xE3A00000         MOV      R0,#+0
   \   000001AC   0xE1B0A000         MOVS     R10,R0
    496          		while (!(status & TWI_SR_RXRDY)
    497          		       && (++timeout < TWITIMEOUTMAX)) ;
   \                     ??twid_dma_read_10:
   \   000001B0   0xE31B0002         TST      R11,#0x2
   \   000001B4   0x1A000004         BNE      ??twid_dma_read_11
   \   000001B8   0xE29AA001         ADDS     R10,R10,#+1
   \   000001BC   0xE3E004F0         MVN      R0,#-268435456
   \   000001C0   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   000001C4   0xE15A0000         CMP      R10,R0
   \   000001C8   0x3AFFFFF8         BCC      ??twid_dma_read_10
    498          
    499          		twi_stop(pTwi);
   \                     ??twid_dma_read_11:
   \   000001CC   0xE1B00008         MOVS     R0,R8
   \   000001D0   0x........         BL       twi_stop
    500          
    501          		twi_read_byte(pTwi);
   \   000001D4   0xE1B00008         MOVS     R0,R8
   \   000001D8   0x........         BL       twi_read_byte
    502          
    503          		status = twi_get_status(pTwi);
   \   000001DC   0xE1B00008         MOVS     R0,R8
   \   000001E0   0x........         BL       twi_get_status
   \   000001E4   0xE1B0B000         MOVS     R11,R0
    504          		timeout = 0;
   \   000001E8   0xE3A00000         MOV      R0,#+0
   \   000001EC   0xE1B0A000         MOVS     R10,R0
    505          		while (!(status & TWI_SR_RXRDY)
    506          		       && (++timeout < TWITIMEOUTMAX)) ;
   \                     ??twid_dma_read_12:
   \   000001F0   0xE31B0002         TST      R11,#0x2
   \   000001F4   0x1A000004         BNE      ??twid_dma_read_13
   \   000001F8   0xE29AA001         ADDS     R10,R10,#+1
   \   000001FC   0xE3E004F0         MVN      R0,#-268435456
   \   00000200   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   00000204   0xE15A0000         CMP      R10,R0
   \   00000208   0x3AFFFFF8         BCC      ??twid_dma_read_12
    507          
    508          		twi_read_byte(pTwi);
   \                     ??twid_dma_read_13:
   \   0000020C   0xE1B00008         MOVS     R0,R8
   \   00000210   0x........         BL       twi_read_byte
    509          
    510          		status = twi_get_status(pTwi);
   \   00000214   0xE1B00008         MOVS     R0,R8
   \   00000218   0x........         BL       twi_get_status
   \   0000021C   0xE1B0B000         MOVS     R11,R0
    511          		timeout = 0;
   \   00000220   0xE3A00000         MOV      R0,#+0
   \   00000224   0xE1B0A000         MOVS     R10,R0
    512          		while (!(status & TWI_SR_TXCOMP)
    513          		       && (++timeout < TWITIMEOUTMAX)) ;
   \                     ??twid_dma_read_14:
   \   00000228   0xE31B0001         TST      R11,#0x1
   \   0000022C   0x1A000004         BNE      ??twid_dma_read_15
   \   00000230   0xE29AA001         ADDS     R10,R10,#+1
   \   00000234   0xE3E004F0         MVN      R0,#-268435456
   \   00000238   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   0000023C   0xE15A0000         CMP      R10,R0
   \   00000240   0x3AFFFFF8         BCC      ??twid_dma_read_14
    514          		if (timeout == TWITIMEOUTMAX) {
   \                     ??twid_dma_read_15:
   \   00000244   0xE3E004F0         MVN      R0,#-268435456
   \   00000248   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   0000024C   0xE15A0000         CMP      R10,R0
   \   00000250   0x1A000001         BNE      ??twid_dma_read_16
    515          			TRACE_ERROR("TWID Timeout Read\n\r");
   \   00000254   0x........         LDR      R0,??DataTable10_10
   \   00000258   0x........         BL       printf
    516          		}
    517          		XDMAD_FreeChannel(&twi_dma, dmaReadChannel);
   \                     ??twid_dma_read_16:
   \   0000025C   0x........         LDR      R0,??DataTable9_6
   \   00000260   0xE5901000         LDR      R1,[R0, #+0]
   \   00000264   0x........         LDR      R0,??DataTable9_5
   \   00000268   0x........         BL       XDMAD_FreeChannel
    518          	}
    519          	return 0;
   \                     ??twid_dma_read_7:
   \   0000026C   0xE3A00000         MOV      R0,#+0
   \                     ??twid_dma_read_5:
   \   00000270   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   00000274   0xE8BD8FF0         POP      {R4-R11,PC}      ;; return
    520          }
    521          
    522          /**
    523           * \brief Asynchronously sends data to a slave on the TWI bus. An optional callback
    524           * function is invoked whenever the transfer is complete.
    525           * \param pTwid  Pointer to a Twid instance.
    526           * \param address  TWI slave address.
    527           * \param iaddress  Optional slave internal address.
    528           * \param isize  Number of internal address bytes.
    529           * \param pData  Data buffer for storing received bytes.
    530           * \param num  Data buffer to send.
    531           * \param pAsync  Asynchronous transfer descriptor.
    532           * \param twi_id  TWI ID for TWI0, TWI1, TWI2.
    533           * \return 0 if the transfer has been started; otherwise returns a TWI error code.
    534           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    535          uint8_t twid_dma_write(struct _twid* pTwid, uint8_t address, uint32_t iaddress,
    536          	      uint8_t isize, uint8_t * pData, uint32_t num, Async * pAsync, uint8_t twi_id)
    537          {
   \                     twid_dma_write:
   \   00000000   0xE92D4FFF         PUSH     {R0-R11,LR}
   \   00000004   0xE24DD004         SUB      SP,SP,#+4
   \   00000008   0xE59D4038         LDR      R4,[SP, #+56]
   \   0000000C   0xE59D503C         LDR      R5,[SP, #+60]
   \   00000010   0xE59D6040         LDR      R6,[SP, #+64]
   \   00000014   0xE5DD7044         LDRB     R7,[SP, #+68]
    538          	Twi *pTwi = pTwid->pTwi;
   \   00000018   0xE59D0004         LDR      R0,[SP, #+4]
   \   0000001C   0xE5908000         LDR      R8,[R0, #+0]
    539          	struct _async_twi* pTransfer;
    540          	uint32_t timeout = 0;
   \   00000020   0xE3A0B000         MOV      R11,#+0
    541          	uint32_t status;
    542          	//uint8_t singleTransfer = 0;
    543          
    544          	assert(pTwi != NULL);
   \   00000024   0xE3580000         CMP      R8,#+0
   \   00000028   0x1A000004         BNE      ??twid_dma_write_0
   \   0000002C   0xE3A02F88         MOV      R2,#+544
   \   00000030   0x........         LDR      R1,??DataTable9_9
   \   00000034   0x........         LDR      R0,??DataTable9_11
   \   00000038   0x........         BL       __aeabi_assert
   \   0000003C   0x........         BL       __iar_EmptyStepPoint
    545          	assert((address & 0x80) == 0);
   \                     ??twid_dma_write_0:
   \   00000040   0xE5DD0008         LDRB     R0,[SP, #+8]
   \   00000044   0xE3100080         TST      R0,#0x80
   \   00000048   0x0A000004         BEQ      ??twid_dma_write_1
   \   0000004C   0xE3002221         MOVW     R2,#+545
   \   00000050   0x........         LDR      R1,??DataTable9_9
   \   00000054   0x........         LDR      R0,??DataTable10_5
   \   00000058   0x........         BL       __aeabi_assert
   \   0000005C   0x........         BL       __iar_EmptyStepPoint
    546          	assert((iaddress & 0xFF000000) == 0);
   \                     ??twid_dma_write_1:
   \   00000060   0xE59D000C         LDR      R0,[SP, #+12]
   \   00000064   0xE31004FF         TST      R0,#0xFF000000
   \   00000068   0x0A000004         BEQ      ??twid_dma_write_2
   \   0000006C   0xE3002222         MOVW     R2,#+546
   \   00000070   0x........         LDR      R1,??DataTable9_9
   \   00000074   0x........         LDR      R0,??DataTable10_6
   \   00000078   0x........         BL       __aeabi_assert
   \   0000007C   0x........         BL       __iar_EmptyStepPoint
    547          	assert(isize < 4);
   \                     ??twid_dma_write_2:
   \   00000080   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000084   0xE3500004         CMP      R0,#+4
   \   00000088   0xBA000004         BLT      ??twid_dma_write_3
   \   0000008C   0xE3002223         MOVW     R2,#+547
   \   00000090   0x........         LDR      R1,??DataTable9_9
   \   00000094   0x........         LDR      R0,??DataTable10_7
   \   00000098   0x........         BL       __aeabi_assert
   \   0000009C   0x........         BL       __iar_EmptyStepPoint
    548          
    549          	pTransfer = (struct _async_twi *) pTwid->pTransfer;
   \                     ??twid_dma_write_3:
   \   000000A0   0xE59D0004         LDR      R0,[SP, #+4]
   \   000000A4   0xE5900004         LDR      R0,[R0, #+4]
   \   000000A8   0xE1B09000         MOVS     R9,R0
    550          //    if(num == 1) singleTransfer = 1;
    551          	/* Check that no transfer is already pending */
    552          	if (pTransfer) {
   \   000000AC   0xE3590000         CMP      R9,#+0
   \   000000B0   0x0A000003         BEQ      ??twid_dma_write_4
    553          		TRACE_ERROR("TWI_Write: A transfer is already pending\n\r");
   \   000000B4   0x........         LDR      R0,??DataTable10_11
   \   000000B8   0x........         BL       printf
    554          		return TWID_ERROR_BUSY;
   \   000000BC   0xE3A00001         MOV      R0,#+1
   \   000000C0   0xEA000070         B        ??twid_dma_write_5
    555          	}
    556          
    557          	/* Asynchronous transfer */
    558          	if (pAsync) {
   \                     ??twid_dma_write_4:
   \   000000C4   0xE3560000         CMP      R6,#+0
   \   000000C8   0x0A000013         BEQ      ??twid_dma_write_6
    559          		/* Update the transfer descriptor */
    560          		pTwid->pTransfer = pAsync;
   \   000000CC   0xE59D0004         LDR      R0,[SP, #+4]
   \   000000D0   0xE5806004         STR      R6,[R0, #+4]
    561          		pTransfer = (struct _async_twi*) pAsync;
   \   000000D4   0xE1B09006         MOVS     R9,R6
    562          		pTransfer->status = ASYNC_STATUS_PENDING;
   \   000000D8   0xE3A000FF         MOV      R0,#+255
   \   000000DC   0xE5890000         STR      R0,[R9, #+0]
    563          		pTransfer->pData = pData;
   \   000000E0   0xE5894008         STR      R4,[R9, #+8]
    564          		pTransfer->num = num;
   \   000000E4   0xE589500C         STR      R5,[R9, #+12]
    565          		pTransfer->transferred = 1;
   \   000000E8   0xE3A00001         MOV      R0,#+1
   \   000000EC   0xE5890010         STR      R0,[R9, #+16]
    566          		/* Enable write interrupt and start the transfer */
    567          		twi_start_write(pTwi, address, iaddress, isize, *pData);
   \   000000F0   0xE5D40000         LDRB     R0,[R4, #+0]
   \   000000F4   0xE58D0000         STR      R0,[SP, #+0]
   \   000000F8   0xE5DD3010         LDRB     R3,[SP, #+16]
   \   000000FC   0xE59D200C         LDR      R2,[SP, #+12]
   \   00000100   0xE5DD1008         LDRB     R1,[SP, #+8]
   \   00000104   0xE1B00008         MOVS     R0,R8
   \   00000108   0x........         BL       twi_start_write
    568          		twi_enable_it(pTwi, TWI_IER_TXRDY);
   \   0000010C   0xE3A01004         MOV      R1,#+4
   \   00000110   0xE1B00008         MOVS     R0,R8
   \   00000114   0x........         BL       twi_enable_it
   \   00000118   0xEA000059         B        ??twid_dma_write_7
    569          	}
    570          	/* Synchronous transfer */
    571          	else {
    572          		cp15_coherent_dcache_for_dma((uint32_t) pData, (uint32_t) pData);
   \                     ??twid_dma_write_6:
   \   0000011C   0xE1B01004         MOVS     R1,R4
   \   00000120   0xE1B00004         MOVS     R0,R4
   \   00000124   0x........         BL       cp15_coherent_dcache_for_dma
    573          		twid_dma_initialize_write(twi_id);
   \   00000128   0xE1B00007         MOVS     R0,R7
   \   0000012C   0xE6EF0070         UXTB     R0,R0
   \   00000130   0x........         BL       twid_dma_initialize_write
    574          		_xdma_configure_write(pData, num, twi_id);
   \   00000134   0xE1B02007         MOVS     R2,R7
   \   00000138   0xE6EF2072         UXTB     R2,R2
   \   0000013C   0xE1B01005         MOVS     R1,R5
   \   00000140   0xE1B00004         MOVS     R0,R4
   \   00000144   0x........         BL       _xdma_configure_write
    575          		/* Set slave address and number of internal address bytes. */
    576          		pTwi->TWI_MMR = 0;
   \   00000148   0xE3A00000         MOV      R0,#+0
   \   0000014C   0xE5880004         STR      R0,[R8, #+4]
    577          		pTwi->TWI_MMR = (isize << 8) | (address << 16);
   \   00000150   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000154   0xE5DD1008         LDRB     R1,[SP, #+8]
   \   00000158   0xE1B01801         LSLS     R1,R1,#+16
   \   0000015C   0xE1910400         ORRS     R0,R1,R0, LSL #+8
   \   00000160   0xE5880004         STR      R0,[R8, #+4]
    578          		/* Set internal address bytes. */
    579          		pTwi->TWI_IADR = 0;
   \   00000164   0xE3A00000         MOV      R0,#+0
   \   00000168   0xE588000C         STR      R0,[R8, #+12]
    580          		pTwi->TWI_IADR = iaddress;
   \   0000016C   0xE59D000C         LDR      R0,[SP, #+12]
   \   00000170   0xE588000C         STR      R0,[R8, #+12]
    581          		XDMAD_StartTransfer(&twi_dma, dmaWriteChannel);
   \   00000174   0x........         LDR      R0,??DataTable9_8
   \   00000178   0xE5901000         LDR      R1,[R0, #+0]
   \   0000017C   0x........         LDR      R0,??DataTable9_5
   \   00000180   0x........         BL       XDMAD_StartTransfer
    582          		while (XDMAD_IsTransferDone(&twi_dma, dmaWriteChannel)) ;
   \                     ??twid_dma_write_8:
   \   00000184   0x........         LDR      R0,??DataTable9_8
   \   00000188   0xE5901000         LDR      R1,[R0, #+0]
   \   0000018C   0x........         LDR      R0,??DataTable9_5
   \   00000190   0x........         BL       XDMAD_IsTransferDone
   \   00000194   0xE3500000         CMP      R0,#+0
   \   00000198   0x1AFFFFF9         BNE      ??twid_dma_write_8
    583          		XDMAD_StopTransfer(&twi_dma, dmaWriteChannel);
   \   0000019C   0x........         LDR      R0,??DataTable9_8
   \   000001A0   0xE5901000         LDR      R1,[R0, #+0]
   \   000001A4   0x........         LDR      R0,??DataTable9_5
   \   000001A8   0x........         BL       XDMAD_StopTransfer
    584          		status = twi_get_status(pTwi);
   \   000001AC   0xE1B00008         MOVS     R0,R8
   \   000001B0   0x........         BL       twi_get_status
   \   000001B4   0xE1B0A000         MOVS     R10,R0
    585          		timeout = 0;
   \   000001B8   0xE3A00000         MOV      R0,#+0
   \   000001BC   0xE1B0B000         MOVS     R11,R0
    586          		while (!(status & TWI_SR_TXRDY) && (timeout++ < TWITIMEOUTMAX)) {
   \                     ??twid_dma_write_9:
   \   000001C0   0xE31A0004         TST      R10,#0x4
   \   000001C4   0x1A000009         BNE      ??twid_dma_write_10
   \   000001C8   0xE1B0000B         MOVS     R0,R11
   \   000001CC   0xE290B001         ADDS     R11,R0,#+1
   \   000001D0   0xE3E014F0         MVN      R1,#-268435456
   \   000001D4   0xE3C116FF         BIC      R1,R1,#0xFF00000
   \   000001D8   0xE1500001         CMP      R0,R1
   \   000001DC   0x2A000003         BCS      ??twid_dma_write_10
    587          			status = twi_get_status(pTwi);
   \   000001E0   0xE1B00008         MOVS     R0,R8
   \   000001E4   0x........         BL       twi_get_status
   \   000001E8   0xE1B0A000         MOVS     R10,R0
   \   000001EC   0xEAFFFFF3         B        ??twid_dma_write_9
    588          		}
    589          		if (timeout == TWITIMEOUTMAX) {
   \                     ??twid_dma_write_10:
   \   000001F0   0xE3E004F0         MVN      R0,#-268435456
   \   000001F4   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   000001F8   0xE15B0000         CMP      R11,R0
   \   000001FC   0x1A000001         BNE      ??twid_dma_write_11
    590          			TRACE_ERROR("TWID Timeout TXRDY\n\r");
   \   00000200   0x........         LDR      R0,??DataTable10_12
   \   00000204   0x........         BL       printf
    591          		}
    592          		/* Send a STOP condition */
    593          		twi_stop(pTwi);
   \                     ??twid_dma_write_11:
   \   00000208   0xE1B00008         MOVS     R0,R8
   \   0000020C   0x........         BL       twi_stop
    594          		status = twi_get_status(pTwi);
   \   00000210   0xE1B00008         MOVS     R0,R8
   \   00000214   0x........         BL       twi_get_status
   \   00000218   0xE1B0A000         MOVS     R10,R0
    595          		timeout = 0;
   \   0000021C   0xE3A00000         MOV      R0,#+0
   \   00000220   0xE1B0B000         MOVS     R11,R0
    596          		while (!(status & TWI_SR_TXCOMP) && (++timeout < TWITIMEOUTMAX)) {
   \                     ??twid_dma_write_12:
   \   00000224   0xE31A0001         TST      R10,#0x1
   \   00000228   0x1A000008         BNE      ??twid_dma_write_13
   \   0000022C   0xE29BB001         ADDS     R11,R11,#+1
   \   00000230   0xE3E004F0         MVN      R0,#-268435456
   \   00000234   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   00000238   0xE15B0000         CMP      R11,R0
   \   0000023C   0x2A000003         BCS      ??twid_dma_write_13
    597          			status = twi_get_status(pTwi);
   \   00000240   0xE1B00008         MOVS     R0,R8
   \   00000244   0x........         BL       twi_get_status
   \   00000248   0xE1B0A000         MOVS     R10,R0
   \   0000024C   0xEAFFFFF4         B        ??twid_dma_write_12
    598          		}
    599          		if (timeout == TWITIMEOUTMAX) {
   \                     ??twid_dma_write_13:
   \   00000250   0xE3E004F0         MVN      R0,#-268435456
   \   00000254   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   00000258   0xE15B0000         CMP      R11,R0
   \   0000025C   0x1A000001         BNE      ??twid_dma_write_14
    600          			TRACE_ERROR("TWID Timeout Write\n\r");
   \   00000260   0x........         LDR      R0,??DataTable10_13
   \   00000264   0x........         BL       printf
    601          		}
    602          		cp15_invalidate_dcache_for_dma((uint32_t) pData, (uint32_t) (pData));
   \                     ??twid_dma_write_14:
   \   00000268   0xE1B01004         MOVS     R1,R4
   \   0000026C   0xE1B00004         MOVS     R0,R4
   \   00000270   0x........         BL       cp15_invalidate_dcache_for_dma
    603          		XDMAD_FreeChannel(&twi_dma, dmaWriteChannel);
   \   00000274   0x........         LDR      R0,??DataTable9_8
   \   00000278   0xE5901000         LDR      R1,[R0, #+0]
   \   0000027C   0x........         LDR      R0,??DataTable9_5
   \   00000280   0x........         BL       XDMAD_FreeChannel
    604          	}
    605          	return 0;
   \                     ??twid_dma_write_7:
   \   00000284   0xE3A00000         MOV      R0,#+0
   \                     ??twid_dma_write_5:
   \   00000288   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   0000028C   0xE8BD8FF0         POP      {R4-R11,PC}      ;; return
    606          }
    607          
    608          /**
    609           * \brief Asynchronously sends data to a slave on the TWI bus. An optional callback
    610           * function is invoked whenever the transfer is complete.
    611           * \param pTwid  Pointer to a Twid instance.
    612           * \param address  TWI slave address.
    613           * \param iaddress  Optional slave internal address.
    614           * \param isize  Number of internal address bytes.
    615           * \param pData  Data buffer for storing received bytes.
    616           * \param num  Data buffer to send.
    617           * \param pAsync  Asynchronous transfer descriptor.
    618           * \return 0 if the transfer has been started; otherwise returns a TWI error code.
    619           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    620          uint8_t twid_write(struct _twid* pTwid, uint8_t address, uint32_t iaddress,
    621          	   uint8_t isize, uint8_t * pData, uint32_t num, Async * pAsync)
    622          {
   \                     twid_write:
   \   00000000   0xE92D4FFF         PUSH     {R0-R11,LR}
   \   00000004   0xE24DD004         SUB      SP,SP,#+4
   \   00000008   0xE59D9038         LDR      R9,[SP, #+56]
   \   0000000C   0xE59DA03C         LDR      R10,[SP, #+60]
   \   00000010   0xE59D4040         LDR      R4,[SP, #+64]
    623          	Twi *pTwi = pTwid->pTwi;
   \   00000014   0xE59D0004         LDR      R0,[SP, #+4]
   \   00000018   0xE5905000         LDR      R5,[R0, #+0]
    624          	struct _async_twi* pTransfer;
    625          	uint32_t timeout = 0;
   \   0000001C   0xE3A0B000         MOV      R11,#+0
    626          	uint32_t status;
    627          	uint8_t singleTransfer = 0;
   \   00000020   0xE3A08000         MOV      R8,#+0
    628          
    629          	assert(pTwi != NULL);
   \   00000024   0xE3550000         CMP      R5,#+0
   \   00000028   0x1A000004         BNE      ??twid_write_0
   \   0000002C   0xE3002275         MOVW     R2,#+629
   \   00000030   0x........         LDR      R1,??DataTable10_14
   \   00000034   0x........         LDR      R0,??DataTable10_4
   \   00000038   0x........         BL       __aeabi_assert
   \   0000003C   0x........         BL       __iar_EmptyStepPoint
    630          	assert((address & 0x80) == 0);
   \                     ??twid_write_0:
   \   00000040   0xE5DD0008         LDRB     R0,[SP, #+8]
   \   00000044   0xE3100080         TST      R0,#0x80
   \   00000048   0x0A000004         BEQ      ??twid_write_1
   \   0000004C   0xE3002276         MOVW     R2,#+630
   \   00000050   0x........         LDR      R1,??DataTable10_14
   \   00000054   0x........         LDR      R0,??DataTable10_5
   \   00000058   0x........         BL       __aeabi_assert
   \   0000005C   0x........         BL       __iar_EmptyStepPoint
    631          	assert((iaddress & 0xFF000000) == 0);
   \                     ??twid_write_1:
   \   00000060   0xE59D000C         LDR      R0,[SP, #+12]
   \   00000064   0xE31004FF         TST      R0,#0xFF000000
   \   00000068   0x0A000004         BEQ      ??twid_write_2
   \   0000006C   0xE3002277         MOVW     R2,#+631
   \   00000070   0x........         LDR      R1,??DataTable10_14
   \   00000074   0x........         LDR      R0,??DataTable10_6
   \   00000078   0x........         BL       __aeabi_assert
   \   0000007C   0x........         BL       __iar_EmptyStepPoint
    632          	assert(isize < 4);
   \                     ??twid_write_2:
   \   00000080   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000084   0xE3500004         CMP      R0,#+4
   \   00000088   0xBA000004         BLT      ??twid_write_3
   \   0000008C   0xE3A02F9E         MOV      R2,#+632
   \   00000090   0x........         LDR      R1,??DataTable10_14
   \   00000094   0x........         LDR      R0,??DataTable10_7
   \   00000098   0x........         BL       __aeabi_assert
   \   0000009C   0x........         BL       __iar_EmptyStepPoint
    633          
    634          	pTransfer = (struct _async_twi *) pTwid->pTransfer;
   \                     ??twid_write_3:
   \   000000A0   0xE59D0004         LDR      R0,[SP, #+4]
   \   000000A4   0xE5900004         LDR      R0,[R0, #+4]
   \   000000A8   0xE1B06000         MOVS     R6,R0
    635          	if (num == 1)
   \   000000AC   0xE35A0001         CMP      R10,#+1
   \   000000B0   0x1A000001         BNE      ??twid_write_4
    636          		singleTransfer = 1;
   \   000000B4   0xE3A00001         MOV      R0,#+1
   \   000000B8   0xE1B08000         MOVS     R8,R0
    637          	/* Check that no transfer is already pending */
    638          	if (pTransfer) {
   \                     ??twid_write_4:
   \   000000BC   0xE3560000         CMP      R6,#+0
   \   000000C0   0x0A000003         BEQ      ??twid_write_5
    639          		TRACE_ERROR("TWI_Write: A transfer is already pending\n\r");
   \   000000C4   0x........         LDR      R0,??DataTable10_11
   \   000000C8   0x........         BL       printf
    640          		return TWID_ERROR_BUSY;
   \   000000CC   0xE3A00001         MOV      R0,#+1
   \   000000D0   0xEA00007A         B        ??twid_write_6
    641          	}
    642          	/* Asynchronous transfer */
    643          	if (pAsync) {
   \                     ??twid_write_5:
   \   000000D4   0xE3540000         CMP      R4,#+0
   \   000000D8   0x0A000013         BEQ      ??twid_write_7
    644          		/* Update the transfer descriptor */
    645          		pTwid->pTransfer = pAsync;
   \   000000DC   0xE59D0004         LDR      R0,[SP, #+4]
   \   000000E0   0xE5804004         STR      R4,[R0, #+4]
    646          		pTransfer = (struct _async_twi*) pAsync;
   \   000000E4   0xE1B06004         MOVS     R6,R4
    647          		pTransfer->status = ASYNC_STATUS_PENDING;
   \   000000E8   0xE3A000FF         MOV      R0,#+255
   \   000000EC   0xE5860000         STR      R0,[R6, #+0]
    648          		pTransfer->pData = pData;
   \   000000F0   0xE5869008         STR      R9,[R6, #+8]
    649          		pTransfer->num = num;
   \   000000F4   0xE586A00C         STR      R10,[R6, #+12]
    650          		pTransfer->transferred = 1;
   \   000000F8   0xE3A00001         MOV      R0,#+1
   \   000000FC   0xE5860010         STR      R0,[R6, #+16]
    651          		/* Enable write interrupt and start the transfer */
    652          		twi_start_write(pTwi, address, iaddress, isize, *pData);
   \   00000100   0xE5D90000         LDRB     R0,[R9, #+0]
   \   00000104   0xE58D0000         STR      R0,[SP, #+0]
   \   00000108   0xE5DD3010         LDRB     R3,[SP, #+16]
   \   0000010C   0xE59D200C         LDR      R2,[SP, #+12]
   \   00000110   0xE5DD1008         LDRB     R1,[SP, #+8]
   \   00000114   0xE1B00005         MOVS     R0,R5
   \   00000118   0x........         BL       twi_start_write
    653          		twi_enable_it(pTwi, TWI_IER_TXRDY);
   \   0000011C   0xE3A01004         MOV      R1,#+4
   \   00000120   0xE1B00005         MOVS     R0,R5
   \   00000124   0x........         BL       twi_enable_it
   \   00000128   0xEA000063         B        ??twid_write_8
    654          	}
    655          	/* Synchronous transfer */
    656          	else {
    657          		// Start write
    658          		twi_start_write(pTwi, address, iaddress, isize, *pData++);
   \                     ??twid_write_7:
   \   0000012C   0xE5D90000         LDRB     R0,[R9, #+0]
   \   00000130   0xE58D0000         STR      R0,[SP, #+0]
   \   00000134   0xE5DD3010         LDRB     R3,[SP, #+16]
   \   00000138   0xE59D200C         LDR      R2,[SP, #+12]
   \   0000013C   0xE5DD1008         LDRB     R1,[SP, #+8]
   \   00000140   0xE1B00005         MOVS     R0,R5
   \   00000144   0x........         BL       twi_start_write
   \   00000148   0xE2999001         ADDS     R9,R9,#+1
    659          		num--;
   \   0000014C   0xE25AA001         SUBS     R10,R10,#+1
    660          		if (singleTransfer) {
   \   00000150   0xE1B00008         MOVS     R0,R8
   \   00000154   0xE6EF0070         UXTB     R0,R0
   \   00000158   0xE3500000         CMP      R0,#+0
   \   0000015C   0x0A000001         BEQ      ??twid_write_9
    661          			/* Send a STOP condition */
    662          			twi_send_stop_condition(pTwi);
   \   00000160   0xE1B00005         MOVS     R0,R5
   \   00000164   0x........         BL       twi_send_stop_condition
    663          		}
    664          		status = twi_get_status(pTwi);
   \                     ??twid_write_9:
   \   00000168   0xE1B00005         MOVS     R0,R5
   \   0000016C   0x........         BL       twi_get_status
   \   00000170   0xE1B07000         MOVS     R7,R0
    665          		if (status & TWI_SR_NACK)
   \   00000174   0xE3170F40         TST      R7,#0x100
   \   00000178   0x0A000001         BEQ      ??twid_write_10
    666          			TRACE_ERROR("TWID NACK error\n\r");
   \   0000017C   0x........         LDR      R0,??DataTable10_9
   \   00000180   0x........         BL       printf
    667          		while (!(status & TWI_SR_TXRDY) && (timeout++ < TWITIMEOUTMAX)) {
   \                     ??twid_write_10:
   \   00000184   0xE3170004         TST      R7,#0x4
   \   00000188   0x1A000009         BNE      ??twid_write_11
   \   0000018C   0xE1B0000B         MOVS     R0,R11
   \   00000190   0xE290B001         ADDS     R11,R0,#+1
   \   00000194   0xE3E014F0         MVN      R1,#-268435456
   \   00000198   0xE3C116FF         BIC      R1,R1,#0xFF00000
   \   0000019C   0xE1500001         CMP      R0,R1
   \   000001A0   0x2A000003         BCS      ??twid_write_11
    668          			status = twi_get_status(pTwi);
   \   000001A4   0xE1B00005         MOVS     R0,R5
   \   000001A8   0x........         BL       twi_get_status
   \   000001AC   0xE1B07000         MOVS     R7,R0
   \   000001B0   0xEAFFFFF3         B        ??twid_write_10
    669          		}
    670          		if (timeout == TWITIMEOUTMAX) {
   \                     ??twid_write_11:
   \   000001B4   0xE3E004F0         MVN      R0,#-268435456
   \   000001B8   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   000001BC   0xE15B0000         CMP      R11,R0
   \   000001C0   0x1A000001         BNE      ??twid_write_12
    671          			TRACE_ERROR("TWID Timeout BS\n\r");
   \   000001C4   0x........         LDR      R0,??DataTable10_15
   \   000001C8   0x........         BL       printf
    672          		}
    673          		timeout = 0;
   \                     ??twid_write_12:
   \   000001CC   0xE3A00000         MOV      R0,#+0
   \   000001D0   0xE1B0B000         MOVS     R11,R0
    674          		/* Send all bytes */
    675          		while (num > 0) {
   \                     ??twid_write_13:
   \   000001D4   0xE35A0000         CMP      R10,#+0
   \   000001D8   0x0A000020         BEQ      ??twid_write_14
    676          			/* Wait before sending the next byte */
    677          			timeout = 0;
   \   000001DC   0xE3A00000         MOV      R0,#+0
   \   000001E0   0xE1B0B000         MOVS     R11,R0
    678          			twi_write_byte(pTwi, *pData++);
   \   000001E4   0xE5D91000         LDRB     R1,[R9, #+0]
   \   000001E8   0xE1B00005         MOVS     R0,R5
   \   000001EC   0x........         BL       twi_write_byte
   \   000001F0   0xE2999001         ADDS     R9,R9,#+1
    679          			status = twi_get_status(pTwi);
   \   000001F4   0xE1B00005         MOVS     R0,R5
   \   000001F8   0x........         BL       twi_get_status
   \   000001FC   0xE1B07000         MOVS     R7,R0
    680          			if (status & TWI_SR_NACK)
   \   00000200   0xE3170F40         TST      R7,#0x100
   \   00000204   0x0A000001         BEQ      ??twid_write_15
    681          				TRACE_ERROR("TWID NACK error\n\r");
   \   00000208   0x........         LDR      R0,??DataTable10_9
   \   0000020C   0x........         BL       printf
    682          			while (!(status & TWI_SR_TXRDY)
    683          			       && (timeout++ < TWITIMEOUTMAX)) {
   \                     ??twid_write_15:
   \   00000210   0xE3170004         TST      R7,#0x4
   \   00000214   0x1A000009         BNE      ??twid_write_16
   \   00000218   0xE1B0000B         MOVS     R0,R11
   \   0000021C   0xE290B001         ADDS     R11,R0,#+1
   \   00000220   0xE3E014F0         MVN      R1,#-268435456
   \   00000224   0xE3C116FF         BIC      R1,R1,#0xFF00000
   \   00000228   0xE1500001         CMP      R0,R1
   \   0000022C   0x2A000003         BCS      ??twid_write_16
    684          				status = twi_get_status(pTwi);
   \   00000230   0xE1B00005         MOVS     R0,R5
   \   00000234   0x........         BL       twi_get_status
   \   00000238   0xE1B07000         MOVS     R7,R0
   \   0000023C   0xEAFFFFF3         B        ??twid_write_15
    685          			}
    686          			if (timeout == TWITIMEOUTMAX) {
   \                     ??twid_write_16:
   \   00000240   0xE3E004F0         MVN      R0,#-268435456
   \   00000244   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   00000248   0xE15B0000         CMP      R11,R0
   \   0000024C   0x1A000001         BNE      ??twid_write_17
    687          				TRACE_ERROR("TWID Timeout BS\n\r");
   \   00000250   0x........         LDR      R0,??DataTable10_15
   \   00000254   0x........         BL       printf
    688          			}
    689          			num--;
   \                     ??twid_write_17:
   \   00000258   0xE25AA001         SUBS     R10,R10,#+1
   \   0000025C   0xEAFFFFDC         B        ??twid_write_13
    690          		}
    691          		/* Wait for actual end of transfer */
    692          		timeout = 0;
   \                     ??twid_write_14:
   \   00000260   0xE3A00000         MOV      R0,#+0
   \   00000264   0xE1B0B000         MOVS     R11,R0
    693          		if (!singleTransfer) {
   \   00000268   0xE1B00008         MOVS     R0,R8
   \   0000026C   0xE6EF0070         UXTB     R0,R0
   \   00000270   0xE3500000         CMP      R0,#+0
   \   00000274   0x1A000001         BNE      ??twid_write_18
    694          			/* Send a STOP condition */
    695          			twi_send_stop_condition(pTwi);
   \   00000278   0xE1B00005         MOVS     R0,R5
   \   0000027C   0x........         BL       twi_send_stop_condition
    696          		}
    697          		while (!twi_is_transfer_complete(pTwi)
    698          		       && (++timeout < TWITIMEOUTMAX)) ;
   \                     ??twid_write_18:
   \   00000280   0xE1B00005         MOVS     R0,R5
   \   00000284   0x........         BL       twi_is_transfer_complete
   \   00000288   0xE3500000         CMP      R0,#+0
   \   0000028C   0x1A000004         BNE      ??twid_write_19
   \   00000290   0xE29BB001         ADDS     R11,R11,#+1
   \   00000294   0xE3E004F0         MVN      R0,#-268435456
   \   00000298   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   0000029C   0xE15B0000         CMP      R11,R0
   \   000002A0   0x3AFFFFF6         BCC      ??twid_write_18
    699          		if (timeout == TWITIMEOUTMAX) {
   \                     ??twid_write_19:
   \   000002A4   0xE3E004F0         MVN      R0,#-268435456
   \   000002A8   0xE3C006FF         BIC      R0,R0,#0xFF00000
   \   000002AC   0xE15B0000         CMP      R11,R0
   \   000002B0   0x1A000001         BNE      ??twid_write_8
    700          			TRACE_ERROR("TWID Timeout TC2\n\r");
   \   000002B4   0x........         LDR      R0,??DataTable10_16
   \   000002B8   0x........         BL       printf
    701          		}
    702          	}
    703          	return 0;
   \                     ??twid_write_8:
   \   000002BC   0xE3A00000         MOV      R0,#+0
   \                     ??twid_write_6:
   \   000002C0   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000002C4   0xE8BD8FF0         POP      {R4-R11,PC}      ;; return
    704          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xF8034600         DC32     0xf8034600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xF8038600         DC32     0xf8038600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0xFC010600         DC32     0xfc010600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0xFC014600         DC32     0xfc014600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0xFC018600         DC32     0xfc018600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     twi_dma

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     dmaReadChannel

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     dmaWriteChannel

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0xF8034634         DC32     0xf8034634

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     dmaWriteLinkList

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     twi_dmaCfg

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xF8034630         DC32     0xf8034630

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     dmaReadLinkList

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     ?_7

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     ?_8

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     ?_9

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     ?_10

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     ?_11

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     ?_12

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     ?_13

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     ?_14

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2D 0x45          DC8 "-E- Can't allocate XDMA channel\012\015"
   \              0x2D 0x20    
   \              0x43 0x61    
   \              0x6E 0x27    
   \              0x74 0x20    
   \              0x61 0x6C    
   \              0x6C 0x6F    
   \              0x63 0x61    
   \              0x74 0x65    
   \              0x20 0x58    
   \              0x44 0x4D    
   \              0x41 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x0A    
   \              0x0D 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x70 0x54          DC8 "pTwid != NULL"
   \              0x77 0x69    
   \              0x64 0x20    
   \              0x21 0x3D    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 62H, 75H, 73H, 5CH
   \              0x73 0x5C    
   \              0x62 0x75    
   \              0x73 0x5C    
   \   00000038   0x74 0x77          DC8 74H, 77H, 69H, 64H, 2EH, 63H, 0
   \              0x69 0x64    
   \              0x2E 0x63    
   \              0x00         
   \   0000003F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x70 0x54          DC8 "pTwi != NULL"
   \              0x77 0x69    
   \              0x20 0x21    
   \              0x3D 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x70 0x54          DC8 "pTransfer != NULL"
   \              0x72 0x61    
   \              0x6E 0x73    
   \              0x66 0x65    
   \              0x72 0x20    
   \              0x21 0x3D    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x28 0x61          DC8 "(address & 0x80) == 0"
   \              0x64 0x64    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x20 0x26    
   \              0x20 0x30    
   \              0x78 0x38    
   \              0x30 0x29    
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x30 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x28 0x69          DC8 "(iaddress & 0xFF000000) == 0"
   \              0x61 0x64    
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x26 0x20    
   \              0x30 0x78    
   \              0x46 0x46    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x29 0x20    
   \              0x3D 0x3D    
   \              0x20 0x30    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x69 0x73          DC8 "isize < 4"
   \              0x69 0x7A    
   \              0x65 0x20    
   \              0x3C 0x20    
   \              0x34 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x2D 0x45          DC8 "-E- twid_read: A transfer is already pending\012\015"
   \              0x2D 0x20    
   \              0x74 0x77    
   \              0x69 0x64    
   \              0x5F 0x72    
   \              0x65 0x61    
   \              0x64 0x3A    
   \              0x20 0x41    
   \              0x20 0x74    
   \              0x72 0x61    
   \              0x6E 0x73    
   \              0x66 0x65    
   \              0x72 0x20    
   \              0x69 0x73    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x70    
   \              0x65 0x6E    
   \              0x64 0x69    
   \              0x6E 0x67    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x2D 0x45          DC8 "-E- TWID NACK error\012\015"
   \              0x2D 0x20    
   \              0x54 0x57    
   \              0x49 0x44    
   \              0x20 0x4E    
   \              0x41 0x43    
   \              0x4B 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x0A    
   \              0x0D 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x2D 0x45          DC8 "-E- TWID Timeout Read\012\015"
   \              0x2D 0x20    
   \              0x54 0x57    
   \              0x49 0x44    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x20 0x52    
   \              0x65 0x61    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x2D 0x45          DC8 "-E- TWI_Write: A transfer is already pending\012\015"
   \              0x2D 0x20    
   \              0x54 0x57    
   \              0x49 0x5F    
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x3A    
   \              0x20 0x41    
   \              0x20 0x74    
   \              0x72 0x61    
   \              0x6E 0x73    
   \              0x66 0x65    
   \              0x72 0x20    
   \              0x69 0x73    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x70    
   \              0x65 0x6E    
   \              0x64 0x69    
   \              0x6E 0x67    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x2D 0x45          DC8 "-E- TWID Timeout TXRDY\012\015"
   \              0x2D 0x20    
   \              0x54 0x57    
   \              0x49 0x44    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x20 0x54    
   \              0x58 0x52    
   \              0x44 0x59    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x2D 0x45          DC8 "-E- TWID Timeout Write\012\015"
   \              0x2D 0x20    
   \              0x54 0x57    
   \              0x49 0x44    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x20 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x2D 0x45          DC8 "-E- TWID Timeout BS\012\015"
   \              0x2D 0x20    
   \              0x54 0x57    
   \              0x49 0x44    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x20 0x42    
   \              0x53 0x0A    
   \              0x0D 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x2D 0x45          DC8 "-E- TWID Timeout TC2\012\015"
   \              0x2D 0x20    
   \              0x54 0x57    
   \              0x49 0x44    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x20 0x54    
   \              0x43 0x32    
   \              0x0A 0x0D    
   \              0x00         
   \   00000017   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   _xdma_configure_read
        40   -> XDMAD_ConfigureTransfer
        40   -> XDMAIF_Get_ChannelNumber
        40   -> cp15_coherent_dcache_for_dma
        40   -> get_twi_addr_from_id
      40   _xdma_configure_write
        40   -> XDMAD_ConfigureTransfer
        40   -> XDMAIF_Get_ChannelNumber
        40   -> cp15_coherent_dcache_for_dma
        40   -> get_twi_addr_from_id
       0   get_twi_addr_from_id
       8   twid_dma_initialize_read
         8   -> XDMAD_AllocateChannel
         8   -> XDMAD_PrepareChannel
         8   -> printf
       8   twid_dma_initialize_write
         8   -> XDMAD_AllocateChannel
         8   -> XDMAD_PrepareChannel
         8   -> printf
      56   twid_dma_read
        56   -> XDMAD_FreeChannel
        56   -> XDMAD_IsTransferDone
        56   -> XDMAD_StartTransfer
        56   -> XDMAD_StopTransfer
        56   -> __aeabi_assert
        56   -> __iar_EmptyStepPoint
        56   -> _xdma_configure_read
        56   -> printf
        56   -> twi_enable_it
        56   -> twi_get_status
        56   -> twi_read_byte
        56   -> twi_start_read
        56   -> twi_stop
        56   -> twid_dma_initialize_read
      56   twid_dma_write
        56   -> XDMAD_FreeChannel
        56   -> XDMAD_IsTransferDone
        56   -> XDMAD_StartTransfer
        56   -> XDMAD_StopTransfer
        56   -> __aeabi_assert
        56   -> __iar_EmptyStepPoint
        56   -> _xdma_configure_write
        56   -> cp15_coherent_dcache_for_dma
        56   -> cp15_invalidate_dcache_for_dma
        56   -> printf
        56   -> twi_enable_it
        56   -> twi_get_status
        56   -> twi_start_write
        56   -> twi_stop
        56   -> twid_dma_initialize_write
      24   twid_handler
        24   -- Indirect call
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> twi_enable_it
        24   -> twi_get_masked_status
        24   -> twi_read_byte
        24   -> twi_send_stop_condition
        24   -> twi_stop
        24   -> twi_write_byte
      16   twid_initialize
        16   -> XDMAD_Initialize
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      56   twid_read
        56   -> __aeabi_assert
        56   -> __iar_EmptyStepPoint
        56   -> printf
        56   -> twi_enable_it
        56   -> twi_get_status
        56   -> twi_read_byte
        56   -> twi_start_read
        56   -> twi_stop
      56   twid_write
        56   -> __aeabi_assert
        56   -> __iar_EmptyStepPoint
        56   -> printf
        56   -> twi_enable_it
        56   -> twi_get_status
        56   -> twi_is_transfer_complete
        56   -> twi_send_stop_condition
        56   -> twi_start_write
        56   -> twi_write_byte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      36  ?_0
      16  ?_1
      24  ?_10
      48  ?_11
      28  ?_12
      28  ?_13
      24  ?_14
      24  ?_15
      64  ?_2
      16  ?_3
      20  ?_4
      24  ?_5
      32  ?_6
      12  ?_7
      48  ?_8
      24  ?_9
      56  _id_h64_matrix
     340  _xdma_configure_read
     340  _xdma_configure_write
       4  dmaReadChannel
      16  dmaReadLinkList
       4  dmaWriteChannel
      16  dmaWriteLinkList
     132  get_twi_addr_from_id
     524  twi_dma
      32  twi_dmaCfg
      88  twid_dma_initialize_read
      88  twid_dma_initialize_write
     632  twid_dma_read
     656  twid_dma_write
     396  twid_handler
      96  twid_initialize
     700  twid_read
     712  twid_write

 
   596 bytes in section .bss
   524 bytes in section .rodata
 4 304 bytes in section SOFTPACK
 
 4 304 bytes of CODE  memory
   524 bytes of CONST memory
   596 bytes of DATA  memory

Errors: none
Warnings: 1
