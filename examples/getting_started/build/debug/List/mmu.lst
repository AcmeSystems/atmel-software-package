###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\mmu.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\mmu.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\mmu.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\mmu.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\core\mmu.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2013, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \file */
     31          
     32          /**
     33           * \addtogroup mmu MMU Initialization
     34           *
     35           * \section Usage
     36           *
     37           * Translation Lookaside Buffers (TLBs) are an implementation technique that caches translations or
     38           * translation table entries. TLBs avoid the requirement for every memory access to perform a translation table
     39           * lookup. The ARM architecture does not specify the exact form of the TLB structures for any design. In a
     40           * similar way to the requirements for caches, the architecture only defines certain principles for TLBs:
     41           *
     42           * The MMU supports memory accesses based on memory sections or pages:
     43           * Supersections Consist of 16MB blocks of memory. Support for Supersections is optional.
     44           * -# Sections Consist of 1MB blocks of memory.
     45           * -# Large pages Consist of 64KB blocks of memory.
     46           * -# Small pages Consist of 4KB blocks of memory.
     47           *
     48           * Access to a memory region is controlled by the access permission bits and the domain field in the TLB entry.
     49           * Memory region attributes
     50           * Each TLB entry has an associated set of memory region attributes. These control accesses to the caches,
     51           * how the write buffer is used, and if the memory region is Shareable and therefore must be kept coherent.
     52           *
     53           * Related files:\n
     54           * \ref mmu.c\n
     55           * \ref mmu.h \n
     56           */
     57          
     58          /*------------------------------------------------------------------------------ */
     59          /*         Headers                                                               */
     60          /*------------------------------------------------------------------------------ */
     61          #include <chip.h>

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     62          #include "core/mmu.h"
     63          
     64          /*------------------------------------------------------------------------------ */
     65          /*         Exported functions */
     66          /*------------------------------------------------------------------------------ */
     67          
     68          /**
     69           * \brief Initializes MMU.
     70           * \param pTB  Address of the translation table.
     71           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     72          void
     73          MMU_Initialize(uint32_t * pTB)
     74          {
   \                     MMU_Initialize:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     75          	unsigned int index;
     76          	unsigned int addr;
     77          
     78          	/* Reset table entries */
     79          	for (index = 0; index < 4096; index++)
   \   00000008   0xE3A00000         MOV      R0,#+0
   \   0000000C   0xE1B06000         MOVS     R6,R0
   \                     ??MMU_Initialize_0:
   \   00000010   0xE3560D40         CMP      R6,#+4096
   \   00000014   0x2A000004         BCS      ??MMU_Initialize_1
     80          		pTB[index] = 0;
   \   00000018   0xE3A00000         MOV      R0,#+0
   \   0000001C   0xE1B01106         LSLS     R1,R6,#+2
   \   00000020   0xE7810004         STR      R0,[R1, +R4]
   \   00000024   0xE2966001         ADDS     R6,R6,#+1
   \   00000028   0xEAFFFFF8         B        ??MMU_Initialize_0
     81          
     82          	/* section Boot (code + data) */
     83          	/* ROM address (after remap) 0x0000_0000 */
     84          	pTB[0x000] = (0x000 << 20) |	// Physical Address
     85          	    (3 << 10) |		// Access in supervisor mode (AP)
     86          	    (0xF << 5) |	// Domain 0xF
     87          	    (1 << 4) |		// (XN)
     88          	    (0 << 3) |		// C bit : cachable => NO
     89          	    (1 << 2) |		// B bit : write-back => YES
     90          	    (2 << 0);		// Set as 1 Mbyte section
   \                     ??MMU_Initialize_1:
   \   0000002C   0xE3000DF6         MOVW     R0,#+3574
   \   00000030   0xE5840000         STR      R0,[R4, #+0]
     91          
     92          	/* section ROM (code + data) */
     93          	/* ROM address (after remap) 0x0010_0000 */
     94          	pTB[0x001] = (0x001 << 20) |	// Physical Address
     95          	    (3 << 10) |		// Access in supervisor mode (AP)
     96          	    (0xF << 5) |	// Domain 0xF
     97          	    (1 << 4) |		// (XN)
     98          	    (0 << 3) |		// C bit : cachable => NO
     99          	    (1 << 2) |		// B bit : write-back => YES
    100          	    (2 << 0);		// Set as 1 Mbyte section
   \   00000034   0xE59F01B4         LDR      R0,??MMU_Initialize_2  ;; 0x100df6
   \   00000038   0xE5840004         STR      R0,[R4, #+4]
    101          	/* section RAM 0 */
    102          	/* SRAM address (after remap) 0x0030_0000 */
    103          	pTB[0x002] = (0x002 << 20) |	// Physical Address
    104          	    (1 << 12) |		// TEX[0]
    105          	    (3 << 10) |		// Access in supervisor mode (AP)
    106          	    (0xF << 5) |	// Domain 0xF
    107          	    (1 << 4) |		// (XN)
    108          	    (1 << 3) |		// C bit : cachable => YES
    109          	    (1 << 2) |		// B bit : write-back => YES
    110          	    (2 << 0);		// Set as 1 Mbyte section
   \   0000003C   0xE59F01B0         LDR      R0,??MMU_Initialize_2+0x4  ;; 0x201dfe
   \   00000040   0xE5840008         STR      R0,[R4, #+8]
    111          
    112          	/* section NFC SRAM  */
    113          	/* SRAM address 0x0040_0000 */
    114          	for (addr = 0x3; addr < 0xB; addr++)
   \   00000044   0xE3A00003         MOV      R0,#+3
   \   00000048   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_3:
   \   0000004C   0xE355000B         CMP      R5,#+11
   \   00000050   0x2A000005         BCS      ??MMU_Initialize_4
    115          		pTB[addr] = (addr << 20) |	// Physical Address
    116          		    (3 << 10) |	// Access in supervisor mode (AP)
    117          		    (0xF << 5) |	// Domain 0xF
    118          		    (1 << 4) |	// (XN)
    119          		    (0 << 3) |	// C bit : cachable => NO
    120          		    (1 << 2) |	// B bit : write-back => YES
    121          		    (2 << 0);	// Set as 1 Mbyte section
   \   00000054   0xE3000DF6         MOVW     R0,#+3574
   \   00000058   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   0000005C   0xE1B01105         LSLS     R1,R5,#+2
   \   00000060   0xE7810004         STR      R0,[R1, +R4]
   \   00000064   0xE2955001         ADDS     R5,R5,#+1
   \   00000068   0xEAFFFFF7         B        ??MMU_Initialize_3
    122          
    123          	/* section PERIPH */
    124          	/* periph address 0xF000_0000 */
    125          	pTB[0xF00] = (0xF00ul << 20) |	// Physical Address
    126          	    (3 << 10) |		// Access in supervisor mode (AP)
    127          	    (0xF << 5) |	// Domain 0
    128          	    (1 << 4) |		// (XN)
    129          	    (0 << 3) |		// C bit : cachable => NO
    130          	    (0 << 2) |		// B bit : write-back => NO
    131          	    (2 << 0);		// Set as 1 Mbyte section
   \                     ??MMU_Initialize_4:
   \   0000006C   0xE3A003BC         MOV      R0,#-268435454
   \   00000070   0xE3800EDF         ORR      R0,R0,#0xDF0
   \   00000074   0xE2941DF0         ADDS     R1,R4,#+15360
   \   00000078   0xE5810000         STR      R0,[R1, #+0]
    132          
    133          	/* section PERIPH */
    134          	/* periph address 0xF800_0000 */
    135          	pTB[0xF80] = (0xF80ul << 20) |	// Physical Address
    136          	    (3 << 10) |		// Access in supervisor mode (AP)
    137          	    (0xF << 5) |	// Domain 0xF
    138          	    (1 << 4) |		// (XN)
    139          	    (0 << 3) |		// C bit : cachable => NO
    140          	    (0 << 2) |		// B bit : write-back => NO
    141          	    (2 << 0);		// Set as 1 Mbyte section
   \   0000007C   0xE3A003BE         MOV      R0,#-134217726
   \   00000080   0xE3800EDF         ORR      R0,R0,#0xDF0
   \   00000084   0xE2941DF8         ADDS     R1,R4,#+15872
   \   00000088   0xE5810000         STR      R0,[R1, #+0]
    142          
    143          	/* section PERIPH */
    144          	/* periph address 0xFC00_0000 */
    145          	pTB[0xFC0] = (0xFC0ul << 20) |	// Physical Address
    146          	    (3 << 10) |		// Access in supervisor mode (AP)
    147          	    (0xF << 5) |	// Domain 0xF
    148          	    (1 << 4) |		// (XN)
    149          	    (0 << 3) |		// C bit : cachable => NO
    150          	    (0 << 2) |		// B bit : write-back => NO
    151          	    (2 << 0);		// Set as 1 Mbyte section
   \   0000008C   0xE3A003BF         MOV      R0,#-67108862
   \   00000090   0xE3800EDF         ORR      R0,R0,#0xDF0
   \   00000094   0xE2941DFC         ADDS     R1,R4,#+16128
   \   00000098   0xE5810000         STR      R0,[R1, #+0]
    152          
    153          	/* section EBI CS0 */
    154          	/* periph address 0x1000_0000 */
    155          	for (addr = 0x100; addr < 0x200; addr++)
   \   0000009C   0xE3A00F40         MOV      R0,#+256
   \   000000A0   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_5:
   \   000000A4   0xE3550F80         CMP      R5,#+512
   \   000000A8   0x2A000005         BCS      ??MMU_Initialize_6
    156          		pTB[addr] = (addr << 20) |	// Physical Address
    157          		    (3 << 10) |	// Access in supervisor mode (AP)
    158          		    (0xF << 5) |	// Domain 0
    159          		    (1 << 4) |	// (XN)
    160          		    (0 << 3) |	// C bit : cachable => NO
    161          		    (0 << 2) |	// B bit : write-back => NO
    162          		    (2 << 0);	// Set as 1 Mbyte section
   \   000000AC   0xE3000DF2         MOVW     R0,#+3570
   \   000000B0   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   000000B4   0xE1B01105         LSLS     R1,R5,#+2
   \   000000B8   0xE7810004         STR      R0,[R1, +R4]
   \   000000BC   0xE2955001         ADDS     R5,R5,#+1
   \   000000C0   0xEAFFFFF7         B        ??MMU_Initialize_5
    163          
    164          	/* section EBI CS1 */
    165          	/* periph address 0x6000_0000 */
    166          	for (addr = 0x600; addr < 0x700; addr++)
   \                     ??MMU_Initialize_6:
   \   000000C4   0xE3A00E60         MOV      R0,#+1536
   \   000000C8   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_7:
   \   000000CC   0xE3550E70         CMP      R5,#+1792
   \   000000D0   0x2A000005         BCS      ??MMU_Initialize_8
    167          		pTB[addr] = (addr << 20) |	// Physical Address
    168          		    (3 << 10) |	// Access in supervisor mode (AP)
    169          		    (0xF << 5) |	// Domain 0xF
    170          		    (1 << 4) |	// (XN)
    171          		    (0 << 3) |	// C bit : cachable => NO
    172          		    (0 << 2) |	// B bit : write-back => NO
    173          		    (2 << 0);	// Set as 1 Mbyte section
   \   000000D4   0xE3000DF2         MOVW     R0,#+3570
   \   000000D8   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   000000DC   0xE1B01105         LSLS     R1,R5,#+2
   \   000000E0   0xE7810004         STR      R0,[R1, +R4]
   \   000000E4   0xE2955001         ADDS     R5,R5,#+1
   \   000000E8   0xEAFFFFF7         B        ??MMU_Initialize_7
    174          
    175          	/* section EBI CS2 */
    176          	/* periph address 0x7000_0000 */
    177          	for (addr = 0x700; addr < 0x800; addr++)
   \                     ??MMU_Initialize_8:
   \   000000EC   0xE3A00E70         MOV      R0,#+1792
   \   000000F0   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_9:
   \   000000F4   0xE3550E80         CMP      R5,#+2048
   \   000000F8   0x2A000005         BCS      ??MMU_Initialize_10
    178          		pTB[addr] = (addr << 20) |	// Physical Address
    179          		    (3 << 10) |	// Access in supervisor mode (AP)
    180          		    (0xF << 5) |	// Domain 0xF
    181          		    (1 << 4) |	// (XN)
    182          		    (0 << 3) |	// C bit : cachable => NO
    183          		    (0 << 2) |	// B bit : write-back => NO
    184          		    (2 << 0);	// Set as 1 Mbyte section
   \   000000FC   0xE3000DF2         MOVW     R0,#+3570
   \   00000100   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   00000104   0xE1B01105         LSLS     R1,R5,#+2
   \   00000108   0xE7810004         STR      R0,[R1, +R4]
   \   0000010C   0xE2955001         ADDS     R5,R5,#+1
   \   00000110   0xEAFFFFF7         B        ??MMU_Initialize_9
    185          
    186          	/* section EBI CS3 */
    187          	/* periph address 0x8000_0000 */
    188          	for (addr = 0x800; addr < 0x880; addr++)
   \                     ??MMU_Initialize_10:
   \   00000114   0xE3A00E80         MOV      R0,#+2048
   \   00000118   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_11:
   \   0000011C   0xE3550E88         CMP      R5,#+2176
   \   00000120   0x2A000005         BCS      ??MMU_Initialize_12
    189          		pTB[addr] = (addr << 20) |	// Physical Address
    190          		    (3 << 10) |	// Access in supervisor mode (AP)
    191          		    (0xF << 5) |	// Domain 0xF
    192          		    (1 << 4) |	// (XN)
    193          		    (0 << 3) |	// C bit : cachable => NO
    194          		    (0 << 2) |	// B bit : write-back => NO
    195          		    (2 << 0);	// Set as 1 Mbyte section
   \   00000124   0xE3000DF2         MOVW     R0,#+3570
   \   00000128   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   0000012C   0xE1B01105         LSLS     R1,R5,#+2
   \   00000130   0xE7810004         STR      R0,[R1, +R4]
   \   00000134   0xE2955001         ADDS     R5,R5,#+1
   \   00000138   0xEAFFFFF7         B        ??MMU_Initialize_11
    196          
    197          	/* section NFC */
    198          	/* periph address 0x9000_0000 */
    199          	for (addr = 0x900; addr < 0xA00; addr++)
   \                     ??MMU_Initialize_12:
   \   0000013C   0xE3A00E90         MOV      R0,#+2304
   \   00000140   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_13:
   \   00000144   0xE3550EA0         CMP      R5,#+2560
   \   00000148   0x2A000005         BCS      ??MMU_Initialize_14
    200          		pTB[addr] = (addr << 20) |	// Physical Address
    201          		    (3 << 10) |	// Access in supervisor mode (AP)
    202          		    (0xF << 5) |	// Domain 0xF
    203          		    (1 << 4) |	// (XN)
    204          		    (0 << 3) |	// C bit : cachable => NO
    205          		    (0 << 2) |	// B bit : write-back => NO
    206          		    (2 << 0);	// Set as 1 Mbyte section
   \   0000014C   0xE3000DF2         MOVW     R0,#+3570
   \   00000150   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   00000154   0xE1B01105         LSLS     R1,R5,#+2
   \   00000158   0xE7810004         STR      R0,[R1, +R4]
   \   0000015C   0xE2955001         ADDS     R5,R5,#+1
   \   00000160   0xEAFFFFF7         B        ??MMU_Initialize_13
    207          
    208          	/* section SDRAM/DDRAM */
    209          	/* periph address 0x2000_0000 */
    210          	for (addr = 0x200; addr < 0x240; addr++)
   \                     ??MMU_Initialize_14:
   \   00000164   0xE3A00F80         MOV      R0,#+512
   \   00000168   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_15:
   \   0000016C   0xE3550F90         CMP      R5,#+576
   \   00000170   0x2A000005         BCS      ??MMU_Initialize_16
    211          		pTB[addr] = (addr << 20) |	// Physical Address
    212          		    (3 << 10) |	// Access in supervisor mode (AP)
    213          		    //(0x1 << 14)|   // TEX[2]
    214          		    (0x1 << 12) |	// TEX[1:0]
    215          		    (0xF << 5) |	// Domain 0xF
    216          		    (1 << 3) |	// C bit : cachable => YES
    217          		    (1 << 2) |	// B bit : write-back => YES
    218          		    (2 << 0);	// Set as 1 Mbyte section
   \   00000174   0xE3010DEE         MOVW     R0,#+7662
   \   00000178   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   0000017C   0xE1B01105         LSLS     R1,R5,#+2
   \   00000180   0xE7810004         STR      R0,[R1, +R4]
   \   00000184   0xE2955001         ADDS     R5,R5,#+1
   \   00000188   0xEAFFFFF7         B        ??MMU_Initialize_15
    219          
    220          	/* section SDRAM/DDRAM */
    221          	/* periph address 0x2400_0000 */
    222          	for (addr = 0x240; addr < 0x400; addr++)
   \                     ??MMU_Initialize_16:
   \   0000018C   0xE3A00F90         MOV      R0,#+576
   \   00000190   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_17:
   \   00000194   0xE3550E40         CMP      R5,#+1024
   \   00000198   0x2A000005         BCS      ??MMU_Initialize_18
    223          		pTB[addr] = (addr << 20) |	// Physical Address
    224          		    (1 << 19) |	// (NS)  Non-secure access is allowed
    225          		    (3 << 10) |	// Access in supervisor mode (AP)
    226          		    (0xF << 5) |	// Domain 0xF
    227          		    (1 << 4) |	// (XN)
    228          		    (0 << 3) |	// C bit : cachable => No
    229          		    (0 << 2) |	// B bit : write-back => No
    230          		    (2 << 0);	// Set as 1 Mbyte section
   \   0000019C   0xE59F0054         LDR      R0,??MMU_Initialize_2+0x8  ;; 0x80df2
   \   000001A0   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   000001A4   0xE1B01105         LSLS     R1,R5,#+2
   \   000001A8   0xE7810004         STR      R0,[R1, +R4]
   \   000001AC   0xE2955001         ADDS     R5,R5,#+1
   \   000001B0   0xEAFFFFF7         B        ??MMU_Initialize_17
    231          
    232          	/* section DDRCS/AES */
    233          	/* periph address 0x4000_0000 */
    234          	for (addr = 0x400; addr < 0x600; addr++)
   \                     ??MMU_Initialize_18:
   \   000001B4   0xE3A00E40         MOV      R0,#+1024
   \   000001B8   0xE1B05000         MOVS     R5,R0
   \                     ??MMU_Initialize_19:
   \   000001BC   0xE3550E60         CMP      R5,#+1536
   \   000001C0   0x2A000005         BCS      ??MMU_Initialize_20
    235          		pTB[addr] = (addr << 20) |	// Physical Address
    236          		    (3 << 10) |	// Access in supervisor mode (AP)
    237          		    (1 << 12) |	// TEX[0]
    238          		    (0xF << 5) |	// Domain 0xF
    239          		    (1 << 3) |	// C bit : cachable => YES
    240          		    (1 << 2) |	// B bit : write-back => YES
    241          		    (2 << 0);	// Set as 1 Mbyte section
   \   000001C4   0xE3010DEE         MOVW     R0,#+7662
   \   000001C8   0xE1900A05         ORRS     R0,R0,R5, LSL #+20
   \   000001CC   0xE1B01105         LSLS     R1,R5,#+2
   \   000001D0   0xE7810004         STR      R0,[R1, +R4]
   \   000001D4   0xE2955001         ADDS     R5,R5,#+1
   \   000001D8   0xEAFFFFF7         B        ??MMU_Initialize_19
    242          
    243          	cp15_write_ttb((unsigned int) pTB);
   \                     ??MMU_Initialize_20:
   \   000001DC   0xE1B00004         MOVS     R0,R4
   \   000001E0   0x........         BL       cp15_write_ttb
    244          	/* Program the domain access register */
    245          	cp15_write_domain_access_control(0xC0000000);	// only domain 15: access are not checked
   \   000001E4   0xE3A004C0         MOV      R0,#-1073741824
   \   000001E8   0x........         BL       cp15_write_domain_access_control
    246          }
   \   000001EC   0xE8BD8070         POP      {R4-R6,PC}       ;; return
   \                     ??MMU_Initialize_2:
   \   000001F0   0x00100DF6         DC32     0x100df6
   \   000001F4   0x00201DFE         DC32     0x201dfe
   \   000001F8   0x00080DF2         DC32     0x80df2

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MMU_Initialize
        16   -> cp15_write_domain_access_control
        16   -> cp15_write_ttb


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     508  MMU_Initialize
      56  _id_h64_matrix

 
  56 bytes in section .rodata
 508 bytes in section SOFTPACK
 
 508 bytes of CODE  memory
  56 bytes of CONST memory

Errors: none
Warnings: 1
