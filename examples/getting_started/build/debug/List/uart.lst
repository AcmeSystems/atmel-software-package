###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:07
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\serial\uart.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\serial\uart.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\uart.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\uart.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\serial\uart.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*------------------------------------------------------------------------------
     31           *         Headers
     32           *------------------------------------------------------------------------------*/
     33          
     34          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp uint32_t get_uart_id_from_addr(Uart const *)
   \                     get_uart_id_from_addr:
   \   00000000   0xE1B01000         MOVS     R1,R0
   \   00000004   0xE3A004F8         MOV      R0,#-134217728
   \   00000008   0xE3800B70         ORR      R0,R0,#0x1C000
   \   0000000C   0xE1510000         CMP      R1,R0
   \   00000010   0x1A000001         BNE      ??get_uart_id_from_addr_0
   \   00000014   0xE3A00018         MOV      R0,#+24
   \   00000018   0xEA000018         B        ??get_uart_id_from_addr_1
   \                     ??get_uart_id_from_addr_0:
   \   0000001C   0xE3A004F8         MOV      R0,#-134217728
   \   00000020   0xE3800B80         ORR      R0,R0,#0x20000
   \   00000024   0xE1510000         CMP      R1,R0
   \   00000028   0x1A000001         BNE      ??get_uart_id_from_addr_2
   \   0000002C   0xE3A00019         MOV      R0,#+25
   \   00000030   0xEA000012         B        ??get_uart_id_from_addr_1
   \                     ??get_uart_id_from_addr_2:
   \   00000034   0xE3A004F8         MOV      R0,#-134217728
   \   00000038   0xE3800B90         ORR      R0,R0,#0x24000
   \   0000003C   0xE1510000         CMP      R1,R0
   \   00000040   0x1A000001         BNE      ??get_uart_id_from_addr_3
   \   00000044   0xE3A0001A         MOV      R0,#+26
   \   00000048   0xEA00000C         B        ??get_uart_id_from_addr_1
   \                     ??get_uart_id_from_addr_3:
   \   0000004C   0xE3A004FC         MOV      R0,#-67108864
   \   00000050   0xE3800C80         ORR      R0,R0,#0x8000
   \   00000054   0xE1510000         CMP      R1,R0
   \   00000058   0x1A000001         BNE      ??get_uart_id_from_addr_4
   \   0000005C   0xE3A0001B         MOV      R0,#+27
   \   00000060   0xEA000006         B        ??get_uart_id_from_addr_1
   \                     ??get_uart_id_from_addr_4:
   \   00000064   0xE3A004FC         MOV      R0,#-67108864
   \   00000068   0xE3800CC0         ORR      R0,R0,#0xC000
   \   0000006C   0xE1510000         CMP      R1,R0
   \   00000070   0x1A000001         BNE      ??get_uart_id_from_addr_5
   \   00000074   0xE3A0001C         MOV      R0,#+28
   \   00000078   0xEA000000         B        ??get_uart_id_from_addr_1
   \                     ??get_uart_id_from_addr_5:
   \   0000007C   0xE3A0004F         MOV      R0,#+79
   \                     ??get_uart_id_from_addr_1:
   \   00000080   0xE12FFF1E         BX       LR               ;; return
     35          #include "serial/uart.h"
     36          #include "core/pmc.h"
     37          
     38          #include <stdint.h>
     39          
     40          /*------------------------------------------------------------------------------
     41           *         Exported functions
     42           *------------------------------------------------------------------------------*/
     43          
     44          /*
     45           * Initializes the UART with the given parameters, and enables both the
     46           * transmitter and the receiver. The mode parameter contains the value of the
     47           * UART_MR register.
     48           * Value UART_STANDARD can be used for mode to get the most common configuration
     49           * (i.e. aysnchronous, 8bits, no parity, 1 stop bit, no flow control).
     50           * \param mode  Operating mode to configure.
     51           * \param baudrate  Desired baudrate (e.g. 115200).
     52           * \param mck  Frequency of the system master clock in Hz.
     53           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     54          void uart_configure(Uart* pUart, uint32_t mode, uint32_t baudrate)
     55          {
   \                     uart_configure:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
     56          	uint32_t uart_id = get_uart_id_from_addr(pUart);
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0x........         BL       get_uart_id_from_addr
   \   00000018   0xE1B07000         MOVS     R7,R0
     57          	// Reset & disable receiver and transmitter, disable interrupts
     58          	pUart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX | UART_CR_RXDIS | UART_CR_TXDIS
     59          		| UART_CR_RSTSTA;
   \   0000001C   0xE3A00F6B         MOV      R0,#+428
   \   00000020   0xE5840000         STR      R0,[R4, #+0]
     60          	pUart->UART_IDR = 0xFFFFFFFF;
   \   00000024   0xE3E00000         MVN      R0,#+0
   \   00000028   0xE584000C         STR      R0,[R4, #+12]
     61          	// Configure baud rate
     62          	pUart->UART_BRGR = pmc_get_peripheral_max_clock(uart_id) / (baudrate * 16);
   \   0000002C   0xE1B00007         MOVS     R0,R7
   \   00000030   0x........         BL       pmc_get_peripheral_max_clock
   \   00000034   0xE1B01206         LSLS     R1,R6,#+4
   \   00000038   0x........         BL       __aeabi_uidiv
   \   0000003C   0xE5840020         STR      R0,[R4, #+32]
     63          	// Configure mode register
     64          	pUart->UART_MR = mode;
   \   00000040   0xE5845004         STR      R5,[R4, #+4]
     65          	// Enable receiver and transmitter
     66          	pUart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
   \   00000044   0xE3A00050         MOV      R0,#+80
   \   00000048   0xE5840000         STR      R0,[R4, #+0]
     67          }
   \   0000004C   0xE8BD80F1         POP      {R0,R4-R7,PC}    ;; return
     68          
     69          /* Enable transmitter
     70           *
     71           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     72          void uart_set_transmitter_enabled (Uart* pUart, uint8_t enabled)
     73          {
     74          	if (enabled) pUart->UART_CR = UART_CR_TXEN;
   \                     uart_set_transmitter_enabled:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE3520000         CMP      R2,#+0
   \   0000000C   0x0A000002         BEQ      ??uart_set_transmitter_enabled_0
   \   00000010   0xE3A02040         MOV      R2,#+64
   \   00000014   0xE5802000         STR      R2,[R0, #+0]
   \   00000018   0xEA000001         B        ??uart_set_transmitter_enabled_1
     75          	else pUart->UART_CR = UART_CR_TXDIS;
   \                     ??uart_set_transmitter_enabled_0:
   \   0000001C   0xE3A02080         MOV      R2,#+128
   \   00000020   0xE5802000         STR      R2,[R0, #+0]
     76          }
   \                     ??uart_set_transmitter_enabled_1:
   \   00000024   0xE12FFF1E         BX       LR               ;; return
     77          
     78          /* Enable receiver
     79           *
     80           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     81          void uart_set_receiver_enabled (Uart* pUart, uint8_t enabled)
     82          {
     83          	if (enabled)
   \                     uart_set_receiver_enabled:
   \   00000000   0xE1B02001         MOVS     R2,R1
   \   00000004   0xE6EF2072         UXTB     R2,R2
   \   00000008   0xE3520000         CMP      R2,#+0
   \   0000000C   0x0A000002         BEQ      ??uart_set_receiver_enabled_0
     84          		pUart->UART_CR = UART_CR_RXEN;
   \   00000010   0xE3A02010         MOV      R2,#+16
   \   00000014   0xE5802000         STR      R2,[R0, #+0]
   \   00000018   0xEA000001         B        ??uart_set_receiver_enabled_1
     85          	else
     86          		pUart->UART_CR = UART_CR_RXDIS;
   \                     ??uart_set_receiver_enabled_0:
   \   0000001C   0xE3A02020         MOV      R2,#+32
   \   00000020   0xE5802000         STR      R2,[R0, #+0]
     87          }
   \                     ??uart_set_receiver_enabled_1:
   \   00000024   0xE12FFF1E         BX       LR               ;; return
     88          
     89          /* Set interrupt register
     90           *
     91           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     92          void uart_set_int (Uart* pUart, uint32_t int_mask)
     93          {
     94          	pUart->UART_IER |= int_mask;
   \                     uart_set_int:
   \   00000000   0xE5902008         LDR      R2,[R0, #+8]
   \   00000004   0xE1912002         ORRS     R2,R1,R2
   \   00000008   0xE5802008         STR      R2,[R0, #+8]
     95          }
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
     96          
     97          /**
     98           * Outputs a character on the UART line.
     99           * \note This function is synchronous (i.e. uses polling).
    100           * \param c  Character to send.
    101           * \param wait = 1 if wait transfer complete
    102           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    103          void uart_put_char(Uart* pUart, unsigned char c)
    104          {
    105          	// Wait for the transmitter to be ready
    106          	while ((pUart->UART_SR & UART_SR_TXEMPTY) == 0);
   \                     uart_put_char:
   \                     ??uart_put_char_0:
   \   00000000   0xE5902014         LDR      R2,[R0, #+20]
   \   00000004   0xE3120F80         TST      R2,#0x200
   \   00000008   0x0AFFFFFC         BEQ      ??uart_put_char_0
    107          	// Send character
    108          	pUart->UART_THR = c;
   \   0000000C   0xE1B02001         MOVS     R2,R1
   \   00000010   0xE6EF2072         UXTB     R2,R2
   \   00000014   0xE580201C         STR      R2,[R0, #+28]
    109          }
   \   00000018   0xE12FFF1E         BX       LR               ;; return
    110          
    111          /**
    112           * Return 1 if a character can be read in UART
    113           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    114          uint32_t uart_is_rx_ready(Uart* pUart)
    115          {
    116          	return (pUart->UART_SR & UART_SR_RXRDY);
   \                     uart_is_rx_ready:
   \   00000000   0xE5900014         LDR      R0,[R0, #+20]
   \   00000004   0xE2100001         ANDS     R0,R0,#0x1
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    117          }
    118          
    119          /**
    120           * Return 1 if a character can be write in UART
    121           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    122          uint32_t uart_is_tx_ready(Uart* pUart)
    123          {
    124          	return (pUart->UART_SR & UART_SR_TXRDY);
   \                     uart_is_tx_ready:
   \   00000000   0xE5900014         LDR      R0,[R0, #+20]
   \   00000004   0xE2100002         ANDS     R0,R0,#0x2
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    125          }
    126          
    127          /**
    128           * \brief Reads and returns a character from the UART.
    129           * \note This function is synchronous (i.e. uses polling).
    130           * \return Character received.
    131           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    132          uint8_t uart_get_char(Uart* pUart)
    133          {
    134          	while ((pUart->UART_SR & UART_SR_RXRDY) == 0);
   \                     uart_get_char:
   \                     ??uart_get_char_0:
   \   00000000   0xE5901014         LDR      R1,[R0, #+20]
   \   00000004   0xE3110001         TST      R1,#0x1
   \   00000008   0x0AFFFFFC         BEQ      ??uart_get_char_0
    135          	return pUart->UART_RHR;
   \   0000000C   0xE5900018         LDR      R0,[R0, #+24]
   \   00000010   0xE6EF0070         UXTB     R0,R0
   \   00000014   0xE12FFF1E         BX       LR               ;; return
    136          }
    137          
    138          
    139          
    140          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   get_uart_id_from_addr
      24   uart_configure
        24   -> get_uart_id_from_addr
        24   -> pmc_get_peripheral_max_clock
        24 __aeabi_uidiv
       0   uart_get_char
       0   uart_is_rx_ready
       0   uart_is_tx_ready
       0   uart_put_char
       0   uart_set_int
       0   uart_set_receiver_enabled
       0   uart_set_transmitter_enabled


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      56  _id_h64_matrix
     132  get_uart_id_from_addr
      80  uart_configure
      24  uart_get_char
      12  uart_is_rx_ready
      12  uart_is_tx_ready
      28  uart_put_char
      16  uart_set_int
      40  uart_set_receiver_enabled
      40  uart_set_transmitter_enabled

 
  56 bytes in section .rodata
 384 bytes in section SOFTPACK
 
 384 bytes of CODE  memory
  56 bytes of CONST memory

Errors: none
Warnings: 1
