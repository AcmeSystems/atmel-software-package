###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:03
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\pio4.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\core\pio4.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\pio4.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\pio4.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\core\pio4.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup pio_module Working with PIO
     31           * \section Purpose
     32           * The PIO driver provides the Interface for configuration the Parallel Input/Output
     33           *  Controller (PIO).
     34           *
     35           * \section Usage
     36           * <ul>
     37           * <li>  Initialize the PIO with the desired period using pio_configure().
     38           * <li>  Set a high or low output level on the given PIO using pio_set() or pio_clear().
     39           * <li>  Get the level of the given PIOs using pio_get() or pio_get_output_date_status().
     40           * <li>  Configures Glitch or Debouncing filter for given input PIO using pio_set_debounce_filter().
     41           * <li>  Enable & disable write protect of the given PIOs using pio_enable_write_protect() or pio_disable_write_protect().
     42           * <li>  Get write protect violation information of given PIO using pio_get_write_protect_violation_info().
     43           * </li>
     44           * </ul>
     45           *
     46           * For more accurate information, please look at the PIT section of the Datasheet.
     47           *
     48           * Related files :\n
     49           * \ref pio.c\n
     50           * \ref pio3.h\n
     51          */
     52          /*@{*/
     53          /*@}*/
     54          
     55          /**
     56           * \file
     57           *
     58           * Implementation of PIO V3 (Parallel Input/Output) controller.
     59           *
     60           */
     61          /*----------------------------------------------------------------------------
     62           *        Headers
     63           *----------------------------------------------------------------------------*/
     64          
     65          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     66          #include "core/pio.h"
     67          #include "core/pmc.h"
     68          
     69          #include <string.h>
     70          #include <assert.h>
     71          
     72          /*----------------------------------------------------------------------------
     73           *        Local define
     74           *----------------------------------------------------------------------------*/
     75          
     76          struct _bitfield_pio_cfgr_func {
     77          	uint32_t
     78          	func		: 3,
     79          	rfu3_7		: 5,
     80          	dir		: 1,
     81          	puen		: 1,
     82          	pden		: 1,
     83          	rfu11		: 1,
     84          	ifen		: 1,
     85          	ifscen		: 1,
     86          	opd		: 1,
     87          	schmitt		: 1,
     88          	drvstr		: 2,
     89          	rfu18_23	: 6,
     90          	evtsel		: 3,
     91          	rfu27_28	: 2,
     92          	pcfs		: 1,
     93          	icfs		: 1,
     94          	tampen		: 1;
     95          };
     96          
     97          union _pio_cfg {
     98          	struct _bitfield_pio_cfgr_func bitfield;
     99          	uint32_t uint32_value;
    100          };
    101          
    102          /*----------------------------------------------------------------------------
    103           *        Local functions
    104           *----------------------------------------------------------------------------*/
    105          

   \                                 In section SOFTPACK, align 4, keep-with-next
    106          static inline uint32_t get_pio_id_from_group(uint32_t group) {
   \                     get_pio_id_from_group:
   \   00000000   0xE1B01000         MOVS     R1,R0
    107          	switch(group) {
   \   00000004   0xE1B00001         MOVS     R0,R1
   \   00000008   0xE3500003         CMP      R0,#+3
   \   0000000C   0x8A00000A         BHI      ??get_pio_id_from_group_1
   \   00000010   0xE7DF2000         LDRB     R2,[PC, R0]
   \   00000014   0xE08FF102         ADD      PC,PC,R2, LSL #+2
   \                     ??get_pio_id_from_group_0:
   \   00000018   0x00 0x02          DC8      0x0,0x2,0x4,0x6
   \              0x04 0x06    
    108          	case PIO_GROUP_A:
    109          		return ID_PIOA;
   \                     ??get_pio_id_from_group_2:
   \   0000001C   0xE3A00012         MOV      R0,#+18
   \   00000020   0xEA000006         B        ??get_pio_id_from_group_3
    110          	case PIO_GROUP_B:
    111          		return ID_PIOB;
   \                     ??get_pio_id_from_group_4:
   \   00000024   0xE3A00044         MOV      R0,#+68
   \   00000028   0xEA000004         B        ??get_pio_id_from_group_3
    112          	case PIO_GROUP_C:
    113          		return ID_PIOC;
   \                     ??get_pio_id_from_group_5:
   \   0000002C   0xE3A00045         MOV      R0,#+69
   \   00000030   0xEA000002         B        ??get_pio_id_from_group_3
    114          	case PIO_GROUP_D:
    115          		return ID_PIOD;
   \                     ??get_pio_id_from_group_6:
   \   00000034   0xE3A00046         MOV      R0,#+70
   \   00000038   0xEA000000         B        ??get_pio_id_from_group_3
    116          	default:
    117          		return ID_PERIPH_COUNT;
   \                     ??get_pio_id_from_group_1:
   \   0000003C   0xE3A0004F         MOV      R0,#+79
   \                     ??get_pio_id_from_group_3:
   \   00000040   0xE12FFF1E         BX       LR               ;; return
    118          	}
    119          }
    120          
    121          /*----------------------------------------------------------------------------
    122           *         Exported functions
    123           *----------------------------------------------------------------------------*/
    124          
    125          /**
    126           * \brief Configures a list of Pin instances, each of which can either hold a single
    127           * pin or a group of pins, depending on the mask value; all pins are configured
    128           * by this function. The size of the array must also be provided and is easily
    129           * computed using PIO_LISTSIZE whenever its length is not known in advance.
    130           *
    131           * \param list  Pointer to a list of _pin instances.
    132           * \param size  Size of the _pin list (calculated using PIN_LISTSIZE).
    133           *
    134           * \return 1 if the pins have been configured properly; otherwise 0.
    135           */
    136          

   \                                 In section SOFTPACK, align 4, keep-with-next
    137          uint8_t pio_configure(const struct _pin *pin_list, uint32_t size)
    138          {
   \                     pio_configure:
   \   00000000   0xE92D43F8         PUSH     {R3-R9,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B08001         MOVS     R8,R1
    139          	union _pio_cfg cfg;
    140          	uint8_t group;
    141          	PioIo_group* pioiog;
    142          
    143          	/* Configure pins */
    144          	while (size--)
   \                     ??pio_configure_1:
   \   0000000C   0xE1B00008         MOVS     R0,R8
   \   00000010   0xE2508001         SUBS     R8,R0,#+1
   \   00000014   0xE3500000         CMP      R0,#+0
   \   00000018   0x0A000061         BEQ      ??pio_configure_2
    145          	{
    146          		assert(pin_list->id < PIO_GROUP_LENGTH);
   \   0000001C   0xE5D40008         LDRB     R0,[R4, #+8]
   \   00000020   0xE3500004         CMP      R0,#+4
   \   00000024   0xBA000004         BLT      ??pio_configure_3
   \   00000028   0xE3A02092         MOV      R2,#+146
   \   0000002C   0x........         LDR      R1,??DataTable8
   \   00000030   0x........         LDR      R0,??DataTable8_1
   \   00000034   0x........         BL       __aeabi_assert
   \   00000038   0x........         BL       __iar_EmptyStepPoint
    147          		cfg.uint32_value = 0;
   \                     ??pio_configure_3:
   \   0000003C   0xE3A00000         MOV      R0,#+0
   \   00000040   0xE1B05000         MOVS     R5,R0
    148          		group = pin_list->id;
   \   00000044   0xE5D40008         LDRB     R0,[R4, #+8]
   \   00000048   0xE1B06000         MOVS     R6,R0
    149          		pioiog = &pin_list->pio->PIO_IO_GROUP[group];
   \   0000004C   0xE5940004         LDR      R0,[R4, #+4]
   \   00000050   0xE1B01006         MOVS     R1,R6
   \   00000054   0xE6EF1071         UXTB     R1,R1
   \   00000058   0xE1B01301         LSLS     R1,R1,#+6
   \   0000005C   0xE0910000         ADDS     R0,R1,R0
   \   00000060   0xE1B07000         MOVS     R7,R0
    150          
    151          		if ( pin_list->attribute != PIO_DEFAULT) {
   \   00000064   0xE5D4000A         LDRB     R0,[R4, #+10]
   \   00000068   0xE3500000         CMP      R0,#+0
   \   0000006C   0x0A00001E         BEQ      ??pio_configure_4
    152          			cfg.bitfield.puen = (pin_list->attribute & PIO_PULLUP)? 1:0 ;
   \   00000070   0xE5D4000A         LDRB     R0,[R4, #+10]
   \   00000074   0xE7C95490         BFI      R5,R0,#+9,#+1
    153          			cfg.bitfield.pden = (pin_list->attribute & PIO_PULLDOWN)? 1:0 ;
   \   00000078   0xE5D4000A         LDRB     R0,[R4, #+10]
   \   0000007C   0xE6EF0070         UXTB     R0,R0
   \   00000080   0xE1B000A0         LSRS     R0,R0,#+1
   \   00000084   0xE6EF0070         UXTB     R0,R0
   \   00000088   0xE7CA5510         BFI      R5,R0,#+10,#+1
    154          			cfg.bitfield.ifen = (pin_list->attribute & PIO_DEGLITCH)? 1:0 ;
   \   0000008C   0xE5D4000A         LDRB     R0,[R4, #+10]
   \   00000090   0xE6EF0070         UXTB     R0,R0
   \   00000094   0xE1B001A0         LSRS     R0,R0,#+3
   \   00000098   0xE6EF0070         UXTB     R0,R0
   \   0000009C   0xE7CC5610         BFI      R5,R0,#+12,#+1
    155          			cfg.bitfield.ifscen = (pin_list->attribute & PIO_FILTER_SLOW_CLOCK)? 1:0 ;
   \   000000A0   0xE5D4000A         LDRB     R0,[R4, #+10]
   \   000000A4   0xE6EF0070         UXTB     R0,R0
   \   000000A8   0xE1B00220         LSRS     R0,R0,#+4
   \   000000AC   0xE6EF0070         UXTB     R0,R0
   \   000000B0   0xE7CD5690         BFI      R5,R0,#+13,#+1
    156          			cfg.bitfield.opd	= (pin_list->attribute & PIO_OPENDRAIN)? 1:0 ;
   \   000000B4   0xE5D4000A         LDRB     R0,[R4, #+10]
   \   000000B8   0xE6EF0070         UXTB     R0,R0
   \   000000BC   0xE1B00120         LSRS     R0,R0,#+2
   \   000000C0   0xE6EF0070         UXTB     R0,R0
   \   000000C4   0xE7CE5710         BFI      R5,R0,#+14,#+1
    157          			cfg.bitfield.schmitt	= (pin_list->attribute & PIO_TRIGGER_DIS)? 1:0 ;
   \   000000C8   0xE5D4000A         LDRB     R0,[R4, #+10]
   \   000000CC   0xE6EF0070         UXTB     R0,R0
   \   000000D0   0xE1B002A0         LSRS     R0,R0,#+5
   \   000000D4   0xE6EF0070         UXTB     R0,R0
   \   000000D8   0xE7CF5790         BFI      R5,R0,#+15,#+1
    158          			cfg.bitfield.drvstr = pin_list->attribute & PIO_DRVSTR_Msk;
   \   000000DC   0xE3D55BC0         BICS     R5,R5,#0x30000
    159          			cfg.bitfield.evtsel = pin_list->attribute & PIO_EVTSEL_Msk;
   \   000000E0   0xE3D55670         BICS     R5,R5,#0x7000000
    160          			cfg.bitfield.pcfs = (pin_list->attribute & PIO_PCFS_FREEZE)? 1:0 ;
   \   000000E4   0xE3D55580         BICS     R5,R5,#0x20000000
    161          			cfg.bitfield.icfs = (pin_list->attribute & PIO_ICFS_FREEZE)? 1:0 ;
   \   000000E8   0xE3D55440         BICS     R5,R5,#0x40000000
    162          			/* cfg.bitfield.tampen = (pin_list->attribute & PIO_TAMPEN_FREEZE)? 1:0 ; */
    163          		}
    164          
    165          		switch ( pin_list->type ){
   \                     ??pio_configure_4:
   \   000000EC   0xE5D40009         LDRB     R0,[R4, #+9]
   \   000000F0   0xE350000C         CMP      R0,#+12
   \   000000F4   0x8A00001E         BHI      ??pio_configure_5
   \   000000F8   0xE7DF1000         LDRB     R1,[PC, R0]
   \   000000FC   0xE08FF101         ADD      PC,PC,R1, LSL #+2
   \                     ??pio_configure_0:
   \   00000100   0x12 0x03          DC8      0x12,0x3,0x6,0x9
   \              0x06 0x09    
   \   00000104   0x0C 0x0F          DC8      0xC,0xF,0x1C,0x1C
   \              0x1C 0x1C    
   \   00000108   0x1C 0x1C          DC8      0x1C,0x1C,0x12,0x14
   \              0x12 0x14    
   \   0000010C   0x18 0x00          DC8      0x18,0x0,0x0,0x0
   \              0x00 0x00    
    166          
    167          		case PIO_PERIPH_A:
    168          			cfg.bitfield.func = PIO_CFGR_FUNC_PERIPH_A;
   \                     ??pio_configure_6:
   \   00000110   0xE3A00001         MOV      R0,#+1
   \   00000114   0xE7C25010         BFI      R5,R0,#+0,#+3
    169          			break;
   \   00000118   0xEA000017         B        ??pio_configure_7
    170          		case PIO_PERIPH_B:
    171          			cfg.bitfield.func = PIO_CFGR_FUNC_PERIPH_B;
   \                     ??pio_configure_8:
   \   0000011C   0xE3A00002         MOV      R0,#+2
   \   00000120   0xE7C25010         BFI      R5,R0,#+0,#+3
    172          			break;
   \   00000124   0xEA000014         B        ??pio_configure_7
    173          		case PIO_PERIPH_C:
    174          			cfg.bitfield.func = PIO_CFGR_FUNC_PERIPH_C;
   \                     ??pio_configure_9:
   \   00000128   0xE3A00003         MOV      R0,#+3
   \   0000012C   0xE7C25010         BFI      R5,R0,#+0,#+3
    175          			break;
   \   00000130   0xEA000011         B        ??pio_configure_7
    176          		case PIO_PERIPH_D:
    177          			cfg.bitfield.func = PIO_CFGR_FUNC_PERIPH_D;
   \                     ??pio_configure_10:
   \   00000134   0xE3A00004         MOV      R0,#+4
   \   00000138   0xE7C25010         BFI      R5,R0,#+0,#+3
    178          			break;
   \   0000013C   0xEA00000E         B        ??pio_configure_7
    179          		case PIO_PERIPH_E:
    180          			cfg.bitfield.func = PIO_CFGR_FUNC_PERIPH_E;
   \                     ??pio_configure_11:
   \   00000140   0xE3A00005         MOV      R0,#+5
   \   00000144   0xE7C25010         BFI      R5,R0,#+0,#+3
    181          			break;
   \   00000148   0xEA00000B         B        ??pio_configure_7
    182          
    183          		case PIO_GENERIC:
    184          		case PIO_INPUT:
    185          			cfg.bitfield.dir = 0;
   \                     ??pio_configure_12:
   \   0000014C   0xE3D55F40         BICS     R5,R5,#0x100
    186          			break;
   \   00000150   0xEA000009         B        ??pio_configure_7
    187          
    188          		case PIO_OUTPUT_0:
    189          			cfg.bitfield.dir = 1;
   \                     ??pio_configure_13:
   \   00000154   0xE3955F40         ORRS     R5,R5,#0x100
    190          			pio_clear(pin_list);
   \   00000158   0xE1B00004         MOVS     R0,R4
   \   0000015C   0x........         BL       pio_clear
    191          			break;
   \   00000160   0xEA000005         B        ??pio_configure_7
    192          
    193          		case PIO_OUTPUT_1:
    194          			cfg.bitfield.dir = 1;
   \                     ??pio_configure_14:
   \   00000164   0xE3955F40         ORRS     R5,R5,#0x100
    195          			pio_set(pin_list);
   \   00000168   0xE1B00004         MOVS     R0,R4
   \   0000016C   0x........         BL       pio_set
    196          			break;
   \   00000170   0xEA000001         B        ??pio_configure_7
    197          
    198          		default:
    199          		case PIO_PERIPH_F:
    200          		case PIO_PERIPH_G:
    201          			return 0;
   \                     ??pio_configure_5:
   \   00000174   0xE3A00000         MOV      R0,#+0
   \   00000178   0xEA00000A         B        ??pio_configure_15
    202          		}
    203          
    204          		pioiog->PIO_MSKR = pin_list->mask;
   \                     ??pio_configure_7:
   \   0000017C   0xE5940000         LDR      R0,[R4, #+0]
   \   00000180   0xE5870000         STR      R0,[R7, #+0]
    205          		pioiog->PIO_CFGR = cfg.uint32_value;
   \   00000184   0xE5875004         STR      R5,[R7, #+4]
    206          
    207          		/* Enable the PIO group if needed */
    208          		uint32_t pio_group = get_pio_id_from_group(pin_list->id);
   \   00000188   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000018C   0x........         BL       get_pio_id_from_group
   \   00000190   0xE1B09000         MOVS     R9,R0
    209          		pmc_enable_peripheral(pio_group);
   \   00000194   0xE1B00009         MOVS     R0,R9
   \   00000198   0x........         BL       pmc_enable_peripheral
    210          
    211          		++pin_list;
   \   0000019C   0xE294400C         ADDS     R4,R4,#+12
   \   000001A0   0xEAFFFF99         B        ??pio_configure_1
    212          	}
    213          	return 1;
   \                     ??pio_configure_2:
   \   000001A4   0xE3A00001         MOV      R0,#+1
   \                     ??pio_configure_15:
   \   000001A8   0xE8BD83F2         POP      {R1,R4-R9,PC}    ;; return
    214          }
    215          
    216          /**
    217           * \brief Sets a high output level on all the PIOs defined in the given Pin instance.
    218           * This has no immediate effects on PIOs that are not output, but the PIO
    219           * controller will memorize the value they are changed to outputs.
    220           *
    221           * \param pin  Pointer to a Pin instance describing one or more pins.
    222           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    223          void pio_set(const struct _pin *pin)
    224          {
   \                     pio_set:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    225          	assert(pin->id < PIO_GROUP_LENGTH);
   \   00000008   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000000C   0xE3500004         CMP      R0,#+4
   \   00000010   0xBA000004         BLT      ??pio_set_0
   \   00000014   0xE3A020E1         MOV      R2,#+225
   \   00000018   0x........         LDR      R1,??DataTable8
   \   0000001C   0x........         LDR      R0,??DataTable8_2
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    226          	PioIo_group* pioiog = &pin->pio->PIO_IO_GROUP[pin->id];
   \                     ??pio_set_0:
   \   00000028   0xE5940004         LDR      R0,[R4, #+4]
   \   0000002C   0xE5D41008         LDRB     R1,[R4, #+8]
   \   00000030   0xE1B01301         LSLS     R1,R1,#+6
   \   00000034   0xE0910000         ADDS     R0,R1,R0
    227          	pioiog->PIO_SODR = pin->mask;
   \   00000038   0xE5941000         LDR      R1,[R4, #+0]
   \   0000003C   0xE5801010         STR      R1,[R0, #+16]
    228          }
   \   00000040   0xE8BD8010         POP      {R4,PC}          ;; return
    229          
    230          /**
    231           * \brief Sets a low output level on all the PIOs defined in the given Pin instance.
    232           * This has no immediate effects on PIOs that are not output, but the PIO
    233           * controller will memorize the value they are changed to outputs.
    234           *
    235           * \param pin  Pointer to a Pin instance describing one or more pins.
    236           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    237          void pio_clear(const struct _pin *pin)
    238          {
   \                     pio_clear:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    239          	assert(pin->id < PIO_GROUP_LENGTH);
   \   00000008   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000000C   0xE3500004         CMP      R0,#+4
   \   00000010   0xBA000004         BLT      ??pio_clear_0
   \   00000014   0xE3A020EF         MOV      R2,#+239
   \   00000018   0x........         LDR      R1,??DataTable8
   \   0000001C   0x........         LDR      R0,??DataTable8_2
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    240          	PioIo_group* pioiog = &pin->pio->PIO_IO_GROUP[pin->id];
   \                     ??pio_clear_0:
   \   00000028   0xE5940004         LDR      R0,[R4, #+4]
   \   0000002C   0xE5D41008         LDRB     R1,[R4, #+8]
   \   00000030   0xE1B01301         LSLS     R1,R1,#+6
   \   00000034   0xE0910000         ADDS     R0,R1,R0
    241          	pioiog->PIO_CODR = pin->mask;
   \   00000038   0xE5941000         LDR      R1,[R4, #+0]
   \   0000003C   0xE5801014         STR      R1,[R0, #+20]
    242          }
   \   00000040   0xE8BD8010         POP      {R4,PC}          ;; return
    243          
    244          /**
    245           * \brief Returns 1 if one or more PIO of the given Pin instance currently have
    246           * a high level; otherwise returns 0. This method returns the actual value that
    247           * is being read on the pin. To return the supposed output value of a pin, use
    248           * pio_get_output_date_status() instead.
    249           *
    250           * \param pin  Pointer to a Pin instance describing one or more pins.
    251           *
    252           * \return 1 if the Pin instance contains at least one PIO that currently has
    253           * a high level; otherwise 0.
    254           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    255          uint8_t pio_get(const struct _pin *pin)
    256          {
   \                     pio_get:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    257          	assert(pin->id < PIO_GROUP_LENGTH);
   \   00000008   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000000C   0xE3500004         CMP      R0,#+4
   \   00000010   0xBA000004         BLT      ??pio_get_0
   \   00000014   0xE3002101         MOVW     R2,#+257
   \   00000018   0x........         LDR      R1,??DataTable8
   \   0000001C   0x........         LDR      R0,??DataTable8_2
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    258              uint32_t reg ;
    259          	PioIo_group* pioiog = &pin->pio->PIO_IO_GROUP[pin->id];
   \                     ??pio_get_0:
   \   00000028   0xE5940004         LDR      R0,[R4, #+4]
   \   0000002C   0xE5D42008         LDRB     R2,[R4, #+8]
   \   00000030   0xE1B02302         LSLS     R2,R2,#+6
   \   00000034   0xE0922000         ADDS     R2,R2,R0
    260          
    261              if ((pin->type == PIO_OUTPUT_0) || (pin->type == PIO_OUTPUT_1)) {
   \   00000038   0xE5D40009         LDRB     R0,[R4, #+9]
   \   0000003C   0xE350000B         CMP      R0,#+11
   \   00000040   0x0A000002         BEQ      ??pio_get_1
   \   00000044   0xE5D40009         LDRB     R0,[R4, #+9]
   \   00000048   0xE350000C         CMP      R0,#+12
   \   0000004C   0x1A000002         BNE      ??pio_get_2
    262          	reg = pioiog->PIO_ODSR ;
   \                     ??pio_get_1:
   \   00000050   0xE5920018         LDR      R0,[R2, #+24]
   \   00000054   0xE1B01000         MOVS     R1,R0
   \   00000058   0xEA000001         B        ??pio_get_3
    263              }
    264              else {
    265          	reg = pioiog->PIO_PDSR ;
   \                     ??pio_get_2:
   \   0000005C   0xE5920008         LDR      R0,[R2, #+8]
   \   00000060   0xE1B01000         MOVS     R1,R0
    266              }
    267              if ( (reg & pin->mask) == 0 ) {
   \                     ??pio_get_3:
   \   00000064   0xE5940000         LDR      R0,[R4, #+0]
   \   00000068   0xE1100001         TST      R0,R1
   \   0000006C   0x1A000001         BNE      ??pio_get_4
    268          	return 0 ;
   \   00000070   0xE3A00000         MOV      R0,#+0
   \   00000074   0xEA000000         B        ??pio_get_5
    269              }
    270              else {
    271          	return 1 ;
   \                     ??pio_get_4:
   \   00000078   0xE3A00001         MOV      R0,#+1
   \                     ??pio_get_5:
   \   0000007C   0xE8BD8010         POP      {R4,PC}          ;; return
    272              }
    273          }
    274          
    275          /**
    276           * \brief Returns 1 if one or more PIO of the given Pin are configured to output a
    277           * high level (even if they are not output).
    278           * To get the actual value of the pin, use pio_get() instead.
    279           *
    280           * \param pin  Pointer to a Pin instance describing one or more pins.
    281           *
    282           * \return 1 if the Pin instance contains at least one PIO that is configured
    283           * to output a high level; otherwise 0.
    284           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    285          uint8_t pio_get_output_data_status(const struct _pin *pin)
    286          {
   \                     pio_get_output_data_status:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    287          	assert(pin->id < PIO_GROUP_LENGTH);
   \   00000008   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000000C   0xE3500004         CMP      R0,#+4
   \   00000010   0xBA000004         BLT      ??pio_get_output_data_status_0
   \   00000014   0xE300211F         MOVW     R2,#+287
   \   00000018   0x........         LDR      R1,??DataTable8
   \   0000001C   0x........         LDR      R0,??DataTable8_2
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    288          	PioIo_group* pioiog = &pin->pio->PIO_IO_GROUP[pin->id];
   \                     ??pio_get_output_data_status_0:
   \   00000028   0xE5940004         LDR      R0,[R4, #+4]
   \   0000002C   0xE5D41008         LDRB     R1,[R4, #+8]
   \   00000030   0xE1B01301         LSLS     R1,R1,#+6
   \   00000034   0xE0911000         ADDS     R1,R1,R0
    289          	if ((pioiog->PIO_ODSR & pin->mask) == 0) {
   \   00000038   0xE5910018         LDR      R0,[R1, #+24]
   \   0000003C   0xE5942000         LDR      R2,[R4, #+0]
   \   00000040   0xE1120000         TST      R2,R0
   \   00000044   0x1A000001         BNE      ??pio_get_output_data_status_1
    290          		return 0;
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xEA000000         B        ??pio_get_output_data_status_2
    291          	}
    292          	else {
    293          		return 1;
   \                     ??pio_get_output_data_status_1:
   \   00000050   0xE3A00001         MOV      R0,#+1
   \                     ??pio_get_output_data_status_2:
   \   00000054   0xE8BD8010         POP      {R4,PC}          ;; return
    294          	}
    295          }
    296          
    297          /**
    298           * \brief Configures Glitch or Debouncing filter for input.
    299           *
    300           * \param pin  Pointer to a Pin instance describing one or more pins.
    301           * \param cuttoff  Cutt off frequency for debounce filter.
    302           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    303          void pio_set_debounce_filter(const struct _pin *pin, uint32_t cuttoff)
    304          {
   \                     pio_set_debounce_filter:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    305          	assert(pin->id < PIO_GROUP_LENGTH);
   \   0000000C   0xE5D40008         LDRB     R0,[R4, #+8]
   \   00000010   0xE3500004         CMP      R0,#+4
   \   00000014   0xBA000004         BLT      ??pio_set_debounce_filter_0
   \   00000018   0xE3002131         MOVW     R2,#+305
   \   0000001C   0x........         LDR      R1,??DataTable8
   \   00000020   0x........         LDR      R0,??DataTable8_2
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    306          	Pio *pio = pin->pio;
   \                     ??pio_set_debounce_filter_0:
   \   0000002C   0xE5946004         LDR      R6,[R4, #+4]
    307          	if (cuttoff == 0) {
   \   00000030   0xE3550000         CMP      R5,#+0
   \   00000034   0x1A000003         BNE      ??pio_set_debounce_filter_1
    308          	   pio->S_PIO_SCDR = 0;
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE2961D54         ADDS     R1,R6,#+5376
   \   00000040   0xE5810000         STR      R0,[R1, #+0]
   \   00000044   0xEA000007         B        ??pio_set_debounce_filter_2
    309          	}
    310          	else {
    311          		/* the lowest 14 bits work */
    312          		pio->S_PIO_SCDR = ((32678/(2*(cuttoff))) - 1) & 0x3FFF;
   \                     ??pio_set_debounce_filter_1:
   \   00000048   0xE3070FA6         MOVW     R0,#+32678
   \   0000004C   0xE1B01085         LSLS     R1,R5,#+1
   \   00000050   0x........         BL       __aeabi_uidiv
   \   00000054   0xE2500001         SUBS     R0,R0,#+1
   \   00000058   0xE1B00900         LSLS     R0,R0,#+18
   \   0000005C   0xE1B00920         LSRS     R0,R0,#+18
   \   00000060   0xE2961D54         ADDS     R1,R6,#+5376
   \   00000064   0xE5810000         STR      R0,[R1, #+0]
    313          	}
    314          }
   \                     ??pio_set_debounce_filter_2:
   \   00000068   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    315          
    316          /**
    317           * \brief Enable write protect.
    318           *
    319           * \param pin  Pointer to a Pin instance describing one or more pins.
    320           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    321          void pio_enable_write_protect(const struct _pin *pin)
    322          {
   \                     pio_enable_write_protect:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    323          	assert(pin->id < PIO_GROUP_LENGTH);
   \   00000008   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000000C   0xE3500004         CMP      R0,#+4
   \   00000010   0xBA000004         BLT      ??pio_enable_write_protect_0
   \   00000014   0xE3002143         MOVW     R2,#+323
   \   00000018   0x........         LDR      R1,??DataTable8
   \   0000001C   0x........         LDR      R0,??DataTable8_2
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    324          	Pio *pio = pin->pio;
   \                     ??pio_enable_write_protect_0:
   \   00000028   0xE5940004         LDR      R0,[R4, #+4]
    325          	pio->PIO_WPMR = (PIO_WPMR_WPKEY_VALID | PIO_WPMR_WPEN_EN  );
   \   0000002C   0x........         LDR      R1,??DataTable8_3  ;; 0x50494f01
   \   00000030   0xE58015E0         STR      R1,[R0, #+1504]
    326          }
   \   00000034   0xE8BD8010         POP      {R4,PC}          ;; return
    327          
    328          /**
    329           * \brief Disable write protect.
    330           *
    331           * \param pin  Pointer to a Pin instance describing one or more pins.
    332           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    333          void pio_disable_write_protect(const struct _pin *pin)
    334          {
   \                     pio_disable_write_protect:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    335          	assert(pin->id < PIO_GROUP_LENGTH);
   \   00000008   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000000C   0xE3500004         CMP      R0,#+4
   \   00000010   0xBA000004         BLT      ??pio_disable_write_protect_0
   \   00000014   0xE300214F         MOVW     R2,#+335
   \   00000018   0x........         LDR      R1,??DataTable8
   \   0000001C   0x........         LDR      R0,??DataTable8_2
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    336          	Pio *pio = pin->pio;
   \                     ??pio_disable_write_protect_0:
   \   00000028   0xE5940004         LDR      R0,[R4, #+4]
    337          	pio->PIO_WPMR = (PIO_WPMR_WPKEY_VALID | PIO_WPMR_WPEN_DIS );
   \   0000002C   0x........         LDR      R1,??DataTable8_4  ;; 0x50494f00
   \   00000030   0xE58015E0         STR      R1,[R0, #+1504]
    338          }
   \   00000034   0xE8BD8010         POP      {R4,PC}          ;; return
    339          
    340          /**
    341           * \brief Get write protect violation information.
    342           *
    343           * \param pin  Pointer to a Pin instance describing one or more pins.
    344           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    345          uint32_t pio_get_write_protect_violation_info(const struct _pin * pin)
    346          {
   \                     pio_get_write_protect_violation_info:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    347          	assert(pin->id < PIO_GROUP_LENGTH);
   \   00000008   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000000C   0xE3500004         CMP      R0,#+4
   \   00000010   0xBA000004         BLT      ??pio_get_write_protect_violation_info_0
   \   00000014   0xE300215B         MOVW     R2,#+347
   \   00000018   0x........         LDR      R1,??DataTable8
   \   0000001C   0x........         LDR      R0,??DataTable8_2
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    348          	Pio *pio = pin->pio;
   \                     ??pio_get_write_protect_violation_info_0:
   \   00000028   0xE5940004         LDR      R0,[R4, #+4]
    349          	return pio->PIO_WPSR;
   \   0000002C   0xE59005E4         LDR      R0,[R0, #+1508]
   \   00000030   0xE8BD8010         POP      {R4,PC}          ;; return
    350          }
    351          
    352          /**
    353           * \brief Configure all pio output low
    354           *
    355           * \param pio  Pointer to a Pio instance describing one or more pins.
    356           * \param pioId PIO ID
    357           * \param mask  Bitmask of one or more pin(s) to configure.
    358           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    359          void pio_output_low (Pio *pio, uint32_t pioId ,uint32_t mask)
    360          {
    361          }
   \                     pio_output_low:
   \   00000000   0xE12FFF1E         BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x50494F01         DC32     0x50494f01

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x50494F00         DC32     0x50494f00

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x70 0x69          DC8 "pin_list->id < PIO_GROUP_LENGTH"
   \              0x6E 0x5F    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x2D 0x3E    
   \              0x69 0x64    
   \              0x20 0x3C    
   \              0x20 0x50    
   \              0x49 0x4F    
   \              0x5F 0x47    
   \              0x52 0x4F    
   \              0x55 0x50    
   \              0x5F 0x4C    
   \              0x45 0x4E    
   \              0x47 0x54    
   \              0x48 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 63H, 6FH, 72H, 65H
   \              0x73 0x5C    
   \              0x63 0x6F    
   \              0x72 0x65    
   \   00000038   0x5C 0x70          DC8 5CH, 70H, 69H, 6FH, 34H, 2EH, 63H, 0
   \              0x69 0x6F    
   \              0x34 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x70 0x69          DC8 "pin->id < PIO_GROUP_LENGTH"
   \              0x6E 0x2D    
   \              0x3E 0x69    
   \              0x64 0x20    
   \              0x3C 0x20    
   \              0x50 0x49    
   \              0x4F 0x5F    
   \              0x47 0x52    
   \              0x4F 0x55    
   \              0x50 0x5F    
   \              0x4C 0x45    
   \              0x4E 0x47    
   \              0x54 0x48    
   \              0x00         
   \   0000001B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   get_pio_id_from_group
       8   pio_clear
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      32   pio_configure
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
        32   -> get_pio_id_from_group
        32   -> pio_clear
        32   -> pio_set
        32   -> pmc_enable_peripheral
       8   pio_disable_write_protect
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pio_enable_write_protect
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pio_get
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pio_get_output_data_status
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pio_get_write_protect_violation_info
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   pio_output_low
       8   pio_set
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   pio_set_debounce_filter
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16 __aeabi_uidiv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
      32  ?_0
      64  ?_1
      28  ?_2
      56  _id_h64_matrix
      68  get_pio_id_from_group
      68  pio_clear
     428  pio_configure
      56  pio_disable_write_protect
      56  pio_enable_write_protect
     128  pio_get
      88  pio_get_output_data_status
      52  pio_get_write_protect_violation_info
       4  pio_output_low
      68  pio_set
     108  pio_set_debounce_filter

 
   180 bytes in section .rodata
 1 144 bytes in section SOFTPACK
 
 1 144 bytes of CODE  memory
   180 bytes of CONST memory

Errors: none
Warnings: 1
