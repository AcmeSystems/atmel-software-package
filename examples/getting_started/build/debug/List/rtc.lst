###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:05
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\time\rtc.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\time\rtc.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\rtc.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\rtc.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\time\rtc.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup rtc_module Working with RTC
     31           * \section Purpose
     32           * The RTC driver provides the interface to configure and use the RTC
     33           * peripheral.
     34           *
     35           * It manages date, time, and alarms.\n
     36           * This timer is clocked by the 32kHz system clock, and is not impacted by
     37           * power management settings (PMC). To be accurate, it is better to use an
     38           * external 32kHz crystal instead of the internal 32kHz RC.\n
     39           *
     40           * It uses BCD format, and time can be set in AM/PM or 24h mode through a
     41           * configuration bit in the mode register.\n
     42           *
     43           * To update date or time, the user has to follow these few steps :
     44           * <ul>
     45           * <li>Set UPDTIM and/or UPDCAL bit(s) in RTC_CR,</li>
     46           * <li>Polling or IRQ on the ACKUPD bit of RTC_CR,</li>
     47           * <li>Clear ACKUPD bit in RTC_SCCR,</li>
     48           * <li>Update Time and/or Calendar values in RTC_TIMR/RTC_CALR (BCD format),</li>
     49           * <li>Clear UPDTIM and/or UPDCAL bit in RTC_CR.</li>
     50           * </ul>
     51           * An alarm can be set to happen on month, date, hours, minutes or seconds,
     52           * by setting the proper "Enable" bit of each of these fields in the Time and
     53           * Calendar registers.
     54           * This allows a large number of configurations to be available for the user.
     55           * Alarm occurence can be detected even by polling or interrupt.
     56           *
     57           * A check of the validity of the date and time format and values written by the user is automatically done.
     58           * Errors are reported through the Valid Entry Register.
     59           *
     60           * \section Usage
     61           * <ul>
     62           * <li>  Enable & disable RTC interrupt using rtc_enable_it() and rtc_disable_it().
     63           * <li>  Set RTC data, time, alarm using rtc_set_date(), rtc_set_time(),
     64           * rtc_set_time_alarm() and rtc_set_date_alarm().
     65           * <li>  Get RTC data, time using rtc_get_date() and rtc_get_time().
     66           * </li>
     67           * </ul>
     68           *
     69           * For more accurate information, please look at the RTC section of the
     70           * Datasheet.
     71           *
     72           * Related files :\n
     73           * \ref rtc.c\n
     74           * \ref rtc.h.\n
     75          */
     76          /*@{*/
     77          /*@}*/
     78          
     79          /**
     80           * \file
     81           *
     82           * Implementation of Real Time Clock (RTC) controller.
     83           *
     84           */
     85          
     86          /*----------------------------------------------------------------------------
     87           *        Headers
     88           *----------------------------------------------------------------------------*/
     89          
     90          #include "board.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     91          #include "chip.h"
     92          
     93          #include "time/rtc.h"
     94          
     95          #include "utils/trace.h"
     96          
     97          #include <stdint.h>
     98          #include <assert.h>
     99          
    100          /*----------------------------------------------------------------------------
    101           *        Define
    102           *----------------------------------------------------------------------------*/
    103          
    104          /* The BCD code shift value */
    105          #define BCD_SHIFT      4
    106          
    107          /* The BCD code mask value */
    108          #define BCD_MASK       0xfu
    109          
    110          /* The BCD mul/div factor value */
    111          #define BCD_FACTOR     10
    112          
    113          /*----------------------------------------------------------------------------
    114           *        Variables
    115           *----------------------------------------------------------------------------*/
    116          
    117          static uint8_t _flag_alarm;
                                ^
Warning[Pe177]: variable "_flag_alarm" was declared but never referenced
    118          static uint8_t _flag_hms;
                                ^
Warning[Pe177]: variable "_flag_hms" was declared but never referenced
    119          static uint8_t _flag_minute_change;
                                ^
Warning[Pe177]: variable "_flag_minute_change" was declared but never
          referenced
    120          
    121          /*----------------------------------------------------------------------------
    122           *        Exported functions
    123           *----------------------------------------------------------------------------*/
    124          
    125          /**
    126           * \brief Sets the RTC in either 12 or 24 hour mode.
    127           *
    128           * \param pRtc  Pointer to a Rtc instance
    129           * \param dwMode  Hour mode.
    130           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    131          void rtc_set_hour_mode(Rtc * pRtc, uint32_t mode)
    132          {
   \                     rtc_set_hour_mode:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    133          	assert((mode & 0xFFFFFFFE) == 0);
   \   0000000C   0xE3D50001         BICS     R0,R5,#0x1
   \   00000010   0xE3500000         CMP      R0,#+0
   \   00000014   0x0A000004         BEQ      ??rtc_set_hour_mode_0
   \   00000018   0xE3A02085         MOV      R2,#+133
   \   0000001C   0x........         LDR      R1,??DataTable2
   \   00000020   0x........         LDR      R0,??DataTable2_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    134          	pRtc->RTC_MR = mode;
   \                     ??rtc_set_hour_mode_0:
   \   0000002C   0xE5845004         STR      R5,[R4, #+4]
    135          }
   \   00000030   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    136          
    137          /**
    138           * \brief Gets the RTC mode.
    139           *
    140           * \param pRtc  Pointer to a Rtc instance
    141           * \return Hour mode.
    142           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    143          extern uint32_t rtc_get_hour_mode(Rtc * pRtc)
    144          {
   \                     rtc_get_hour_mode:
   \   00000000   0xE1B01000         MOVS     R1,R0
    145          	uint32_t mode;
    146          	TRACE_DEBUG("rtc_get_hour_mode()\n\r");
    147          	mode = pRtc->RTC_MR;
   \   00000004   0xE5912004         LDR      R2,[R1, #+4]
   \   00000008   0xE1B00002         MOVS     R0,R2
    148          	mode &= 0xFFFFFFFE;
   \   0000000C   0xE3D00001         BICS     R0,R0,#0x1
    149          	return mode;
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    150          }
    151          
    152          /**
    153           * \brief Enables the selected interrupt sources of the RTC.
    154           *
    155           * \param pRtc  Pointer to a Rtc instance
    156           * \param dwSources  Interrupt sources to enable.
    157           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    158          void rtc_enable_it(Rtc * pRtc, uint32_t sources)
    159          {
   \                     rtc_enable_it:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    160          	assert((sources & (uint32_t) (~0x1F)) == 0);
   \   0000000C   0xE3D5001F         BICS     R0,R5,#0x1F
   \   00000010   0xE3500000         CMP      R0,#+0
   \   00000014   0x0A000004         BEQ      ??rtc_enable_it_0
   \   00000018   0xE3A020A0         MOV      R2,#+160
   \   0000001C   0x........         LDR      R1,??DataTable2
   \   00000020   0x........         LDR      R0,??DataTable2_2
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    161          	TRACE_DEBUG("rtc_enable_it()\n\r");
    162          	pRtc->RTC_IER = sources;
   \                     ??rtc_enable_it_0:
   \   0000002C   0xE5845020         STR      R5,[R4, #+32]
    163          }
   \   00000030   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    164          
    165          /**
    166          * \brief Disables the selected interrupt sources of the RTC.
    167          *
    168           * \param pRtc  Pointer to a Rtc instance
    169          * \param dwSources  Interrupt sources to disable.
    170          */

   \                                 In section SOFTPACK, align 4, keep-with-next
    171          void rtc_disable_it(Rtc * pRtc, uint32_t sources)
    172          {
   \                     rtc_disable_it:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    173          	assert((sources & (uint32_t) (~0x1F)) == 0);
   \   0000000C   0xE3D5001F         BICS     R0,R5,#0x1F
   \   00000010   0xE3500000         CMP      R0,#+0
   \   00000014   0x0A000004         BEQ      ??rtc_disable_it_0
   \   00000018   0xE3A020AD         MOV      R2,#+173
   \   0000001C   0x........         LDR      R1,??DataTable2
   \   00000020   0x........         LDR      R0,??DataTable2_2
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    174          	TRACE_DEBUG("rtc_disable_it()\n\r");
    175          	pRtc->RTC_IDR = sources;
   \                     ??rtc_disable_it_0:
   \   0000002C   0xE5845024         STR      R5,[R4, #+36]
    176          }
   \   00000030   0xE8BD8031         POP      {R0,R4,R5,PC}    ;; return
    177          
    178          /**
    179           * \brief Sets the current time in the RTC.
    180           *
    181           * \note In successive update operations, the user must wait at least one second
    182           * after resetting the UPDTIM/UPDCAL bit in the RTC_CR before setting these
    183           * bits again. Please look at the RTC section of the datasheet for detail.
    184           *
    185           * \param pRtc  Pointer to a Rtc instance
    186           * \param pTime Pointer to structure time
    187           *
    188           * \return 0 sucess, 1 fail to set
    189           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    190          extern int rtc_set_time(Rtc * pRtc, struct _time *pTime)
    191          {
   \                     rtc_set_time:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    192          	uint32_t ltime = 0;
   \   0000000C   0xE3A06000         MOV      R6,#+0
    193          	uint8_t hour_bcd , min_bcd, sec_bcd;
    194          
    195          	TRACE_DEBUG("rtc_set_time(%02d:%02d:%02d)\n\r", pTime->hour, pTime->min, pTime->sec);
    196          
    197          	/* if 12-hour mode, set AMPM bit */
    198          	if ((pRtc->RTC_MR & RTC_MR_HRMOD) == RTC_MR_HRMOD) {
   \   00000010   0xE5940004         LDR      R0,[R4, #+4]
   \   00000014   0xE3100001         TST      R0,#0x1
   \   00000018   0x0A000006         BEQ      ??rtc_set_time_0
    199          		if (pTime->hour > 12) {
   \   0000001C   0xE5D50000         LDRB     R0,[R5, #+0]
   \   00000020   0xE350000D         CMP      R0,#+13
   \   00000024   0xBA000003         BLT      ??rtc_set_time_0
    200          			pTime->hour -= 12;
   \   00000028   0xE5D50000         LDRB     R0,[R5, #+0]
   \   0000002C   0xE250000C         SUBS     R0,R0,#+12
   \   00000030   0xE5C50000         STRB     R0,[R5, #+0]
    201          			ltime |= RTC_TIMR_AMPM;
   \   00000034   0xE3966840         ORRS     R6,R6,#0x400000
    202          		}
    203          	}
    204          	hour_bcd = (pTime->hour % 10) | ((pTime->hour / 10) << 4);
   \                     ??rtc_set_time_0:
   \   00000038   0xE5D50000         LDRB     R0,[R5, #+0]
   \   0000003C   0xE3A0100A         MOV      R1,#+10
   \   00000040   0x........         BL       __aeabi_idivmod
   \   00000044   0xE1B0A001         MOVS     R10,R1
   \   00000048   0xE5D50000         LDRB     R0,[R5, #+0]
   \   0000004C   0xE3A0100A         MOV      R1,#+10
   \   00000050   0x........         BL       __aeabi_idiv
   \   00000054   0xE19A0200         ORRS     R0,R10,R0, LSL #+4
   \   00000058   0xE1B07000         MOVS     R7,R0
    205          	min_bcd = (pTime->min % 10) | ((pTime->min / 10) << 4);
   \   0000005C   0xE5D50001         LDRB     R0,[R5, #+1]
   \   00000060   0xE3A0100A         MOV      R1,#+10
   \   00000064   0x........         BL       __aeabi_idivmod
   \   00000068   0xE1B0A001         MOVS     R10,R1
   \   0000006C   0xE5D50001         LDRB     R0,[R5, #+1]
   \   00000070   0xE3A0100A         MOV      R1,#+10
   \   00000074   0x........         BL       __aeabi_idiv
   \   00000078   0xE19A0200         ORRS     R0,R10,R0, LSL #+4
   \   0000007C   0xE1B08000         MOVS     R8,R0
    206          	sec_bcd = (pTime->sec % 10) | ((pTime->sec / 10) << 4);
   \   00000080   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000084   0xE3A0100A         MOV      R1,#+10
   \   00000088   0x........         BL       __aeabi_idivmod
   \   0000008C   0xE1B0A001         MOVS     R10,R1
   \   00000090   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000094   0xE3A0100A         MOV      R1,#+10
   \   00000098   0x........         BL       __aeabi_idiv
   \   0000009C   0xE19A0200         ORRS     R0,R10,R0, LSL #+4
   \   000000A0   0xE1B09000         MOVS     R9,R0
    207          	/* value overflow */
    208          	if ((hour_bcd & (uint8_t) (~RTC_HOUR_BIT_LEN_MASK)) |
    209          	    (min_bcd & (uint8_t) (~RTC_MIN_BIT_LEN_MASK)) |
    210          	    (sec_bcd & (uint8_t) (~RTC_SEC_BIT_LEN_MASK))) {
   \   000000A4   0xE1B00007         MOVS     R0,R7
   \   000000A8   0xE6EF0070         UXTB     R0,R0
   \   000000AC   0xE21000C0         ANDS     R0,R0,#0xC0
   \   000000B0   0xE1B01008         MOVS     R1,R8
   \   000000B4   0xE6EF1071         UXTB     R1,R1
   \   000000B8   0xE2111080         ANDS     R1,R1,#0x80
   \   000000BC   0xE1910000         ORRS     R0,R1,R0
   \   000000C0   0xE1B01009         MOVS     R1,R9
   \   000000C4   0xE6EF1071         UXTB     R1,R1
   \   000000C8   0xE2111080         ANDS     R1,R1,#0x80
   \   000000CC   0xE1910000         ORRS     R0,R1,R0
   \   000000D0   0xE3500000         CMP      R0,#+0
   \   000000D4   0x0A000001         BEQ      ??rtc_set_time_1
    211          		return 1;
   \   000000D8   0xE3A00001         MOV      R0,#+1
   \   000000DC   0xEA000019         B        ??rtc_set_time_2
    212          	}
    213          	ltime = sec_bcd | (min_bcd << 8) | (hour_bcd << 16);
   \                     ??rtc_set_time_1:
   \   000000E0   0xE1B00009         MOVS     R0,R9
   \   000000E4   0xE6EF0070         UXTB     R0,R0
   \   000000E8   0xE1B01008         MOVS     R1,R8
   \   000000EC   0xE6EF1071         UXTB     R1,R1
   \   000000F0   0xE1900401         ORRS     R0,R0,R1, LSL #+8
   \   000000F4   0xE1B01007         MOVS     R1,R7
   \   000000F8   0xE6EF1071         UXTB     R1,R1
   \   000000FC   0xE1900801         ORRS     R0,R0,R1, LSL #+16
   \   00000100   0xE1B06000         MOVS     R6,R0
    214          	pRtc->RTC_CR |= RTC_CR_UPDTIM;
   \   00000104   0xE5940000         LDR      R0,[R4, #+0]
   \   00000108   0xE3900001         ORRS     R0,R0,#0x1
   \   0000010C   0xE5840000         STR      R0,[R4, #+0]
    215          	while ((pRtc->RTC_SR & RTC_SR_ACKUPD) != RTC_SR_ACKUPD) ;
   \                     ??rtc_set_time_3:
   \   00000110   0xE5940018         LDR      R0,[R4, #+24]
   \   00000114   0xE3100001         TST      R0,#0x1
   \   00000118   0x0AFFFFFC         BEQ      ??rtc_set_time_3
    216          	pRtc->RTC_SCCR = RTC_SCCR_ACKCLR;
   \   0000011C   0xE3A00001         MOV      R0,#+1
   \   00000120   0xE584001C         STR      R0,[R4, #+28]
    217          	pRtc->RTC_TIMR = ltime;
   \   00000124   0xE5846008         STR      R6,[R4, #+8]
    218          	pRtc->RTC_CR &= (uint32_t) (~RTC_CR_UPDTIM);
   \   00000128   0xE5940000         LDR      R0,[R4, #+0]
   \   0000012C   0xE3D00001         BICS     R0,R0,#0x1
   \   00000130   0xE5840000         STR      R0,[R4, #+0]
    219          	pRtc->RTC_SCCR |= RTC_SCCR_SECCLR;
   \   00000134   0xE594001C         LDR      R0,[R4, #+28]
   \   00000138   0xE3900004         ORRS     R0,R0,#0x4
   \   0000013C   0xE584001C         STR      R0,[R4, #+28]
    220          	return (int) (pRtc->RTC_VER & RTC_VER_NVTIM);
   \   00000140   0xE594002C         LDR      R0,[R4, #+44]
   \   00000144   0xE2100001         ANDS     R0,R0,#0x1
   \                     ??rtc_set_time_2:
   \   00000148   0xE8BD87F0         POP      {R4-R10,PC}      ;; return
    221          }
    222          
    223          /**
    224           * \brief Retrieves the current time as stored in the RTC in several variables.
    225           *
    226           * \param pRtc  Pointer to a Rtc instance
    227           * \param pTime Pointer to structure time
    228           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    229          void rtc_get_time(Rtc * pRtc, struct _time *pTime)
    230          {
   \                     rtc_get_time:
   \   00000000   0xE92D4000         PUSH     {LR}
    231          	uint32_t ltime;
    232          
    233          	TRACE_DEBUG("rtc_get_time()\n\r");
    234          	/* Get current RTC time */
    235          	ltime = pRtc->RTC_TIMR;
   \   00000004   0xE5903008         LDR      R3,[R0, #+8]
   \   00000008   0xE1B02003         MOVS     R2,R3
    236          	while (ltime != pRtc->RTC_TIMR) {
   \                     ??rtc_get_time_0:
   \   0000000C   0xE5903008         LDR      R3,[R0, #+8]
   \   00000010   0xE1520003         CMP      R2,R3
   \   00000014   0x0A000002         BEQ      ??rtc_get_time_1
    237          		ltime = pRtc->RTC_TIMR;
   \   00000018   0xE5903008         LDR      R3,[R0, #+8]
   \   0000001C   0xE1B02003         MOVS     R2,R3
   \   00000020   0xEAFFFFF9         B        ??rtc_get_time_0
    238          	}
    239          	/* Hour */
    240          	if (pTime->hour) {
   \                     ??rtc_get_time_1:
   \   00000024   0xE5D13000         LDRB     R3,[R1, #+0]
   \   00000028   0xE3530000         CMP      R3,#+0
   \   0000002C   0x0A000009         BEQ      ??rtc_get_time_2
    241          		pTime->hour = ((ltime & 0x00300000) >> 20) * 10 + ((ltime & 0x000F0000) >> 16);
   \   00000030   0xE7E13A52         UBFX     R3,R2,#+20,#+2
   \   00000034   0xE3A0C00A         MOV      R12,#+10
   \   00000038   0xE7E3E852         UBFX     LR,R2,#+16,#+4
   \   0000003C   0xE023E39C         MLA      R3,R12,R3,LR
   \   00000040   0xE5C13000         STRB     R3,[R1, #+0]
    242          		if ((ltime & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
   \   00000044   0xE3120840         TST      R2,#0x400000
   \   00000048   0x0A000002         BEQ      ??rtc_get_time_2
    243          			pTime->hour += 12;
   \   0000004C   0xE5D13000         LDRB     R3,[R1, #+0]
   \   00000050   0xE293300C         ADDS     R3,R3,#+12
   \   00000054   0xE5C13000         STRB     R3,[R1, #+0]
    244          		}
    245          	}
    246          	/* Minute */
    247          	if (pTime->min) {
   \                     ??rtc_get_time_2:
   \   00000058   0xE5D13001         LDRB     R3,[R1, #+1]
   \   0000005C   0xE3530000         CMP      R3,#+0
   \   00000060   0x0A000004         BEQ      ??rtc_get_time_3
    248          		pTime->min = ((ltime & 0x00007000) >> 12) * 10 + ((ltime & 0x00000F00) >> 8);
   \   00000064   0xE7E23652         UBFX     R3,R2,#+12,#+3
   \   00000068   0xE3A0C00A         MOV      R12,#+10
   \   0000006C   0xE7E3E452         UBFX     LR,R2,#+8,#+4
   \   00000070   0xE023E39C         MLA      R3,R12,R3,LR
   \   00000074   0xE5C13001         STRB     R3,[R1, #+1]
    249          	}
    250          	/* Second */
    251          	if (pTime->sec) {
   \                     ??rtc_get_time_3:
   \   00000078   0xE5D13002         LDRB     R3,[R1, #+2]
   \   0000007C   0xE3530000         CMP      R3,#+0
   \   00000080   0x0A000004         BEQ      ??rtc_get_time_4
    252          		pTime->sec = ((ltime & 0x00000070) >> 4) * 10 + (ltime & 0x0000000F);
   \   00000084   0xE7E23252         UBFX     R3,R2,#+4,#+3
   \   00000088   0xE3A0C00A         MOV      R12,#+10
   \   0000008C   0xE212E00F         ANDS     LR,R2,#0xF
   \   00000090   0xE023E39C         MLA      R3,R12,R3,LR
   \   00000094   0xE5C13002         STRB     R3,[R1, #+2]
    253          	}
    254          }
   \                     ??rtc_get_time_4:
   \   00000098   0xE8BD8000         POP      {PC}             ;; return
    255          
    256          /**
    257           * \brief Sets a time alarm on the RTC.
    258           * The match is performed only on the provided variables;
    259           * Setting all pointers to 0 disables the time alarm.
    260           *
    261           * \note In AM/PM mode, the hour value must have bit #7 set for PM, cleared for
    262           * AM (as expected in the time registers).
    263           *
    264           * \param pRtc  Pointer to a Rtc instance
    265           * \param pTime Pointer to structure time.
    266           *
    267           * \return 0 success, 1 fail to set
    268           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    269          extern int rtc_set_time_alarm(Rtc * pRtc, struct _time *pTime)
    270          {
   \                     rtc_set_time_alarm:
   \   00000000   0xE92D40F0         PUSH     {R4-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    271          	uint32_t alarm = 0;
   \   0000000C   0xE3A06000         MOV      R6,#+0
    272          
    273          	TRACE_DEBUG("rtc_set_time_alarm()\n\r");
    274          
    275          	/* Hour */
    276          	if (pTime->hour) {
   \   00000010   0xE5D50000         LDRB     R0,[R5, #+0]
   \   00000014   0xE3500000         CMP      R0,#+0
   \   00000018   0x0A00000A         BEQ      ??rtc_set_time_alarm_0
    277          		alarm |= RTC_TIMALR_HOUREN | ((pTime->hour / 10) << 20) | ((pTime->hour % 10) << 16);
   \   0000001C   0xE5D50000         LDRB     R0,[R5, #+0]
   \   00000020   0xE3A0100A         MOV      R1,#+10
   \   00000024   0x........         BL       __aeabi_idiv
   \   00000028   0xE1B07000         MOVS     R7,R0
   \   0000002C   0xE5D50000         LDRB     R0,[R5, #+0]
   \   00000030   0xE3A0100A         MOV      R1,#+10
   \   00000034   0x........         BL       __aeabi_idivmod
   \   00000038   0xE1B00801         LSLS     R0,R1,#+16
   \   0000003C   0xE1900A07         ORRS     R0,R0,R7, LSL #+20
   \   00000040   0xE3900880         ORRS     R0,R0,#0x800000
   \   00000044   0xE1906006         ORRS     R6,R0,R6
    278          	}
    279          	/* Minute */
    280          	if (pTime->min) {
   \                     ??rtc_set_time_alarm_0:
   \   00000048   0xE5D50001         LDRB     R0,[R5, #+1]
   \   0000004C   0xE3500000         CMP      R0,#+0
   \   00000050   0x0A00000A         BEQ      ??rtc_set_time_alarm_1
    281          		alarm |= RTC_TIMALR_MINEN | ((pTime->min / 10) << 12) | ((pTime->min % 10) << 8);
   \   00000054   0xE5D50001         LDRB     R0,[R5, #+1]
   \   00000058   0xE3A0100A         MOV      R1,#+10
   \   0000005C   0x........         BL       __aeabi_idiv
   \   00000060   0xE1B07000         MOVS     R7,R0
   \   00000064   0xE5D50001         LDRB     R0,[R5, #+1]
   \   00000068   0xE3A0100A         MOV      R1,#+10
   \   0000006C   0x........         BL       __aeabi_idivmod
   \   00000070   0xE1B00401         LSLS     R0,R1,#+8
   \   00000074   0xE1900607         ORRS     R0,R0,R7, LSL #+12
   \   00000078   0xE3900C80         ORRS     R0,R0,#0x8000
   \   0000007C   0xE1906006         ORRS     R6,R0,R6
    282          	}
    283          	/* Second */
    284          	if (pTime->sec) {
   \                     ??rtc_set_time_alarm_1:
   \   00000080   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000084   0xE3500000         CMP      R0,#+0
   \   00000088   0x0A000009         BEQ      ??rtc_set_time_alarm_2
    285          		alarm |= RTC_TIMALR_SECEN | ((pTime->sec / 10) << 4) | (pTime->sec % 10);
   \   0000008C   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000090   0xE3A0100A         MOV      R1,#+10
   \   00000094   0x........         BL       __aeabi_idiv
   \   00000098   0xE1B07000         MOVS     R7,R0
   \   0000009C   0xE5D50002         LDRB     R0,[R5, #+2]
   \   000000A0   0xE3A0100A         MOV      R1,#+10
   \   000000A4   0x........         BL       __aeabi_idivmod
   \   000000A8   0xE1910207         ORRS     R0,R1,R7, LSL #+4
   \   000000AC   0xE3900080         ORRS     R0,R0,#0x80
   \   000000B0   0xE1906006         ORRS     R6,R0,R6
    286          	}
    287          	pRtc->RTC_TIMALR = alarm;
   \                     ??rtc_set_time_alarm_2:
   \   000000B4   0xE5846010         STR      R6,[R4, #+16]
    288          	return (int) (pRtc->RTC_VER & RTC_VER_NVTIMALR);
   \   000000B8   0xE594002C         LDR      R0,[R4, #+44]
   \   000000BC   0xE2100004         ANDS     R0,R0,#0x4
   \   000000C0   0xE8BD80F0         POP      {R4-R7,PC}       ;; return
    289          }
    290          
    291          /**
    292           * \brief Retrieves the current year, month and day from the RTC.
    293           * Month, day and week values are numbered starting at 1.
    294           *
    295           * \param pRtc  Pointer to a Rtc instance
    296           * \param pDate	Pointer to structure Date.
    297           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    298          void rtc_get_date(Rtc * pRtc, struct _date *pDate)
    299          {
   \                     rtc_get_date:
   \   00000000   0xE92D4000         PUSH     {LR}
    300          	uint32_t date;
    301          
    302          	/* Get current date (multiple reads are necessary to insure a stable value) */
    303          	do {
    304          		date = pRtc->RTC_CALR;
   \                     ??rtc_get_date_0:
   \   00000004   0xE590300C         LDR      R3,[R0, #+12]
   \   00000008   0xE1B02003         MOVS     R2,R3
    305          	} while (date != pRtc->RTC_CALR);
   \   0000000C   0xE590300C         LDR      R3,[R0, #+12]
   \   00000010   0xE1520003         CMP      R2,R3
   \   00000014   0x1AFFFFFA         BNE      ??rtc_get_date_0
    306          	/* Retrieve year */
    307          	if (pDate->year) {
   \   00000018   0xE1D130B0         LDRH     R3,[R1, #+0]
   \   0000001C   0xE3530000         CMP      R3,#+0
   \   00000020   0x0A00000C         BEQ      ??rtc_get_date_1
    308          		pDate->year = (((date >> 4) & 0x7) * 1000) + ((date & 0xF) * 100)
    309          			+ (((date >> 12) & 0xF) * 10) + ((date >> 8) & 0xF);
   \   00000024   0xE7E23252         UBFX     R3,R2,#+4,#+3
   \   00000028   0xE3A0CFFA         MOV      R12,#+1000
   \   0000002C   0xE1630C83         SMULBB   R3,R3,R12
   \   00000030   0xE1B0C002         MOVS     R12,R2
   \   00000034   0xE21CC00F         ANDS     R12,R12,#0xF
   \   00000038   0xE3A0E064         MOV      LR,#+100
   \   0000003C   0xE1033E8C         SMLABB   R3,R12,LR,R3
   \   00000040   0xE7E3C652         UBFX     R12,R2,#+12,#+4
   \   00000044   0xE3A0E00A         MOV      LR,#+10
   \   00000048   0xE1033E8C         SMLABB   R3,R12,LR,R3
   \   0000004C   0xE7E3C452         UBFX     R12,R2,#+8,#+4
   \   00000050   0xE09C3003         ADDS     R3,R12,R3
   \   00000054   0xE1C130B0         STRH     R3,[R1, #+0]
    310          	}
    311          	/* Retrieve month */
    312          	if (pDate->month) {
   \                     ??rtc_get_date_1:
   \   00000058   0xE5D13002         LDRB     R3,[R1, #+2]
   \   0000005C   0xE3530000         CMP      R3,#+0
   \   00000060   0x0A000004         BEQ      ??rtc_get_date_2
    313          		pDate->month = (((date >> 20) & 1) * 10) + ((date >> 16) & 0xF);
   \   00000064   0xE7E03A52         UBFX     R3,R2,#+20,#+1
   \   00000068   0xE3A0C00A         MOV      R12,#+10
   \   0000006C   0xE7E3E852         UBFX     LR,R2,#+16,#+4
   \   00000070   0xE023E39C         MLA      R3,R12,R3,LR
   \   00000074   0xE5C13002         STRB     R3,[R1, #+2]
    314          	}
    315          	/* Retrieve day */
    316          	if (pDate->day) {
   \                     ??rtc_get_date_2:
   \   00000078   0xE5D13003         LDRB     R3,[R1, #+3]
   \   0000007C   0xE3530000         CMP      R3,#+0
   \   00000080   0x0A000004         BEQ      ??rtc_get_date_3
    317          		pDate->day = (((date >> 28) & 0x3) * 10) + ((date >> 24) & 0xF);
   \   00000084   0xE7E13E52         UBFX     R3,R2,#+28,#+2
   \   00000088   0xE3A0C00A         MOV      R12,#+10
   \   0000008C   0xE7E3EC52         UBFX     LR,R2,#+24,#+4
   \   00000090   0xE023E39C         MLA      R3,R12,R3,LR
   \   00000094   0xE5C13003         STRB     R3,[R1, #+3]
    318          	}
    319          	/* Retrieve week */
    320          	if (pDate->week) {
   \                     ??rtc_get_date_3:
   \   00000098   0xE5D13004         LDRB     R3,[R1, #+4]
   \   0000009C   0xE3530000         CMP      R3,#+0
   \   000000A0   0x0A000002         BEQ      ??rtc_get_date_4
    321          		pDate->week = ((date >> 21) & 0x7);
   \   000000A4   0xE1B03AA2         LSRS     R3,R2,#+21
   \   000000A8   0xE2133007         ANDS     R3,R3,#0x7
   \   000000AC   0xE5C13004         STRB     R3,[R1, #+4]
    322          	}
    323          }
   \                     ??rtc_get_date_4:
   \   000000B0   0xE8BD8000         POP      {PC}             ;; return
    324          
    325          /**
    326           * \brief Sets the current year, month and day in the RTC.
    327           * Month, day and week values must be numbered starting from 1.
    328           *
    329           * \note In successive update operations, the user must wait at least one second
    330           * after resetting the UPDTIM/UPDCAL bit in the RTC_CR before setting these
    331           * bits again. Please look at the RTC section of the datasheet for detail.
    332           *
    333           * \param pRtc  Pointer to a Rtc instance
    334           * \param pDate	Pointer to structure Date
    335           *
    336           * \return 0 success, 1 fail to set
    337           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    338          extern int rtc_set_date(Rtc * pRtc, struct _date *pDate)
    339          {
   \                     rtc_set_date:
   \   00000000   0xE92D4FF8         PUSH     {R3-R11,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    340          	uint32_t ldate;
    341          	uint8_t cent_bcd, year_bcd, month_bcd, day_bcd, week_bcd;
    342          
    343          	cent_bcd = ((pDate->year / 100) % 10) | ((pDate->year / 1000) << 4);
   \   0000000C   0xE1D500B0         LDRH     R0,[R5, #+0]
   \   00000010   0xE3A01064         MOV      R1,#+100
   \   00000014   0x........         BL       __aeabi_idiv
   \   00000018   0xE3A0100A         MOV      R1,#+10
   \   0000001C   0x........         BL       __aeabi_idivmod
   \   00000020   0xE58D1000         STR      R1,[SP, #+0]
   \   00000024   0xE1D500B0         LDRH     R0,[R5, #+0]
   \   00000028   0xE3A01FFA         MOV      R1,#+1000
   \   0000002C   0x........         BL       __aeabi_idiv
   \   00000030   0xE59D1000         LDR      R1,[SP, #+0]
   \   00000034   0xE1910200         ORRS     R0,R1,R0, LSL #+4
   \   00000038   0xE1B07000         MOVS     R7,R0
    344          	year_bcd = (pDate->year % 10) | (((pDate->year / 10) % 10) << 4);
   \   0000003C   0xE1D500B0         LDRH     R0,[R5, #+0]
   \   00000040   0xE3A0100A         MOV      R1,#+10
   \   00000044   0x........         BL       __aeabi_idivmod
   \   00000048   0xE58D1000         STR      R1,[SP, #+0]
   \   0000004C   0xE1D500B0         LDRH     R0,[R5, #+0]
   \   00000050   0xE3A0100A         MOV      R1,#+10
   \   00000054   0x........         BL       __aeabi_idiv
   \   00000058   0xE3A0100A         MOV      R1,#+10
   \   0000005C   0x........         BL       __aeabi_idivmod
   \   00000060   0xE59D0000         LDR      R0,[SP, #+0]
   \   00000064   0xE1900201         ORRS     R0,R0,R1, LSL #+4
   \   00000068   0xE1B08000         MOVS     R8,R0
    345          	month_bcd = ((pDate->month % 10) | (pDate->month / 10) << 4);
   \   0000006C   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000070   0xE3A0100A         MOV      R1,#+10
   \   00000074   0x........         BL       __aeabi_idivmod
   \   00000078   0xE58D1000         STR      R1,[SP, #+0]
   \   0000007C   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000080   0xE3A0100A         MOV      R1,#+10
   \   00000084   0x........         BL       __aeabi_idiv
   \   00000088   0xE59D1000         LDR      R1,[SP, #+0]
   \   0000008C   0xE1910200         ORRS     R0,R1,R0, LSL #+4
   \   00000090   0xE1B09000         MOVS     R9,R0
    346          	day_bcd = ((pDate->day % 10) | (pDate->day / 10) << 4);
   \   00000094   0xE5D50003         LDRB     R0,[R5, #+3]
   \   00000098   0xE3A0100A         MOV      R1,#+10
   \   0000009C   0x........         BL       __aeabi_idivmod
   \   000000A0   0xE58D1000         STR      R1,[SP, #+0]
   \   000000A4   0xE5D50003         LDRB     R0,[R5, #+3]
   \   000000A8   0xE3A0100A         MOV      R1,#+10
   \   000000AC   0x........         BL       __aeabi_idiv
   \   000000B0   0xE59D1000         LDR      R1,[SP, #+0]
   \   000000B4   0xE1910200         ORRS     R0,R1,R0, LSL #+4
   \   000000B8   0xE1B0A000         MOVS     R10,R0
    347          	week_bcd = ((pDate->week % 10) | (pDate->week / 10) << 4);
   \   000000BC   0xE5D50004         LDRB     R0,[R5, #+4]
   \   000000C0   0xE3A0100A         MOV      R1,#+10
   \   000000C4   0x........         BL       __aeabi_idivmod
   \   000000C8   0xE58D1000         STR      R1,[SP, #+0]
   \   000000CC   0xE5D50004         LDRB     R0,[R5, #+4]
   \   000000D0   0xE3A0100A         MOV      R1,#+10
   \   000000D4   0x........         BL       __aeabi_idiv
   \   000000D8   0xE59D1000         LDR      R1,[SP, #+0]
   \   000000DC   0xE1910200         ORRS     R0,R1,R0, LSL #+4
   \   000000E0   0xE1B0B000         MOVS     R11,R0
    348          	/* value over flow */
    349          	if ((cent_bcd & (uint8_t) (~RTC_CENT_BIT_LEN_MASK)) |
    350          	    (year_bcd & (uint8_t) (~RTC_YEAR_BIT_LEN_MASK)) |
    351          	    (month_bcd & (uint8_t) (~RTC_MONTH_BIT_LEN_MASK)) |
    352          	    (week_bcd & (uint8_t) (~RTC_WEEK_BIT_LEN_MASK)) |
    353          	    (day_bcd & (uint8_t) (~RTC_DATE_BIT_LEN_MASK))
    354          	    ) {
   \   000000E4   0xE1B00007         MOVS     R0,R7
   \   000000E8   0xE6EF0070         UXTB     R0,R0
   \   000000EC   0xE2100080         ANDS     R0,R0,#0x80
   \   000000F0   0xE1B01009         MOVS     R1,R9
   \   000000F4   0xE6EF1071         UXTB     R1,R1
   \   000000F8   0xE21110E0         ANDS     R1,R1,#0xE0
   \   000000FC   0xE1910000         ORRS     R0,R1,R0
   \   00000100   0xE1B0100B         MOVS     R1,R11
   \   00000104   0xE6EF1071         UXTB     R1,R1
   \   00000108   0xE21110F8         ANDS     R1,R1,#0xF8
   \   0000010C   0xE1910000         ORRS     R0,R1,R0
   \   00000110   0xE1B0100A         MOVS     R1,R10
   \   00000114   0xE6EF1071         UXTB     R1,R1
   \   00000118   0xE21110C0         ANDS     R1,R1,#0xC0
   \   0000011C   0xE1910000         ORRS     R0,R1,R0
   \   00000120   0xE3500000         CMP      R0,#+0
   \   00000124   0x0A000001         BEQ      ??rtc_set_date_0
    355          		return 1;
   \   00000128   0xE3A00001         MOV      R0,#+1
   \   0000012C   0xEA00001F         B        ??rtc_set_date_1
    356          	}
    357          	/* Convert values to date register value */
    358          	ldate = cent_bcd | (year_bcd << 8) | (month_bcd << 16) | (week_bcd << 21) | (day_bcd << 24);
   \                     ??rtc_set_date_0:
   \   00000130   0xE1B00007         MOVS     R0,R7
   \   00000134   0xE6EF0070         UXTB     R0,R0
   \   00000138   0xE1B01008         MOVS     R1,R8
   \   0000013C   0xE6EF1071         UXTB     R1,R1
   \   00000140   0xE1900401         ORRS     R0,R0,R1, LSL #+8
   \   00000144   0xE1B01009         MOVS     R1,R9
   \   00000148   0xE6EF1071         UXTB     R1,R1
   \   0000014C   0xE1900801         ORRS     R0,R0,R1, LSL #+16
   \   00000150   0xE1B0100B         MOVS     R1,R11
   \   00000154   0xE6EF1071         UXTB     R1,R1
   \   00000158   0xE1900A81         ORRS     R0,R0,R1, LSL #+21
   \   0000015C   0xE1B0100A         MOVS     R1,R10
   \   00000160   0xE6EF1071         UXTB     R1,R1
   \   00000164   0xE1900C01         ORRS     R0,R0,R1, LSL #+24
   \   00000168   0xE1B06000         MOVS     R6,R0
    359          	/* Update calendar register  */
    360          	pRtc->RTC_CR |= RTC_CR_UPDCAL;
   \   0000016C   0xE5940000         LDR      R0,[R4, #+0]
   \   00000170   0xE3900002         ORRS     R0,R0,#0x2
   \   00000174   0xE5840000         STR      R0,[R4, #+0]
    361          	while ((pRtc->RTC_SR & RTC_SR_ACKUPD) != RTC_SR_ACKUPD) ;
   \                     ??rtc_set_date_2:
   \   00000178   0xE5940018         LDR      R0,[R4, #+24]
   \   0000017C   0xE3100001         TST      R0,#0x1
   \   00000180   0x0AFFFFFC         BEQ      ??rtc_set_date_2
    362          	pRtc->RTC_SCCR = RTC_SCCR_ACKCLR;
   \   00000184   0xE3A00001         MOV      R0,#+1
   \   00000188   0xE584001C         STR      R0,[R4, #+28]
    363          	pRtc->RTC_CALR = ldate;
   \   0000018C   0xE584600C         STR      R6,[R4, #+12]
    364          	pRtc->RTC_CR &= (uint32_t) (~RTC_CR_UPDCAL);
   \   00000190   0xE5940000         LDR      R0,[R4, #+0]
   \   00000194   0xE3D00002         BICS     R0,R0,#0x2
   \   00000198   0xE5840000         STR      R0,[R4, #+0]
    365          	pRtc->RTC_SCCR |= RTC_SCCR_SECCLR;	/* clear SECENV in SCCR */
   \   0000019C   0xE594001C         LDR      R0,[R4, #+28]
   \   000001A0   0xE3900004         ORRS     R0,R0,#0x4
   \   000001A4   0xE584001C         STR      R0,[R4, #+28]
    366          	return (int) (pRtc->RTC_VER & RTC_VER_NVCAL);
   \   000001A8   0xE594002C         LDR      R0,[R4, #+44]
   \   000001AC   0xE2100002         ANDS     R0,R0,#0x2
   \                     ??rtc_set_date_1:
   \   000001B0   0xE8BD8FF2         POP      {R1,R4-R11,PC}   ;; return
    367          }
    368          
    369          /**
    370           * \brief Sets a date alarm in the RTC.
    371           * The alarm will match only the provided values;
    372           * Passing a null-pointer disables the corresponding field match.
    373           *
    374           * \param pRtc  Pointer to a Rtc instance
    375           * \param pucMonth If not null, the RTC alarm will month-match this value.
    376           * \param pucDay   If not null, the RTC alarm will day-match this value.
    377           *
    378           * \return 0 success, 1 fail to set
    379           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    380          extern int rtc_set_date_alarm(Rtc * pRtc, struct _date *pDate)
    381          {
   \                     rtc_set_date_alarm:
   \   00000000   0xE92D40F0         PUSH     {R4-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    382          	uint32_t alarm;
    383          
    384          	alarm = ((pDate->month) || (pDate->day)) ? (0) : (0x01010000);
   \   0000000C   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000010   0xE3500000         CMP      R0,#+0
   \   00000014   0x1A000002         BNE      ??rtc_set_date_alarm_0
   \   00000018   0xE5D50003         LDRB     R0,[R5, #+3]
   \   0000001C   0xE3500000         CMP      R0,#+0
   \   00000020   0x0A000001         BEQ      ??rtc_set_date_alarm_1
   \                     ??rtc_set_date_alarm_0:
   \   00000024   0xE3A06000         MOV      R6,#+0
   \   00000028   0xEA000001         B        ??rtc_set_date_alarm_2
   \                     ??rtc_set_date_alarm_1:
   \   0000002C   0xE3A06740         MOV      R6,#+16777216
   \   00000030   0xE3866B40         ORR      R6,R6,#0x10000
    385          	TRACE_DEBUG("rtc_set_date_alarm()\n\r");
    386          	/* Compute alarm field value */
    387          	if (pDate->month) {
   \                     ??rtc_set_date_alarm_2:
   \   00000034   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000038   0xE3500000         CMP      R0,#+0
   \   0000003C   0x0A00000A         BEQ      ??rtc_set_date_alarm_3
    388          		alarm |= RTC_CALALR_MTHEN | ((pDate->month / 10) << 20) | ((pDate->month % 10) << 16);
   \   00000040   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000044   0xE3A0100A         MOV      R1,#+10
   \   00000048   0x........         BL       __aeabi_idiv
   \   0000004C   0xE1B07000         MOVS     R7,R0
   \   00000050   0xE5D50002         LDRB     R0,[R5, #+2]
   \   00000054   0xE3A0100A         MOV      R1,#+10
   \   00000058   0x........         BL       __aeabi_idivmod
   \   0000005C   0xE1B00801         LSLS     R0,R1,#+16
   \   00000060   0xE1900A07         ORRS     R0,R0,R7, LSL #+20
   \   00000064   0xE3900880         ORRS     R0,R0,#0x800000
   \   00000068   0xE1906006         ORRS     R6,R0,R6
    389          	}
    390          	if (pDate->day) {
   \                     ??rtc_set_date_alarm_3:
   \   0000006C   0xE5D50003         LDRB     R0,[R5, #+3]
   \   00000070   0xE3500000         CMP      R0,#+0
   \   00000074   0x0A00000A         BEQ      ??rtc_set_date_alarm_4
    391          		alarm |= RTC_CALALR_DATEEN | ((pDate->day / 10) << 28) | ((pDate->day % 10) << 24);
   \   00000078   0xE5D50003         LDRB     R0,[R5, #+3]
   \   0000007C   0xE3A0100A         MOV      R1,#+10
   \   00000080   0x........         BL       __aeabi_idiv
   \   00000084   0xE1B07000         MOVS     R7,R0
   \   00000088   0xE5D50003         LDRB     R0,[R5, #+3]
   \   0000008C   0xE3A0100A         MOV      R1,#+10
   \   00000090   0x........         BL       __aeabi_idivmod
   \   00000094   0xE1B00C01         LSLS     R0,R1,#+24
   \   00000098   0xE1900E07         ORRS     R0,R0,R7, LSL #+28
   \   0000009C   0xE3900480         ORRS     R0,R0,#0x80000000
   \   000000A0   0xE1906006         ORRS     R6,R0,R6
    392          	}
    393          	/* Set alarm */
    394          	pRtc->RTC_CALALR = alarm;
   \                     ??rtc_set_date_alarm_4:
   \   000000A4   0xE5846014         STR      R6,[R4, #+20]
    395          	return (int) (pRtc->RTC_VER & RTC_VER_NVCALALR);
   \   000000A8   0xE594002C         LDR      R0,[R4, #+44]
   \   000000AC   0xE2100008         ANDS     R0,R0,#0x8
   \   000000B0   0xE8BD80F0         POP      {R4-R7,PC}       ;; return
    396          }
    397          
    398          /**
    399           * \brief Clear flag bits of status clear command register in the RTC.
    400           *
    401           * \param pRtc  Pointer to a Rtc instance
    402           * \param dwMask Bits mask of cleared events
    403           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    404          void rtc_clear_sccr(Rtc * pRtc, uint32_t mask)
    405          {
    406          	/* Clear all flag bits in status clear command register */
    407          	mask &= RTC_SCCR_ACKCLR | RTC_SCCR_ALRCLR | RTC_SCCR_SECCLR |
    408          		RTC_SCCR_TIMCLR | RTC_SCCR_CALCLR;
   \                     rtc_clear_sccr:
   \   00000000   0xE211101F         ANDS     R1,R1,#0x1F
    409          	pRtc->RTC_SCCR = mask;
   \   00000004   0xE580101C         STR      R1,[R0, #+28]
    410          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    411          
    412          /**
    413           * \brief Get flag bits of status register in the RTC.
    414           *
    415           * \param pRtc  Pointer to a Rtc instance
    416           * \param dwMask Bits mask of Status Register
    417           *
    418           * \return Status register & mask
    419           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    420          extern uint32_t rtc_get_sr(Rtc * pRtc, uint32_t mask)
    421          {
    422          	return ((pRtc->RTC_SR) & mask);
   \                     rtc_get_sr:
   \   00000000   0xE5900018         LDR      R0,[R0, #+24]
   \   00000004   0xE0110000         ANDS     R0,R1,R0
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    423          }
    424          
    425          /**
    426           * \brief Get the RTC tamper time value.
    427           *
    428           * \note This function should be called before rtc_get_tamper_source()
    429           *       function call, Otherwise the tamper time will be cleared.
    430           *
    431           * \param pRtc       Pointer to an RTC instance.
    432           * \param pTime    	 Pointer to structure Time.
    433           * \param reg_num    Tamper register set number.
    434           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    435          void rtc_get_tamper_time(Rtc * pRtc, struct _time *pTime,  uint8_t reg_num)
    436          {
   \                     rtc_get_tamper_time:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
    437          	uint32_t ltime, temp;
    438          
    439          	TRACE_DEBUG("rtc_get_tamper_time()\n\r");
    440          
    441          	/* Get current RTC time */
    442          	ltime = pRtc->RTC_TS[reg_num].RTC_TSTR;
   \   00000004   0xE1B0E002         MOVS     LR,R2
   \   00000008   0xE6EFE07E         UXTB     LR,LR
   \   0000000C   0xE08E408E         ADD      R4,LR,LR, LSL #+1
   \   00000010   0xE090E104         ADDS     LR,R0,R4, LSL #+2
   \   00000014   0xE59EE0B0         LDR      LR,[LR, #+176]
   \   00000018   0xE1B0300E         MOVS     R3,LR
    443          	while (ltime != pRtc->RTC_TS[reg_num].RTC_TSTR) {
   \                     ??rtc_get_tamper_time_0:
   \   0000001C   0xE1B0E002         MOVS     LR,R2
   \   00000020   0xE6EFE07E         UXTB     LR,LR
   \   00000024   0xE08E408E         ADD      R4,LR,LR, LSL #+1
   \   00000028   0xE090E104         ADDS     LR,R0,R4, LSL #+2
   \   0000002C   0xE59EE0B0         LDR      LR,[LR, #+176]
   \   00000030   0xE153000E         CMP      R3,LR
   \   00000034   0x0A000006         BEQ      ??rtc_get_tamper_time_1
    444          		ltime = pRtc->RTC_TS[reg_num].RTC_TSTR;
   \   00000038   0xE1B0E002         MOVS     LR,R2
   \   0000003C   0xE6EFE07E         UXTB     LR,LR
   \   00000040   0xE08E408E         ADD      R4,LR,LR, LSL #+1
   \   00000044   0xE090E104         ADDS     LR,R0,R4, LSL #+2
   \   00000048   0xE59EE0B0         LDR      LR,[LR, #+176]
   \   0000004C   0xE1B0300E         MOVS     R3,LR
   \   00000050   0xEAFFFFF1         B        ??rtc_get_tamper_time_0
    445          	}
    446          	/* Hour */
    447          	if (pTime->hour) {
   \                     ??rtc_get_tamper_time_1:
   \   00000054   0xE5D1E000         LDRB     LR,[R1, #+0]
   \   00000058   0xE35E0000         CMP      LR,#+0
   \   0000005C   0x0A00000B         BEQ      ??rtc_get_tamper_time_2
    448          		temp = (ltime & RTC_TSTR_HOUR_Msk) >> RTC_TSTR_HOUR_Pos;
   \   00000060   0xE7E5E853         UBFX     LR,R3,#+16,#+6
   \   00000064   0xE1B0C00E         MOVS     R12,LR
    449          		pTime->hour = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
   \   00000068   0xE1B0E22C         LSRS     LR,R12,#+4
   \   0000006C   0xE3A0400A         MOV      R4,#+10
   \   00000070   0xE21C500F         ANDS     R5,R12,#0xF
   \   00000074   0xE02E5E94         MLA      LR,R4,LR,R5
   \   00000078   0xE5C1E000         STRB     LR,[R1, #+0]
    450          		if ((ltime & RTC_TSTR_AMPM) == RTC_TSTR_AMPM) {
   \   0000007C   0xE3130840         TST      R3,#0x400000
   \   00000080   0x0A000002         BEQ      ??rtc_get_tamper_time_2
    451          			pTime->hour += 12;
   \   00000084   0xE5D1E000         LDRB     LR,[R1, #+0]
   \   00000088   0xE29EE00C         ADDS     LR,LR,#+12
   \   0000008C   0xE5C1E000         STRB     LR,[R1, #+0]
    452          		}
    453          	}
    454          	/* Minute */
    455          	if (pTime->min) {
   \                     ??rtc_get_tamper_time_2:
   \   00000090   0xE5D1E001         LDRB     LR,[R1, #+1]
   \   00000094   0xE35E0000         CMP      LR,#+0
   \   00000098   0x0A000006         BEQ      ??rtc_get_tamper_time_3
    456          		temp = (ltime & RTC_TSTR_MIN_Msk) >> RTC_TSTR_MIN_Pos;
   \   0000009C   0xE7E6E453         UBFX     LR,R3,#+8,#+7
   \   000000A0   0xE1B0C00E         MOVS     R12,LR
    457          		pTime->min = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
   \   000000A4   0xE1B0E22C         LSRS     LR,R12,#+4
   \   000000A8   0xE3A0400A         MOV      R4,#+10
   \   000000AC   0xE21C500F         ANDS     R5,R12,#0xF
   \   000000B0   0xE02E5E94         MLA      LR,R4,LR,R5
   \   000000B4   0xE5C1E001         STRB     LR,[R1, #+1]
    458          	}
    459          	/* Second */
    460          	if (pTime->sec) {
   \                     ??rtc_get_tamper_time_3:
   \   000000B8   0xE5D1E002         LDRB     LR,[R1, #+2]
   \   000000BC   0xE35E0000         CMP      LR,#+0
   \   000000C0   0x0A000006         BEQ      ??rtc_get_tamper_time_4
    461          		temp = (ltime & RTC_TSTR_SEC_Msk) >> RTC_TSTR_SEC_Pos;
   \   000000C4   0xE213E07F         ANDS     LR,R3,#0x7F
   \   000000C8   0xE1B0C00E         MOVS     R12,LR
    462          		pTime->sec = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
   \   000000CC   0xE1B0E22C         LSRS     LR,R12,#+4
   \   000000D0   0xE3A0400A         MOV      R4,#+10
   \   000000D4   0xE21C500F         ANDS     R5,R12,#0xF
   \   000000D8   0xE02E5E94         MLA      LR,R4,LR,R5
   \   000000DC   0xE5C1E002         STRB     LR,[R1, #+2]
    463          	}
    464          }
   \                     ??rtc_get_tamper_time_4:
   \   000000E0   0xE8BD8030         POP      {R4,R5,PC}       ;; return
    465          
    466          /**
    467           * \brief Get the RTC tamper date.
    468           *
    469           * \note This function should be called before rtc_get_tamper_source()
    470           *       function call, Otherwise the tamper date will be cleared.
    471           *
    472           * \param pRtc      Pointer to an RTC instance.
    473           * \param pDate     Pointer to structure Date
    474           * \param reg_num   Tamper register set number.
    475           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    476          void rtc_get_tamper_date(Rtc * pRtc, struct _date *pDate, uint8_t reg_num)
    477          {
   \                     rtc_get_tamper_date:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
    478          	uint32_t date, cent, temp;
    479          
    480          	/* Get the current date (multiple reads are to insure a stable value). */
    481          	date = pRtc->RTC_TS[reg_num].RTC_TSDR;
   \   00000004   0xE1B04002         MOVS     R4,R2
   \   00000008   0xE6EF4074         UXTB     R4,R4
   \   0000000C   0xE0845084         ADD      R5,R4,R4, LSL #+1
   \   00000010   0xE0904105         ADDS     R4,R0,R5, LSL #+2
   \   00000014   0xE59440B4         LDR      R4,[R4, #+180]
   \   00000018   0xE1B03004         MOVS     R3,R4
    482          	while (date != pRtc->RTC_TS[reg_num].RTC_TSDR) {
   \                     ??rtc_get_tamper_date_0:
   \   0000001C   0xE1B04002         MOVS     R4,R2
   \   00000020   0xE6EF4074         UXTB     R4,R4
   \   00000024   0xE0845084         ADD      R5,R4,R4, LSL #+1
   \   00000028   0xE0904105         ADDS     R4,R0,R5, LSL #+2
   \   0000002C   0xE59440B4         LDR      R4,[R4, #+180]
   \   00000030   0xE1530004         CMP      R3,R4
   \   00000034   0x0A000006         BEQ      ??rtc_get_tamper_date_1
    483          		date = pRtc->RTC_TS[reg_num].RTC_TSDR;
   \   00000038   0xE1B04002         MOVS     R4,R2
   \   0000003C   0xE6EF4074         UXTB     R4,R4
   \   00000040   0xE0845084         ADD      R5,R4,R4, LSL #+1
   \   00000044   0xE0904105         ADDS     R4,R0,R5, LSL #+2
   \   00000048   0xE59440B4         LDR      R4,[R4, #+180]
   \   0000004C   0xE1B03004         MOVS     R3,R4
   \   00000050   0xEAFFFFF1         B        ??rtc_get_tamper_date_0
    484          	}
    485          	/* Retrieve year */
    486          	if (pDate->year) {
   \                     ??rtc_get_tamper_date_1:
   \   00000054   0xE1D140B0         LDRH     R4,[R1, #+0]
   \   00000058   0xE3540000         CMP      R4,#+0
   \   0000005C   0x0A000011         BEQ      ??rtc_get_tamper_date_2
    487          		temp = (date & RTC_TSDR_CENT_Msk) >> RTC_TSDR_CENT_Pos;
   \   00000060   0xE213407F         ANDS     R4,R3,#0x7F
   \   00000064   0xE1B0E004         MOVS     LR,R4
    488          		cent = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
   \   00000068   0xE1B0422E         LSRS     R4,LR,#+4
   \   0000006C   0xE3A0500A         MOV      R5,#+10
   \   00000070   0xE21E600F         ANDS     R6,LR,#0xF
   \   00000074   0xE0246495         MLA      R4,R5,R4,R6
   \   00000078   0xE1B0C004         MOVS     R12,R4
    489          		temp = (date & RTC_TSDR_YEAR_Msk) >> RTC_TSDR_YEAR_Pos;
   \   0000007C   0xE7E74453         UBFX     R4,R3,#+8,#+8
   \   00000080   0xE1B0E004         MOVS     LR,R4
    490          		pDate->year = (cent * BCD_FACTOR * BCD_FACTOR) + (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
   \   00000084   0xE3A04064         MOV      R4,#+100
   \   00000088   0xE164048C         SMULBB   R4,R12,R4
   \   0000008C   0xE1B0522E         LSRS     R5,LR,#+4
   \   00000090   0xE3A0600A         MOV      R6,#+10
   \   00000094   0xE1044685         SMLABB   R4,R5,R6,R4
   \   00000098   0xE1B0500E         MOVS     R5,LR
   \   0000009C   0xE215500F         ANDS     R5,R5,#0xF
   \   000000A0   0xE0954004         ADDS     R4,R5,R4
   \   000000A4   0xE1C140B0         STRH     R4,[R1, #+0]
    491          	}
    492          	/* Retrieve month */
    493          	if (pDate->month) {
   \                     ??rtc_get_tamper_date_2:
   \   000000A8   0xE5D14002         LDRB     R4,[R1, #+2]
   \   000000AC   0xE3540000         CMP      R4,#+0
   \   000000B0   0x0A000006         BEQ      ??rtc_get_tamper_date_3
    494          		temp = (date & RTC_TSDR_MONTH_Msk) >> RTC_TSDR_MONTH_Pos;
   \   000000B4   0xE7E44853         UBFX     R4,R3,#+16,#+5
   \   000000B8   0xE1B0E004         MOVS     LR,R4
    495          		pDate->month = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
   \   000000BC   0xE1B0422E         LSRS     R4,LR,#+4
   \   000000C0   0xE3A0500A         MOV      R5,#+10
   \   000000C4   0xE21E600F         ANDS     R6,LR,#0xF
   \   000000C8   0xE0246495         MLA      R4,R5,R4,R6
   \   000000CC   0xE5C14002         STRB     R4,[R1, #+2]
    496          	}
    497          	/* Retrieve day */
    498          	if (pDate->day) {
   \                     ??rtc_get_tamper_date_3:
   \   000000D0   0xE5D14003         LDRB     R4,[R1, #+3]
   \   000000D4   0xE3540000         CMP      R4,#+0
   \   000000D8   0x0A000006         BEQ      ??rtc_get_tamper_date_4
    499          		temp = (date & RTC_TSDR_DATE_Msk) >> RTC_TSDR_DATE_Pos;
   \   000000DC   0xE7E54C53         UBFX     R4,R3,#+24,#+6
   \   000000E0   0xE1B0E004         MOVS     LR,R4
    500          		pDate->day = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
   \   000000E4   0xE1B0422E         LSRS     R4,LR,#+4
   \   000000E8   0xE3A0500A         MOV      R5,#+10
   \   000000EC   0xE21E600F         ANDS     R6,LR,#0xF
   \   000000F0   0xE0246495         MLA      R4,R5,R4,R6
   \   000000F4   0xE5C14003         STRB     R4,[R1, #+3]
    501          	}
    502          	/* Retrieve week */
    503          	if (pDate->week) {
   \                     ??rtc_get_tamper_date_4:
   \   000000F8   0xE5D14004         LDRB     R4,[R1, #+4]
   \   000000FC   0xE3540000         CMP      R4,#+0
   \   00000100   0x0A000002         BEQ      ??rtc_get_tamper_date_5
    504          		pDate->week= ((date & RTC_TSDR_DAY_Msk) >> RTC_TSDR_DAY_Pos);
   \   00000104   0xE1B04AA3         LSRS     R4,R3,#+21
   \   00000108   0xE2144007         ANDS     R4,R4,#0x7
   \   0000010C   0xE5C14004         STRB     R4,[R1, #+4]
    505          	}
    506          }
   \                     ??rtc_get_tamper_date_5:
   \   00000110   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    507          
    508          /**
    509           * \brief Get the RTC tamper source.
    510           *
    511           * \param pRtc      Pointer to an RTC instance.
    512           * \param ucRegNum  Current tamper register set number.
    513           *
    514           * \return Tamper source.
    515           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    516          extern uint32_t rtc_get_tamper_source(Rtc * pRtc, uint8_t reg_num)
    517          {
    518          	return pRtc->RTC_TS[reg_num].RTC_TSSR;
   \                     rtc_get_tamper_source:
   \   00000000   0xE6EF1071         UXTB     R1,R1
   \   00000004   0xE0812081         ADD      R2,R1,R1, LSL #+1
   \   00000008   0xE0900102         ADDS     R0,R0,R2, LSL #+2
   \   0000000C   0xE59000B8         LDR      R0,[R0, #+184]
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    519          }
    520          
    521          /**
    522           * \brief Get the RTC tamper event counter.
    523           *
    524           * \note This function should be called before rtc_get_tamper_source()
    525           *       function call, Otherwise the tamper event counter will be cleared.
    526           *
    527           * \param pRtc Pointer to an RTC instance.
    528           *
    529           * \return Tamper event counter
    530           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    531          extern uint32_t rtc_get_tamper_event_counter(Rtc * pRtc)
    532          {
    533          	return (pRtc->RTC_TS[0].RTC_TSTR & RTC_TSTR_TEVCNT_Msk) >> RTC_TSTR_TEVCNT_Pos;
   \                     rtc_get_tamper_event_counter:
   \   00000000   0xE59000B0         LDR      R0,[R0, #+176]
   \   00000004   0xE7E30C50         UBFX     R0,R0,#+24,#+4
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    534          }
    535          
    536          /**
    537           * \brief Check the system is in backup mode when RTC tamper event happen.
    538           *
    539           * \note This function should be called before rtc_get_tamper_source()
    540           *       function call, Otherwise the flag indicates tamper occur in backup
    541           *       mode will be cleared.
    542           *
    543           * \param pRtc      Pointer to an RTC instance.
    544           * \param ucRegNum  Current tamper register set number.
    545           *
    546           * \return 1 - The system is in backup mode when the tamper event occurs.
    547           *         0 - The system is different from backup mode.
    548           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    549          extern uint8_t rtc_is_tamper_occur_in_backup_mode(Rtc * pRtc, uint8_t reg_num)
    550          {
   \                     rtc_is_tamper_occur_in_backup_mode:
   \   00000000   0xE1B02000         MOVS     R2,R0
    551          	if (pRtc->RTC_TS[reg_num].RTC_TSTR & RTC_TSTR_BACKUP) {
   \   00000004   0xE1B00001         MOVS     R0,R1
   \   00000008   0xE6EF0070         UXTB     R0,R0
   \   0000000C   0xE0803080         ADD      R3,R0,R0, LSL #+1
   \   00000010   0xE0920103         ADDS     R0,R2,R3, LSL #+2
   \   00000014   0xE59000B0         LDR      R0,[R0, #+176]
   \   00000018   0xE3100480         TST      R0,#0x80000000
   \   0000001C   0x0A000001         BEQ      ??rtc_is_tamper_occur_in_backup_mode_0
    552          		return 1;
   \   00000020   0xE3A00001         MOV      R0,#+1
   \   00000024   0xEA000000         B        ??rtc_is_tamper_occur_in_backup_mode_1
    553          	} else {
    554          		return 0;
   \                     ??rtc_is_tamper_occur_in_backup_mode_0:
   \   00000028   0xE3A00000         MOV      R0,#+0
   \                     ??rtc_is_tamper_occur_in_backup_mode_1:
   \   0000002C   0xE12FFF1E         BX       LR               ;; return
    555          	}
    556          }
    557          
    558          /**
    559           * \brief Convert number of second (count) to HMS format.
    560           *
    561           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    562          void rtc_convert_time_to_hms (struct _time *pTime, uint32_t count)
    563          {
   \                     rtc_convert_time_to_hms:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    564            uint32_t temps = count;
   \   0000000C   0xE1B06005         MOVS     R6,R5
    565            pTime->hour = pTime->min = pTime->sec= 0;
   \   00000010   0xE3A00000         MOV      R0,#+0
   \   00000014   0xE5C40002         STRB     R0,[R4, #+2]
   \   00000018   0xE5C40001         STRB     R0,[R4, #+1]
   \   0000001C   0xE5C40000         STRB     R0,[R4, #+0]
    566            temps = temps%86400;
   \   00000020   0xE1B00006         MOVS     R0,R6
   \   00000024   0xE3A01B50         MOV      R1,#+81920
   \   00000028   0xE3811D46         ORR      R1,R1,#0x1180
   \   0000002C   0x........         BL       __aeabi_uidivmod
   \   00000030   0xE1B06001         MOVS     R6,R1
    567            pTime->hour = temps/3600 ;
   \   00000034   0xE1B00006         MOVS     R0,R6
   \   00000038   0xE3A01EE1         MOV      R1,#+3600
   \   0000003C   0x........         BL       __aeabi_uidiv
   \   00000040   0xE5C40000         STRB     R0,[R4, #+0]
    568            temps -= pTime->hour*3600 ;
   \   00000044   0xE5D40000         LDRB     R0,[R4, #+0]
   \   00000048   0xE3A01EE1         MOV      R1,#+3600
   \   0000004C   0xE0100091         MULS     R0,R1,R0
   \   00000050   0xE0566000         SUBS     R6,R6,R0
    569            pTime->min = temps/60;
   \   00000054   0xE1B00006         MOVS     R0,R6
   \   00000058   0xE3A0103C         MOV      R1,#+60
   \   0000005C   0x........         BL       __aeabi_uidiv
   \   00000060   0xE5C40001         STRB     R0,[R4, #+1]
    570            pTime->sec = temps%60;
   \   00000064   0xE1B00006         MOVS     R0,R6
   \   00000068   0xE3A0103C         MOV      R1,#+60
   \   0000006C   0x........         BL       __aeabi_uidivmod
   \   00000070   0xE5C41002         STRB     R1,[R4, #+2]
    571          }
   \   00000074   0xE8BD8070         POP      {R4-R6,PC}       ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x28 0x6D          DC8 "(mode & 0xFFFFFFFE) == 0"
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x26 0x20    
   \              0x30 0x78    
   \              0x46 0x46    
   \              0x46 0x46    
   \              0x46 0x46    
   \              0x46 0x45    
   \              0x29 0x20    
   \              0x3D 0x3D    
   \              0x20 0x30    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 74H, 69H, 6DH, 65H
   \              0x73 0x5C    
   \              0x74 0x69    
   \              0x6D 0x65    
   \   00000038   0x5C 0x72          DC8 5CH, 72H, 74H, 63H, 2EH, 63H, 0
   \              0x74 0x63    
   \              0x2E 0x63    
   \              0x00         
   \   0000003F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x28 0x73          DC8 "(sources & (uint32_t) (~0x1F)) == 0"
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x73    
   \              0x20 0x26    
   \              0x20 0x28    
   \              0x75 0x69    
   \              0x6E 0x74    
   \              0x33 0x32    
   \              0x5F 0x74    
   \              0x29 0x20    
   \              0x28 0x7E    
   \              0x30 0x78    
   \              0x31 0x46    
   \              0x29 0x29    
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x30 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   rtc_clear_sccr
      16   rtc_convert_time_to_hms
        16 __aeabi_uidiv
        16 __aeabi_uidivmod
      16   rtc_disable_it
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   rtc_enable_it
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       4   rtc_get_date
       0   rtc_get_hour_mode
       0   rtc_get_sr
      16   rtc_get_tamper_date
       0   rtc_get_tamper_event_counter
       0   rtc_get_tamper_source
      12   rtc_get_tamper_time
       4   rtc_get_time
       0   rtc_is_tamper_occur_in_backup_mode
      40   rtc_set_date
        40 __aeabi_idiv
        40 __aeabi_idivmod
      20   rtc_set_date_alarm
        20 __aeabi_idiv
        20 __aeabi_idivmod
      16   rtc_set_hour_mode
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      32   rtc_set_time
        32 __aeabi_idiv
        32 __aeabi_idivmod
      20   rtc_set_time_alarm
        20 __aeabi_idiv
        20 __aeabi_idivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
      28  ?_0
      64  ?_1
      36  ?_2
      56  _id_h64_matrix
      12  rtc_clear_sccr
     120  rtc_convert_time_to_hms
      52  rtc_disable_it
      52  rtc_enable_it
     180  rtc_get_date
      20  rtc_get_hour_mode
      12  rtc_get_sr
     276  rtc_get_tamper_date
      12  rtc_get_tamper_event_counter
      20  rtc_get_tamper_source
     228  rtc_get_tamper_time
     156  rtc_get_time
      48  rtc_is_tamper_occur_in_backup_mode
     436  rtc_set_date
     180  rtc_set_date_alarm
      52  rtc_set_hour_mode
     332  rtc_set_time
     196  rtc_set_time_alarm

 
   184 bytes in section .rodata
 2 396 bytes in section SOFTPACK
 
 2 396 bytes of CODE  memory
   184 bytes of CONST memory

Errors: none
Warnings: 4
