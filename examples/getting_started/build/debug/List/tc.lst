###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        21/May/2015  13:39:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\time\tc.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\time\tc.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D27
#        -D sram --preprocess=l
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -lC
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started/../../target/sama5d2\
#        --section .text=SOFTPACK --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\List\tc.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\getting_started\build\debug\Obj\tc.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\time\tc.c
      1          /* ----------------------------------------------------------------------------
                                                                                               ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup tc_module
     31           * \section Purpose
     32           * The TC driver provides the Interface to configure the Timer Counter (TC).
     33           *
     34           * \section Usage
     35           * <ul>
     36           *  <li> Optionally, use TC_FindMckDivisor() to let the program find the best
     37           *     TCCLKS field value automatically.</li>
     38           *  <li> Configure a Timer Counter in the desired mode using TC_Configure().</li>
     39           *  <li> Start or stop the timer clock using TC_Start() and TC_Stop().</li>
     40           *  </li>
     41           * </ul>
     42           * For more accurate information, please look at the TC section of the Datasheet.
     43           *
     44           * Related files :\n
     45           * \ref tc.c\n
     46           * \ref tc.h.\n
     47          */
     48          
     49          /**
     50          *  \file
     51          *
     52          *  \section Purpose
     53          *
     54          *  Interface for configuring and using Timer Counter (TC) peripherals.
     55          *
     56          *  \section Usage
     57          *  -# Optionally, use TC_FindMckDivisor() to let the program find the best
     58          *     TCCLKS field value automatically.
     59          *  -# Configure a Timer Counter in the desired mode using TC_Configure().
     60          *  -# Start or stop the timer clock using TC_Start() and TC_Stop().
     61          */
     62          
     63          /**
     64           * \file
     65           *
     66           * Implementation of Timer Counter (TC).
     67           *
     68           */
     69          
     70          /*------------------------------------------------------------------------------
     71           *         Headers
     72           *------------------------------------------------------------------------------*/
     73          
     74          #include "chip.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned int const _id_h64_matrix[14]
   \                     _id_h64_matrix:
   \   00000000   0x00000006         DC32 6, 7, 9, 10, 12, 13, 15, 31, 32, 45, 46, 52, 53, 63
   \              0x00000007   
   \              0x00000009   
   \              0x0000000A   
   \              0x0000000C   
   \              0x0000000D   
   \              0x0000000F   
   \              0x0000001F   
   \              0x00000020   
   \              0x0000002D   
   \              0x0000002E   
   \              0x00000034   
   \              0x00000035   
   \              0x0000003F   
     75          #include "time/tc.h"
     76          #include "core/pmc.h"
     77          
     78          #include <assert.h>
     79          
     80          /*------------------------------------------------------------------------------
     81           *         Global functions
     82           *------------------------------------------------------------------------------*/
     83          
     84          /**
     85           * \brief Configures a Timer Counter Channel
     86           *
     87           * Configures a Timer Counter to operate in the given mode. Timer is stopped
     88           * after configuration and must be restarted with TC_Start(). All the
     89           * interrupts of the timer are also disabled.
     90           *
     91           * \param pTc  Pointer to a Tc instance.
     92           * \param channel Channel number.
     93           * \param mode  Operating mode (TC_CMR value).
     94           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     95          void tc_configure(Tc * pTc, uint32_t channel, uint32_t mode)
     96          {
   \                     tc_configure:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
     97          	volatile TcChannel *pTcCh;
     98          
     99          	assert(channel <
    100          	       (sizeof (pTc->TC_CHANNEL) / sizeof (pTc->TC_CHANNEL[0])));
   \   00000010   0xE3550003         CMP      R5,#+3
   \   00000014   0x3A000004         BCC      ??tc_configure_0
   \   00000018   0xE3A02064         MOV      R2,#+100
   \   0000001C   0x........         LDR      R1,??DataTable3
   \   00000020   0x........         LDR      R0,??DataTable3_1
   \   00000024   0x........         BL       __aeabi_assert
   \   00000028   0x........         BL       __iar_EmptyStepPoint
    101          	pTcCh = pTc->TC_CHANNEL + channel;
   \                     ??tc_configure_0:
   \   0000002C   0xE1B00305         LSLS     R0,R5,#+6
   \   00000030   0xE0900004         ADDS     R0,R0,R4
   \   00000034   0xE1B07000         MOVS     R7,R0
    102          
    103          	/*  Disable TC clock */
    104          	pTcCh->TC_CCR = TC_CCR_CLKDIS;
   \   00000038   0xE3A00002         MOV      R0,#+2
   \   0000003C   0xE5870000         STR      R0,[R7, #+0]
    105          
    106          	/*  Disable interrupts */
    107          	pTcCh->TC_IDR = 0xFFFFFFFF;
   \   00000040   0xE3E00000         MVN      R0,#+0
   \   00000044   0xE5870028         STR      R0,[R7, #+40]
    108          
    109          	/*  Clear status register */
    110          	pTcCh->TC_SR;
   \   00000048   0xE5970020         LDR      R0,[R7, #+32]
    111          
    112          	/*  Set mode */
    113          	pTcCh->TC_CMR = mode;
   \   0000004C   0xE5876004         STR      R6,[R7, #+4]
    114          }
   \   00000050   0xE8BD80F1         POP      {R0,R4-R7,PC}    ;; return
    115          
    116          /**
    117           * \brief Reset and Start the TC Channel
    118           *
    119           * Enables the timer clock and performs a software reset to start the counting.
    120           *
    121           * \param pTc  Pointer to a Tc instance.
    122           * \param channel Channel number.
    123           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    124          void tc_start(Tc * pTc, uint32_t channel)
    125          {
   \                     tc_start:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    126          	volatile TcChannel *pTcCh;
    127          
    128          	assert(channel <
    129          	       (sizeof (pTc->TC_CHANNEL) / sizeof (pTc->TC_CHANNEL[0])));
   \   0000000C   0xE3550003         CMP      R5,#+3
   \   00000010   0x3A000004         BCC      ??tc_start_0
   \   00000014   0xE3A02081         MOV      R2,#+129
   \   00000018   0x........         LDR      R1,??DataTable3
   \   0000001C   0x........         LDR      R0,??DataTable3_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    130          
    131          	pTcCh = pTc->TC_CHANNEL + channel;
   \                     ??tc_start_0:
   \   00000028   0xE1B00305         LSLS     R0,R5,#+6
   \   0000002C   0xE0900004         ADDS     R0,R0,R4
   \   00000030   0xE1B06000         MOVS     R6,R0
    132          	pTcCh->TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
   \   00000034   0xE3A00005         MOV      R0,#+5
   \   00000038   0xE5860000         STR      R0,[R6, #+0]
    133          	pTcCh->TC_IER = TC_IER_COVFS;
   \   0000003C   0xE3A00001         MOV      R0,#+1
   \   00000040   0xE5860024         STR      R0,[R6, #+36]
    134          }
   \   00000044   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    135          
    136          /**
    137           * \brief Stop TC Channel
    138           *
    139           * Disables the timer clock, stopping the counting.
    140           *
    141           * \param pTc     Pointer to a Tc instance.
    142           * \param channel Channel number.
    143           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    144          void tc_stop(Tc * pTc, uint32_t channel)
    145          {
   \                     tc_stop:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    146          	volatile TcChannel *pTcCh;
    147          
    148          	assert(channel <
    149          	       (sizeof (pTc->TC_CHANNEL) / sizeof (pTc->TC_CHANNEL[0])));
   \   0000000C   0xE3550003         CMP      R5,#+3
   \   00000010   0x3A000004         BCC      ??tc_stop_0
   \   00000014   0xE3A02095         MOV      R2,#+149
   \   00000018   0x........         LDR      R1,??DataTable3
   \   0000001C   0x........         LDR      R0,??DataTable3_1
   \   00000020   0x........         BL       __aeabi_assert
   \   00000024   0x........         BL       __iar_EmptyStepPoint
    150          
    151          	pTcCh = pTc->TC_CHANNEL + channel;
   \                     ??tc_stop_0:
   \   00000028   0xE1B00305         LSLS     R0,R5,#+6
   \   0000002C   0xE0900004         ADDS     R0,R0,R4
   \   00000030   0xE1B06000         MOVS     R6,R0
    152          	pTcCh->TC_CCR = TC_CCR_CLKDIS;
   \   00000034   0xE3A00002         MOV      R0,#+2
   \   00000038   0xE5860000         STR      R0,[R6, #+0]
    153          	pTcCh->TC_IDR = TC_IER_COVFS;
   \   0000003C   0xE3A00001         MOV      R0,#+1
   \   00000040   0xE5860028         STR      R0,[R6, #+40]
    154          }
   \   00000044   0xE8BD8070         POP      {R4-R6,PC}       ;; return
    155          
    156          /**
    157           * \brief Find best MCK divisor
    158           *
    159           * Finds the best MCK divisor given the timer frequency and MCK. The result
    160           * is guaranteed to satisfy the following equation:
    161           * \code
    162           *   (MCK / (DIV * 65536)) <= freq <= (MCK / DIV)
    163           * \endcode
    164           * with DIV being the highest possible value.
    165           *
    166           * \param freq  Desired timer frequency.
    167           * \param dwMCk  Master clock frequency.
    168           * \param div  Divisor value.
    169           * \param tc_clks  TCCLKS field value for divisor.
    170           * \param board_mck  Board clock frequency.
    171           *
    172           * \return 1 if a proper divisor has been found, otherwise 0.
    173           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    174          extern uint32_t tc_find_mck_divisor (uint32_t freq, uint32_t * div,
    175          				  uint32_t * tc_clks)
    176          {
   \                     tc_find_mck_divisor:
   \   00000000   0xE92D43F0         PUSH     {R4-R9,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05001         MOVS     R5,R1
   \   00000010   0xE1B06002         MOVS     R6,R2
    177          	const uint32_t master_clock = pmc_get_master_clock();
   \   00000014   0x........         BL       pmc_get_master_clock
   \   00000018   0xE1B07000         MOVS     R7,R0
    178          	const uint32_t periph_clock = pmc_get_peripheral_max_clock(ID_TC0);
   \   0000001C   0xE3A00023         MOV      R0,#+35
   \   00000020   0x........         BL       pmc_get_peripheral_max_clock
   \   00000024   0xE1B08000         MOVS     R8,R0
    179          	const uint32_t adivisors[5] = { 2, 8, 32, 128, master_clock / 32768 };
   \   00000028   0xE1B0000D         MOVS     R0,SP
   \   0000002C   0x........         LDR      R1,??DataTable3_2
   \   00000030   0xE3A02014         MOV      R2,#+20
   \   00000034   0x........         BL       __aeabi_memcpy4
   \   00000038   0xE1B007A7         LSRS     R0,R7,#+15
   \   0000003C   0xE58D0010         STR      R0,[SP, #+16]
    180          
    181          	uint32_t dwIndex = 0;
   \   00000040   0xE3A09000         MOV      R9,#+0
    182          
    183          	/*  Satisfy lower bound */
    184          	while (freq < ((periph_clock / adivisors[dwIndex]) / 65536)) {
   \                     ??tc_find_mck_divisor_0:
   \   00000044   0xE1B00008         MOVS     R0,R8
   \   00000048   0xE1B0100D         MOVS     R1,SP
   \   0000004C   0xE1B02109         LSLS     R2,R9,#+2
   \   00000050   0xE7921001         LDR      R1,[R2, +R1]
   \   00000054   0x........         BL       __aeabi_uidiv
   \   00000058   0xE1540820         CMP      R4,R0, LSR #+16
   \   0000005C   0x2A000004         BCS      ??tc_find_mck_divisor_1
    185          		dwIndex++;
   \   00000060   0xE2999001         ADDS     R9,R9,#+1
    186          
    187          		/*  If no divisor can be found, return 0 */
    188          		if (dwIndex == (sizeof (adivisors) / sizeof (adivisors[0]))) {
   \   00000064   0xE3590005         CMP      R9,#+5
   \   00000068   0x1AFFFFF5         BNE      ??tc_find_mck_divisor_0
    189          			return 0;
   \   0000006C   0xE3A00000         MOV      R0,#+0
   \   00000070   0xEA000015         B        ??tc_find_mck_divisor_2
    190          		}
    191          	}
    192          
    193          	/*  Try to maximize DIV while satisfying upper bound */
    194          	while (dwIndex < 4) {
   \                     ??tc_find_mck_divisor_1:
   \   00000074   0xE3590004         CMP      R9,#+4
   \   00000078   0x2A000009         BCS      ??tc_find_mck_divisor_3
    195          
    196          		if (freq > (periph_clock / adivisors[dwIndex + 1])) {
   \   0000007C   0xE1B00008         MOVS     R0,R8
   \   00000080   0xE1B0100D         MOVS     R1,SP
   \   00000084   0xE1B02109         LSLS     R2,R9,#+2
   \   00000088   0xE0921001         ADDS     R1,R2,R1
   \   0000008C   0xE5911004         LDR      R1,[R1, #+4]
   \   00000090   0x........         BL       __aeabi_uidiv
   \   00000094   0xE1500004         CMP      R0,R4
   \   00000098   0x3A000001         BCC      ??tc_find_mck_divisor_3
    197          			break;
    198          		}
    199          		dwIndex++;
   \                     ??tc_find_mck_divisor_4:
   \   0000009C   0xE2999001         ADDS     R9,R9,#+1
   \   000000A0   0xEAFFFFF3         B        ??tc_find_mck_divisor_1
    200          	}
    201          
    202          	/*  Store results */
    203          	if (div) {
   \                     ??tc_find_mck_divisor_3:
   \   000000A4   0xE3550000         CMP      R5,#+0
   \   000000A8   0x0A000003         BEQ      ??tc_find_mck_divisor_5
    204          		*div = adivisors[dwIndex];
   \   000000AC   0xE1B0000D         MOVS     R0,SP
   \   000000B0   0xE1B01109         LSLS     R1,R9,#+2
   \   000000B4   0xE7910000         LDR      R0,[R1, +R0]
   \   000000B8   0xE5850000         STR      R0,[R5, #+0]
    205          	}
    206          	if (tc_clks) {
   \                     ??tc_find_mck_divisor_5:
   \   000000BC   0xE3560000         CMP      R6,#+0
   \   000000C0   0x0A000000         BEQ      ??tc_find_mck_divisor_6
    207          		*tc_clks = dwIndex;
   \   000000C4   0xE5869000         STR      R9,[R6, #+0]
    208          	}
    209          
    210          	return 1;
   \                     ??tc_find_mck_divisor_6:
   \   000000C8   0xE3A00001         MOV      R0,#+1
   \                     ??tc_find_mck_divisor_2:
   \   000000CC   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000D0   0xE8BD83F0         POP      {R4-R9,PC}       ;; return
    211          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x00000002         DC32 2, 8, 32, 128, 0
   \              0x00000008   
   \              0x00000020   
   \              0x00000080   
   \              0x00000000   

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x63 0x68          DC8 63H, 68H, 61H, 6EH, 6EH, 65H, 6CH, 20H
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \   00000008   0x3C 0x20          DC8 3CH, 20H, 28H, 73H, 69H, 7AH, 65H, 6FH
   \              0x28 0x73    
   \              0x69 0x7A    
   \              0x65 0x6F    
   \   00000010   0x66 0x20          DC8 66H, 20H, 28H, 70H, 54H, 63H, 2DH, 3EH
   \              0x28 0x70    
   \              0x54 0x63    
   \              0x2D 0x3E    
   \   00000018   0x54 0x43          DC8 54H, 43H, 5FH, 43H, 48H, 41H, 4EH, 4EH
   \              0x5F 0x43    
   \              0x48 0x41    
   \              0x4E 0x4E    
   \   00000020   0x45 0x4C          DC8 45H, 4CH, 29H, 20H, 2FH, 20H, 73H, 69H
   \              0x29 0x20    
   \              0x2F 0x20    
   \              0x73 0x69    
   \   00000028   0x7A 0x65          DC8 7AH, 65H, 6FH, 66H, 20H, 28H, 70H, 54H
   \              0x6F 0x66    
   \              0x20 0x28    
   \              0x70 0x54    
   \   00000030   0x63 0x2D          DC8 63H, 2DH, 3EH, 54H, 43H, 5FH, 43H, 48H
   \              0x3E 0x54    
   \              0x43 0x5F    
   \              0x43 0x48    
   \   00000038   0x41 0x4E          DC8 41H, 4EH, 4EH, 45H, 4CH, 5BH, 30H, 5DH
   \              0x4E 0x45    
   \              0x4C 0x5B    
   \              0x30 0x5D    
   \   00000040   0x29 0x29          DC8 29H, 29H, 0
   \              0x00         
   \   00000043   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x64          DC8 5CH, 64H, 66H, 72H, 6FH, 6EH, 65H, 6BH
   \              0x66 0x72    
   \              0x6F 0x6E    
   \              0x65 0x6B    
   \   00000010   0x5C 0x44          DC8 5CH, 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH
   \              0x6F 0x63    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \   00000018   0x74 0x73          DC8 74H, 73H, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \              0x5C 0x50    
   \              0x72 0x6F    
   \              0x6A 0x65    
   \   00000020   0x63 0x74          DC8 63H, 74H, 5CH, 73H, 6FH, 66H, 74H, 70H
   \              0x5C 0x73    
   \              0x6F 0x66    
   \              0x74 0x70    
   \   00000028   0x61 0x63          DC8 61H, 63H, 6BH, 5CH, 64H, 72H, 69H, 76H
   \              0x6B 0x5C    
   \              0x64 0x72    
   \              0x69 0x76    
   \   00000030   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 74H, 69H, 6DH, 65H
   \              0x73 0x5C    
   \              0x74 0x69    
   \              0x6D 0x65    
   \   00000038   0x5C 0x74          DC8 5CH, 74H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   tc_configure
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      48   tc_find_mck_divisor
        48   -> __aeabi_memcpy4
        48   -> pmc_get_master_clock
        48   -> pmc_get_peripheral_max_clock
        48 __aeabi_uidiv
      16   tc_start
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   tc_stop
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
      68  ?_0
      64  ?_1
      20  ?_2
      56  _id_h64_matrix
      84  tc_configure
     212  tc_find_mck_divisor
      72  tc_start
      72  tc_stop

 
 208 bytes in section .rodata
 452 bytes in section SOFTPACK
 
 452 bytes of CODE  memory
 208 bytes of CONST memory

Errors: none
Warnings: 1
