###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        30/Apr/2015  16:45:29
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\time\rtc.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\time\rtc.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D21
#        -lcN
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw\Debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../target/sama5d2\
#        --interwork --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw\Debug\List\rtc.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw\Debug\Obj\rtc.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\time\rtc.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup rtc_module Working with RTC
     31           * \section Purpose
     32           * The RTC driver provides the interface to configure and use the RTC
     33           * peripheral.
     34           *
     35           * It manages date, time, and alarms.\n
     36           * This timer is clocked by the 32kHz system clock, and is not impacted by
     37           * power management settings (PMC). To be accurate, it is better to use an
     38           * external 32kHz crystal instead of the internal 32kHz RC.\n
     39           *
     40           * It uses BCD format, and time can be set in AM/PM or 24h mode through a
     41           * configuration bit in the mode register.\n
     42           *
     43           * To update date or time, the user has to follow these few steps :
     44           * <ul>
     45           * <li>Set UPDTIM and/or UPDCAL bit(s) in RTC_CR,</li>
     46           * <li>Polling or IRQ on the ACKUPD bit of RTC_CR,</li>
     47           * <li>Clear ACKUPD bit in RTC_SCCR,</li>
     48           * <li>Update Time and/or Calendar values in RTC_TIMR/RTC_CALR (BCD format),</li>
     49           * <li>Clear UPDTIM and/or UPDCAL bit in RTC_CR.</li>
     50           * </ul>
     51           * An alarm can be set to happen on month, date, hours, minutes or seconds,
     52           * by setting the proper "Enable" bit of each of these fields in the Time and
     53           * Calendar registers.
     54           * This allows a large number of configurations to be available for the user.
     55           * Alarm occurence can be detected even by polling or interrupt.
     56           *
     57           * A check of the validity of the date and time format and values written by the user is automatically done.
     58           * Errors are reported through the Valid Entry Register.
     59           *
     60           * \section Usage
     61           * <ul>
     62           * <li>  Enable & disable RTC interrupt using RTC_EnableIt() and RTC_DisableIt().
     63           * <li>  Set RTC data, time, alarm using rtc_set_date(), RTC_SetTime(),
     64           * rtc_set_time_alarm() and rtc_set_date_alarm().
     65           * <li>  Get RTC data, time using rtc_get_date() and rtc_get_time().
     66           * </li>
     67           * </ul>
     68           *
     69           * For more accurate information, please look at the RTC section of the
     70           * Datasheet.
     71           *
     72           * Related files :\n
     73           * \ref rtc.c\n
     74           * \ref rtc.h.\n
     75          */
     76          /*@{*/
     77          /*@}*/
     78          
     79          /**
     80           * \file
     81           *
     82           * Implementation of Real Time Clock (RTC) controller.
     83           *
     84           */
     85          
     86          /*----------------------------------------------------------------------------
     87           *        Headers
     88           *----------------------------------------------------------------------------*/
     89          
     90          //#include "chip.h"
     91          #include "time/rtc.h"
     92          
     93          #include "utils/trace.h"
     94          
     95          #include <stdint.h>
     96          #include <assert.h>
     97          
     98          /* The BCD code shift value */
     99          #define BCD_SHIFT      4
    100          
    101          /* The BCD code mask value */
    102          #define BCD_MASK       0xfu
    103          
    104          /* The BCD mul/div factor value */
    105          #define BCD_FACTOR     10
    106          
    107          /*----------------------------------------------------------------------------
    108           *        Variables
    109           *----------------------------------------------------------------------------*/
    110          
    111          static uint8_t _flag_alarm;
    112          static uint8_t _flag_hms;
    113          static uint8_t _flag_minute_change;
    114          
    115          /*----------------------------------------------------------------------------
    116           *        Exported functions
    117           *----------------------------------------------------------------------------*/
    118          
    119          /**
    120           * \brief Sets the RTC in either 12 or 24 hour mode.
    121           *
    122           * \param pRtc  Pointer to a Rtc instance
    123           * \param dwMode  Hour mode.
    124           */
    125          extern void rtc_set_hour_mode(Rtc * pRtc, uint32_t mode)
    126          {
    127          	assert((mode & 0xFFFFFFFE) == 0);
    128          	pRtc->RTC_MR = mode;
    129          }
    130          
    131          /**
    132           * \brief Gets the RTC mode.
    133           *
    134           * \param pRtc  Pointer to a Rtc instance
    135           * \return Hour mode.
    136           */
    137          extern uint32_t rtc_get_hour_mode(Rtc * pRtc)
    138          {
    139          	uint32_t mode;
    140          	TRACE_DEBUG("rtc_get_hour_mode()\n\r");
    141          	mode = pRtc->RTC_MR;
    142          	mode &= 0xFFFFFFFE;
    143          	return mode;
    144          }
    145          
    146          /**
    147           * \brief Enables the selected interrupt sources of the RTC.
    148           *
    149           * \param pRtc  Pointer to a Rtc instance
    150           * \param dwSources  Interrupt sources to enable.
    151           */
    152          extern void rtc_enable_it(Rtc * pRtc, uint32_t sources)
    153          {
    154          	assert((sources & (uint32_t) (~0x1F)) == 0);
    155          	TRACE_DEBUG("rtc_enable_it()\n\r");
    156          	pRtc->RTC_IER = sources;
    157          }
    158          
    159          /**
    160          * \brief Disables the selected interrupt sources of the RTC.
    161          *
    162           * \param pRtc  Pointer to a Rtc instance
    163          * \param dwSources  Interrupt sources to disable.
    164          */
    165          extern void rtc_disable_it(Rtc * pRtc, uint32_t sources)
    166          {
    167          	assert((sources & (uint32_t) (~0x1F)) == 0);
    168          	TRACE_DEBUG("rtc_disable_it()\n\r");
    169          	pRtc->RTC_IDR = sources;
    170          }
    171          
    172          /**
    173           * \brief Sets the current time in the RTC.
    174           *
    175           * \note In successive update operations, the user must wait at least one second
    176           * after resetting the UPDTIM/UPDCAL bit in the RTC_CR before setting these
    177           * bits again. Please look at the RTC section of the datasheet for detail.
    178           *
    179           * \param pRtc  Pointer to a Rtc instance
    180           * \param pTime Pointer to structure time
    181           *
    182           * \return 0 sucess, 1 fail to set
    183           */
    184          extern int rtc_set_time(Rtc * pRtc, struct _time *pTime)
    185          {
    186          	uint32_t ltime = 0;
    187          	uint8_t hour_bcd , min_bcd, sec_bcd;
    188          
    189          	TRACE_DEBUG("rtc_set_time(%02d:%02d:%02d)\n\r", pTime->hour, pTime->min, pTime->sec);
    190          
    191          	/* if 12-hour mode, set AMPM bit */
    192          	if ((pRtc->RTC_MR & RTC_MR_HRMOD) == RTC_MR_HRMOD) {
    193          		if (pTime->hour > 12) {
    194          			pTime->hour -= 12;
    195          			ltime |= RTC_TIMR_AMPM;
    196          		}
    197          	}
    198          	hour_bcd = (pTime->hour % 10) | ((pTime->hour / 10) << 4);
    199          	min_bcd = (pTime->min % 10) | ((pTime->min / 10) << 4);
    200          	sec_bcd = (pTime->sec % 10) | ((pTime->sec / 10) << 4);
    201          	/* value overflow */
    202          	if ((hour_bcd & (uint8_t) (~RTC_HOUR_BIT_LEN_MASK)) |
    203          	    (min_bcd & (uint8_t) (~RTC_MIN_BIT_LEN_MASK)) |
    204          	    (sec_bcd & (uint8_t) (~RTC_SEC_BIT_LEN_MASK))) {
    205          		return 1;
    206          	}
    207          	ltime = sec_bcd | (min_bcd << 8) | (hour_bcd << 16);
    208          	pRtc->RTC_CR |= RTC_CR_UPDTIM;
    209          	while ((pRtc->RTC_SR & RTC_SR_ACKUPD) != RTC_SR_ACKUPD) ;
    210          	pRtc->RTC_SCCR = RTC_SCCR_ACKCLR;
    211          	pRtc->RTC_TIMR = ltime;
    212          	pRtc->RTC_CR &= (uint32_t) (~RTC_CR_UPDTIM);
    213          	pRtc->RTC_SCCR |= RTC_SCCR_SECCLR;
    214          	return (int) (pRtc->RTC_VER & RTC_VER_NVTIM);
    215          }
    216          
    217          /**
    218           * \brief Retrieves the current time as stored in the RTC in several variables.
    219           *
    220           * \param pRtc  Pointer to a Rtc instance
    221           * \param pTime Pointer to structure time
    222           */
    223          extern void rtc_get_time(Rtc * pRtc, struct _time *pTime)
    224          {
    225          	uint32_t ltime;
    226          
    227          	TRACE_DEBUG("rtc_get_time()\n\r");
    228          	/* Get current RTC time */
    229          	ltime = pRtc->RTC_TIMR;
    230          	while (ltime != pRtc->RTC_TIMR) {
    231          		ltime = pRtc->RTC_TIMR;
    232          	}
    233          	/* Hour */
    234          	if (pTime->hour) {
    235          		pTime->hour = ((ltime & 0x00300000) >> 20) * 10 + ((ltime & 0x000F0000) >> 16);
    236          		if ((ltime & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
    237          			pTime->hour += 12;
    238          		}
    239          	}
    240          	/* Minute */
    241          	if (pTime->min) {
    242          		pTime->min = ((ltime & 0x00007000) >> 12) * 10 + ((ltime & 0x00000F00) >> 8);
    243          	}
    244          	/* Second */
    245          	if (pTime->sec) {
    246          		pTime->sec = ((ltime & 0x00000070) >> 4) * 10 + (ltime & 0x0000000F);
    247          	}
    248          }
    249          
    250          /**
    251           * \brief Sets a time alarm on the RTC.
    252           * The match is performed only on the provided variables;
    253           * Setting all pointers to 0 disables the time alarm.
    254           *
    255           * \note In AM/PM mode, the hour value must have bit #7 set for PM, cleared for
    256           * AM (as expected in the time registers).
    257           *
    258           * \param pRtc  Pointer to a Rtc instance
    259           * \param pTime Pointer to structure time.
    260           *
    261           * \return 0 success, 1 fail to set
    262           */
    263          extern int rtc_set_time_alarm(Rtc * pRtc, struct _time *pTime)
    264          {
    265          	uint32_t alarm = 0;
    266          
    267          	TRACE_DEBUG("rtc_set_time_alarm()\n\r");
    268          
    269          	/* Hour */
    270          	if (pTime->hour) {
    271          		alarm |= RTC_TIMALR_HOUREN | ((pTime->hour / 10) << 20) | ((pTime->hour % 10) << 16);
    272          	}
    273          	/* Minute */
    274          	if (pTime->min) {
    275          		alarm |= RTC_TIMALR_MINEN | ((pTime->min / 10) << 12) | ((pTime->min % 10) << 8);
    276          	}
    277          	/* Second */
    278          	if (pTime->sec) {
    279          		alarm |= RTC_TIMALR_SECEN | ((pTime->sec / 10) << 4) | (pTime->sec % 10);
    280          	}
    281          	pRtc->RTC_TIMALR = alarm;
    282          	return (int) (pRtc->RTC_VER & RTC_VER_NVTIMALR);
    283          }
    284          
    285          /**
    286           * \brief Retrieves the current year, month and day from the RTC.
    287           * Month, day and week values are numbered starting at 1.
    288           *
    289           * \param pRtc  Pointer to a Rtc instance
    290           * \param pDate	Pointer to structure Date.
    291           */
    292          extern void rtc_get_date(Rtc * pRtc, struct _date *pDate)
    293          {
    294          	uint32_t date;
    295          
    296          	/* Get current date (multiple reads are necessary to insure a stable value) */
    297          	do {
    298          		date = pRtc->RTC_CALR;
    299          	} while (date != pRtc->RTC_CALR);
    300          	/* Retrieve year */
    301          	if (pDate->year) {
    302          		pDate->year = (((date >> 4) & 0x7) * 1000) + ((date & 0xF) * 100)
    303          			+ (((date >> 12) & 0xF) * 10) + ((date >> 8) & 0xF);
    304          	}
    305          	/* Retrieve month */
    306          	if (pDate->month) {
    307          		pDate->month = (((date >> 20) & 1) * 10) + ((date >> 16) & 0xF);
    308          	}
    309          	/* Retrieve day */
    310          	if (pDate->day) {
    311          		pDate->day = (((date >> 28) & 0x3) * 10) + ((date >> 24) & 0xF);
    312          	}
    313          	/* Retrieve week */
    314          	if (pDate->week) {
    315          		pDate->week = ((date >> 21) & 0x7);
    316          	}
    317          }
    318          
    319          /**
    320           * \brief Sets the current year, month and day in the RTC.
    321           * Month, day and week values must be numbered starting from 1.
    322           *
    323           * \note In successive update operations, the user must wait at least one second
    324           * after resetting the UPDTIM/UPDCAL bit in the RTC_CR before setting these
    325           * bits again. Please look at the RTC section of the datasheet for detail.
    326           *
    327           * \param pRtc  Pointer to a Rtc instance
    328           * \param pDate	Pointer to structure Date
    329           *
    330           * \return 0 success, 1 fail to set
    331           */
    332          extern int rtc_set_date(Rtc * pRtc, struct _date *pDate)
    333          {
    334          	uint32_t ldate;
    335          	uint8_t cent_bcd, year_bcd, month_bcd, day_bcd, week_bcd;
    336          
    337          	cent_bcd = ((pDate->year / 100) % 10) | ((pDate->year / 1000) << 4);
    338          	year_bcd = (pDate->year % 10) | (((pDate->year / 10) % 10) << 4);
    339          	month_bcd = ((pDate->month % 10) | (pDate->month / 10) << 4);
    340          	day_bcd = ((pDate->day % 10) | (pDate->day / 10) << 4);
    341          	week_bcd = ((pDate->week % 10) | (pDate->week / 10) << 4);
    342          	/* value over flow */
    343          	if ((cent_bcd & (uint8_t) (~RTC_CENT_BIT_LEN_MASK)) |
    344          	    (year_bcd & (uint8_t) (~RTC_YEAR_BIT_LEN_MASK)) |
    345          	    (month_bcd & (uint8_t) (~RTC_MONTH_BIT_LEN_MASK)) |
    346          	    (week_bcd & (uint8_t) (~RTC_WEEK_BIT_LEN_MASK)) |
    347          	    (day_bcd & (uint8_t) (~RTC_DATE_BIT_LEN_MASK))
    348          	    ) {
    349          		return 1;
    350          	}
    351          	/* Convert values to date register value */
    352          	ldate = cent_bcd | (year_bcd << 8) | (month_bcd << 16) | (week_bcd << 21) | (day_bcd << 24);
    353          	/* Update calendar register  */
    354          	pRtc->RTC_CR |= RTC_CR_UPDCAL;
    355          	while ((pRtc->RTC_SR & RTC_SR_ACKUPD) != RTC_SR_ACKUPD) ;
    356          	pRtc->RTC_SCCR = RTC_SCCR_ACKCLR;
    357          	pRtc->RTC_CALR = ldate;
    358          	pRtc->RTC_CR &= (uint32_t) (~RTC_CR_UPDCAL);
    359          	pRtc->RTC_SCCR |= RTC_SCCR_SECCLR;	/* clear SECENV in SCCR */
    360          	return (int) (pRtc->RTC_VER & RTC_VER_NVCAL);
    361          }
    362          
    363          /**
    364           * \brief Sets a date alarm in the RTC.
    365           * The alarm will match only the provided values;
    366           * Passing a null-pointer disables the corresponding field match.
    367           *
    368           * \param pRtc  Pointer to a Rtc instance
    369           * \param pucMonth If not null, the RTC alarm will month-match this value.
    370           * \param pucDay   If not null, the RTC alarm will day-match this value.
    371           *
    372           * \return 0 success, 1 fail to set
    373           */
    374          extern int rtc_set_date_alarm(Rtc * pRtc, struct _date *pDate)
    375          {
    376          	uint32_t alarm;
    377          
    378          	alarm = ((pDate->month) || (pDate->day)) ? (0) : (0x01010000);
    379          	TRACE_DEBUG("rtc_set_date_alarm()\n\r");
    380          	/* Compute alarm field value */
    381          	if (pDate->month) {
    382          		alarm |= RTC_CALALR_MTHEN | ((pDate->month / 10) << 20) | ((pDate->month % 10) << 16);
    383          	}
    384          	if (pDate->day) {
    385          		alarm |= RTC_CALALR_DATEEN | ((pDate->day / 10) << 28) | ((pDate->day % 10) << 24);
    386          	}
    387          	/* Set alarm */
    388          	pRtc->RTC_CALALR = alarm;
    389          	return (int) (pRtc->RTC_VER & RTC_VER_NVCALALR);
    390          }
    391          
    392          /**
    393           * \brief Clear flag bits of status clear command register in the RTC.
    394           *
    395           * \param pRtc  Pointer to a Rtc instance
    396           * \param dwMask Bits mask of cleared events
    397           */
    398          extern void rtc_clear_sccr(Rtc * pRtc, uint32_t mask)
    399          {
    400          	/* Clear all flag bits in status clear command register */
    401          	mask &= RTC_SCCR_ACKCLR | RTC_SCCR_ALRCLR | RTC_SCCR_SECCLR |
    402          		RTC_SCCR_TIMCLR | RTC_SCCR_CALCLR;
    403          	pRtc->RTC_SCCR = mask;
    404          }
    405          
    406          /**
    407           * \brief Get flag bits of status register in the RTC.
    408           *
    409           * \param pRtc  Pointer to a Rtc instance
    410           * \param dwMask Bits mask of Status Register
    411           *
    412           * \return Status register & mask
    413           */
    414          extern uint32_t rtc_get_sr(Rtc * pRtc, uint32_t mask)
    415          {
    416          	return ((pRtc->RTC_SR) & mask);
    417          }
    418          
    419          /**
    420           * \brief Get the RTC tamper time value.
    421           *
    422           * \note This function should be called before rtc_get_tamper_source()
    423           *       function call, Otherwise the tamper time will be cleared.
    424           *
    425           * \param pRtc       Pointer to an RTC instance.
    426           * \param pTime    	 Pointer to structure Time.
    427           * \param reg_num    Tamper register set number.
    428           */
    429          extern void rtc_get_tamper_time(Rtc * pRtc, struct _time *pTime,  uint8_t reg_num)
    430          {
    431          	uint32_t ltime, temp;
    432          
    433          	TRACE_DEBUG("rtc_get_tamper_time()\n\r");
    434          
    435          	/* Get current RTC time */
    436          	ltime = pRtc->RTC_TS[ucRegNum].RTC_TSTR;
    437          	while (ltime != pRtc->RTC_TS[reg_num].RTC_TSTR) {
    438          		ltime = pRtc->RTC_TS[reg_num].RTC_TSTR;
    439          	}
    440          	/* Hour */
    441          	if (pTime->hour) {
    442          		temp = (ltime & RTC_TSTR_HOUR_Msk) >> RTC_TSTR_HOUR_Pos;
    443          		pTime->hour = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
    444          		if ((ltime & RTC_TSTR_AMPM) == RTC_TSTR_AMPM) {
    445          			pTime->hour += 12;
    446          		}
    447          	}
    448          	/* Minute */
    449          	if (pTime->min) {
    450          		temp = (ltime & RTC_TSTR_MIN_Msk) >> RTC_TSTR_MIN_Pos;
    451          		pTime->min = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
    452          	}
    453          	/* Second */
    454          	if (pTime->sec) {
    455          		temp = (ltime & RTC_TSTR_SEC_Msk) >> RTC_TSTR_SEC_Pos;
    456          		pTime->sec = temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
    457          	}
    458          }
    459          
    460          /**
    461           * \brief Get the RTC tamper date.
    462           *
    463           * \note This function should be called before rtc_get_tamper_source()
    464           *       function call, Otherwise the tamper date will be cleared.
    465           *
    466           * \param pRtc      Pointer to an RTC instance.
    467           * \param pDate     Pointer to structure Date
    468           * \param reg_num   Tamper register set number.
    469           */
    470          extern void rtc_get_tamper_date(Rtc * pRtc, struct _date *pDate, uint8_t reg_num)
    471          {
    472          	uint32_t date, cent, temp;
    473          
    474          	/* Get the current date (multiple reads are to insure a stable value). */
    475          	date = pRtc->RTC_TS[reg_num].RTC_TSDR;
    476          	while (date != pRtc->RTC_TS[reg_num].RTC_TSDR) {
    477          		date = pRtc->RTC_TS[reg_num].RTC_TSDR;
    478          	}
    479          	/* Retrieve year */
    480          	if (pDate->year) {
    481          		temp = (date & RTC_TSDR_CENT_Msk) >> RTC_TSDR_CENT_Pos;
    482          		cent = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
    483          		temp = (date & RTC_TSDR_YEAR_Msk) >> RTC_TSDR_YEAR_Pos;
    484          		pDate->year = (cent * BCD_FACTOR * BCD_FACTOR) + (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
    485          	}
    486          	/* Retrieve month */
    487          	if (pDate->month) {
    488          		temp = (date & RTC_TSDR_MONTH_Msk) >> RTC_TSDR_MONTH_Pos;
    489          		pDate->month = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
    490          	}
    491          	/* Retrieve day */
    492          	if (pDate->day) {
    493          		temp = (date & RTC_TSDR_DATE_Msk) >> RTC_TSDR_DATE_Pos;
    494          		pDate->day = (temp >> BCD_SHIFT) * BCD_FACTOR + (temp & BCD_MASK);
    495          	}
    496          	/* Retrieve week */
    497          	if (pDate->week) {
    498          		pDate->week= ((date & RTC_TSDR_DAY_Msk) >> RTC_TSDR_DAY_Pos);
    499          	}
    500          }
    501          
    502          /**
    503           * \brief Get the RTC tamper source.
    504           *
    505           * \param pRtc      Pointer to an RTC instance.
    506           * \param ucRegNum  Current tamper register set number.
    507           *
    508           * \return Tamper source.
    509           */
    510          extern uint32_t rtc_get_tamper_source(Rtc * pRtc, uint8_t reg_num)
    511          {
    512          	return pRtc->RTC_TS[reg_num].RTC_TSSR;
    513          }
    514          
    515          /**
    516           * \brief Get the RTC tamper event counter.
    517           *
    518           * \note This function should be called before rtc_get_tamper_source()
    519           *       function call, Otherwise the tamper event counter will be cleared.
    520           *
    521           * \param pRtc Pointer to an RTC instance.
    522           *
    523           * \return Tamper event counter
    524           */
    525          extern uint32_t rtc_get_tamper_event_counter(Rtc * pRtc)
    526          {
    527          	return (pRtc->RTC_TS[0].RTC_TSTR & RTC_TSTR_TEVCNT_Msk) >>
    528          	    RTC_TSTR_TEVCNT_Pos;
    529          }
    530          
    531          /**
    532           * \brief Check the system is in backup mode when RTC tamper event happen.
    533           *
    534           * \note This function should be called before rtc_get_tamper_source()
    535           *       function call, Otherwise the flag indicates tamper occur in backup
    536           *       mode will be cleared.
    537           *
    538           * \param pRtc      Pointer to an RTC instance.
    539           * \param ucRegNum  Current tamper register set number.
    540           *
    541           * \return 1 - The system is in backup mode when the tamper event occurs.
    542           *         0 - The system is different from backup mode.
    543           */
    544          extern uint8_t rtc_is_tamper_occur_in_backup_mode(Rtc * pRtc, uint8_t reg_num)
    545          {
    546          	if (pRtc->RTC_TS[reg_num].RTC_TSTR & RTC_TSTR_BACKUP) {
    547          		return 1;
    548          	} else {
    549          		return 0;
    550          	}
    551          }
    552          
    553          /**
    554           * \brief Convert number of second (count) to HMS format.
    555           *
    556           */
    557          void rtc_convert_time_to_hms (struct _time *pTime, uint32_t count)
    558          {
    559            uint32_t temps = count;
    560            pTime->hour = pTime->min = pTime->sec= 0;
    561            temps = temps%86400;
    562            pTime->hour = temps/3600 ;
    563            temps -= pTime->hour*3600 ;
    564            pTime->min = temps/60;
    565            pTime->sec = temps%60;
    566          }

Errors: 22
Warnings: 4
