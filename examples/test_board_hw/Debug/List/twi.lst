###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        30/Apr/2015  08:34:18
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c
#    Command line =  
#        C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c -D
#        BOARD_SAMA5D2_XPLAINED -D API_PIOv4 -D SERIE_SAMA5D2 -D CHIP_SAMA5D21
#        -lcN
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw\Debug\List\
#        -o
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../drivers\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../examples\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../lib\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../target\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../target/include\
#        -I
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw/../../target/sama5d2\
#        --interwork --cpu_mode arm -On
#    List file    =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw\Debug\List\twi.lst
#    Object file  =  
#        C:\Users\dfronek\Documents\Project\softpack\examples\test_board_hw\Debug\Obj\twi.o
#
###############################################################################

C:\Users\dfronek\Documents\Project\softpack\drivers\bus\twi.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup twi_module Working with TWI
     31           * \section Purpose
     32           * The TWI driver provides the interface to configure and use the TWI
     33           * peripheral.
     34           *
     35           * \section Usage
     36           * <ul>
     37           * <li> Configures a TWI peripheral to operate in master mode, at the given
     38           * frequency (in Hz) using TWI_Configure(). </li>
     39           * <li> Sends a STOP condition on the TWI using TWI_Stop().</li>
     40           * <li> Starts a read operation on the TWI bus with the specified slave using
     41           * TWI_StartRead(). Data must then be read using TWI_ReadByte() whenever
     42           * a byte is available (poll using TWI_ByteReceived()).</li>
     43           * <li> Starts a write operation on the TWI to access the selected slave using
     44           * TWI_StartWrite(). A byte of data must be provided to start the write;
     45           * other bytes are written next.</li>
     46           * <li> Sends a byte of data to one of the TWI slaves on the bus using TWI_WriteByte().
     47           * This function must be called once before TWI_StartWrite() with the first byte of data
     48           * to send, then it shall be called repeatedly after that to send the remaining bytes.</li>
     49           * <li> Check if a byte has been received and can be read on the given TWI
     50           * peripheral using TWI_ByteReceived().<
     51           * Check if a byte has been sent using TWI_ByteSent().</li>
     52           * <li> Check if the current transmission is complete (the STOP has been sent)
     53           * using TWI_TransferComplete().</li>
     54           * <li> Enables & disable the selected interrupts sources on a TWI peripheral
     55           * using TWI_EnableIt() and TWI_DisableIt().</li>
     56           * <li> Get current status register of the given TWI peripheral using
     57           * TWI_GetStatus(). Get current status register of the given TWI peripheral, but
     58           * masking interrupt sources which are not currently enabled using
     59           * TWI_GetMaskedStatus().</li>
     60           * </ul>
     61           * For more accurate information, please look at the TWI section of the
     62           * Datasheet.
     63           *
     64           * Related files :\n
     65           * \ref twi.c\n
     66           * \ref twi.h.\n
     67          */
     68          /*@{*/
     69          /*@}*/
     70          
     71          /**
     72           * \file
     73           *
     74           * Implementation of Two Wire Interface (TWI).
     75           *
     76           */
     77          
     78          /*----------------------------------------------------------------------------
     79           *        Headers
     80           *----------------------------------------------------------------------------*/
     81          
     82          #include "chip.h"
     83          #include "bus/twi.h"
     84          #include "core/pmc_d2.h"
     85          #include "utils/trace.h"
     86          
     87          #include <stddef.h>
     88          #include <assert.h>
     89          
     90          /*----------------------------------------------------------------------------
     91           *        Exported functions
     92           *----------------------------------------------------------------------------*/
     93          
     94          /**
     95           * \brief Configures a TWI peripheral to operate in master mode, at the given
     96           * frequency (in Hz). The duty cycle of the TWI clock is set to 50%.
     97           * \param twi  Pointer to an Twi instance.
     98           * \param dwTwCk  Desired TWI clock frequency.
     99           * \param dwMCk  Master clock frequency.
    100           */
    101          void twi_configure_master(Twi * pTwi, uint32_t twi_clock, uint32_t master_clock)
    102          {
    103          	uint32_t ck_div, cl_div, ok, max_clock;
    104          	uint32_t id = GET_TWI_ID_FROM_ADDR(pTwi);
    105          
    106          	TRACE_DEBUG("twi_configure_master()\n\r");
    107          	assert(pTwi);
    108          	assert(id != ID_PERIPH_COUNT);
    109          	/* SVEN: TWI Slave Mode Enabled */
    110          	pTwi->TWI_CR = TWI_CR_SVEN;
    111          	/* Reset the TWI */
    112          	pTwi->TWI_CR = TWI_CR_SWRST;
    113          	pTwi->TWI_RHR;
    114          	/* TWI Slave Mode Disabled, TWI Master Mode Disabled. */
    115          	pTwi->TWI_CR = TWI_CR_SVDIS;
    116          	pTwi->TWI_CR = TWI_CR_MSDIS;
    117          	/* Set master mode */
    118          	pTwi->TWI_CR = TWI_CR_MSEN;
    119          	max_clock = pmc_get_peripheral_max_clock(id, master_clock);
    120          	/* Configure clock */
    121          	ck_div = 0;
    122          	ok = 0;
    123          	while (!ok) {
    124          		cl_div = ((max_clock / (2 * twi_clock)) - 8) / (1 << ck_div);
    125          		(cl_div <= 255) ? ok = 1 : ck_div++;
    126          	}
    127          	assert(ck_div < 8);
    128          	TRACE_DEBUG("Using CKDIV = %u and CLDIV/CHDIV = %u\n\r", ck_div, cl_div);
    129          	pTwi->TWI_CWGR = 0;
    130          	pTwi->TWI_CWGR = (cl_div << 16) | (cl_div << 8) | cl_div;
    131          }
    132          
    133          /**
    134           * \brief Configures a TWI peripheral to operate in slave mode.
    135           * \param twi  Pointer to an Twi instance.
    136           * \param slaveAddress Slave address.
    137           */
    138          void twi_configure_slave(Twi * pTwi, uint8_t slave_address)
    139          {
    140          	uint32_t i;
    141          
    142          	TRACE_DEBUG("twi_configure_slave()\n\r");
    143          	assert(pTwi);
    144          	/* TWI software reset */
    145          	pTwi->TWI_CR = TWI_CR_SWRST;
    146          	pTwi->TWI_RHR;
    147          	/* Wait at least 10 ms */
    148          	for (i = 0; i < 1000000; i++) ;
    149          	/* TWI Slave Mode Disabled, TWI Master Mode Disabled */
    150          	pTwi->TWI_CR = TWI_CR_SVDIS | TWI_CR_MSDIS;
    151          	/* Configure slave address. */
    152          	pTwi->TWI_SMR = 0;
    153          	pTwi->TWI_SMR = TWI_SMR_SADR(slave_address);
    154          	/* SVEN: TWI Slave Mode Enabled */
    155          	pTwi->TWI_CR = TWI_CR_SVEN;
    156          	/* Wait at least 10 ms */
    157          	for (i = 0; i < 1000000; i++) ;
    158          	assert((pTwi->TWI_CR & TWI_CR_SVDIS) != TWI_CR_SVDIS);
    159          }
    160          
    161          /**
    162           * \brief Sends a STOP condition on the TWI.
    163           * \param twi  Pointer to an Twi instance.
    164           */
    165          void twi_stop(Twi * pTwi)
    166          {
    167          	assert(pTwi != NULL);
    168          	pTwi->TWI_CR = TWI_CR_STOP;
    169          }
    170          
    171          /**
    172           * \brief Starts a read operation on the TWI bus with the specified slave, it returns
    173           * immediately. Data must then be read using TWI_ReadByte() whenever a byte is
    174           * available (poll using TWI_ByteReceived()).
    175           * \param twi  Pointer to an Twi instance.
    176           * \param address  Slave address on the bus.
    177           * \param iaddress  Optional internal address bytes.
    178           * \param isize  Number of internal address bytes.
    179           */
    180          void twi_start_read(Twi * pTwi, uint8_t address, uint32_t iaddress, uint8_t isize)
    181          {
    182          	assert(pTwi != NULL);
    183          	assert((address & 0x80) == 0);
    184          	assert((iaddress & 0xFF000000) == 0);
    185          	assert(isize < 4);
    186          	/* Set slave address and number of internal address bytes. */
    187          	pTwi->TWI_MMR = 0;
    188          	pTwi->TWI_MMR = (isize << 8) | TWI_MMR_MREAD | (address << 16);
    189          	/* Set internal address bytes */
    190          	pTwi->TWI_IADR = 0;
    191          	pTwi->TWI_IADR = iaddress;
    192          	/* Send START condition */
    193          	pTwi->TWI_CR = TWI_CR_START;
    194          }
    195          
    196          /**
    197           * \brief Reads a byte from the TWI bus. The read operation must have been started
    198           * using TWI_StartRead() and a byte must be available (check with TWI_ByteReceived()).
    199           * \param twi  Pointer to an Twi instance.
    200           * \return byte read.
    201           */
    202          uint8_t twi_read_byte(Twi * pTwi)
    203          {
    204          	assert(pTwi != NULL);
    205          	return pTwi->TWI_RHR;
    206          }
    207          
    208          /**
    209           * \brief Sends a byte of data to one of the TWI slaves on the bus.
    210           * \note This function must be called once before TWI_StartWrite() with
    211           * the first byte of data  to send, then it shall be called repeatedly
    212           * after that to send the remaining bytes.
    213           * \param twi  Pointer to an Twi instance.
    214           * \param byte  Byte to send.
    215           */
    216          void twi_write_byte(Twi * pTwi, uint8_t byte)
    217          {
    218          	assert(pTwi != NULL);
    219          	pTwi->TWI_THR = byte;
    220          }
    221          
    222          /**
    223           * \brief Starts a write operation on the TWI to access the selected slave, then
    224           *  returns immediately. A byte of data must be provided to start the write;
    225           * other bytes are written next.
    226           * after that to send the remaining bytes.
    227           * \param twi  Pointer to an Twi instance.
    228           * \param address  Address of slave to acccess on the bus.
    229           * \param iaddress  Optional slave internal address.
    230           * \param isize  Number of internal address bytes.
    231           * \param byte  First byte to send.
    232           */
    233          void twi_start_write(Twi * pTwi, uint8_t address, uint32_t iaddress, uint8_t isize, uint8_t byte)
    234          {
    235          	assert(pTwi != NULL);
    236          	assert((address & 0x80) == 0);
    237          	assert((iaddress & 0xFF000000) == 0);
    238          	assert(isize < 4);
    239          	/* Set slave address and number of internal address bytes. */
    240          	pTwi->TWI_MMR = 0;
    241          	pTwi->TWI_MMR = (isize << 8) | (address << 16);
    242          	/* Set internal address bytes. */
    243          	pTwi->TWI_IADR = 0;
    244          	pTwi->TWI_IADR = iaddress;
    245          	/* Write first byte to send. */
    246          	twi_write_byte(pTwi, byte);
    247          }
    248          
    249          /**
    250           * \brief Check if a byte have been receiced from TWI.
    251           * \param twi  Pointer to an Twi instance.
    252           * \return 1 if a byte has been received and can be read on the given TWI
    253           * peripheral; otherwise, returns 0. This function resets the status register.
    254           */
    255          uint8_t twi_is_byte_received(Twi * pTwi)
    256          {
    257          	assert(pTwi != NULL);
    258          	return ((pTwi->TWI_SR & TWI_SR_RXRDY) == TWI_SR_RXRDY);
    259          }
    260          
    261          /**
    262           * \brief Check if a byte have been sent to TWI.
    263           * \param twi  Pointer to an Twi instance.
    264           * \return 1 if a byte has been sent  so another one can be stored for
    265           * transmission; otherwise returns 0. This function clears the status register.
    266           */
    267          uint8_t twi_byte_sent(Twi * pTwi)
    268          {
    269          	assert(pTwi != NULL);
    270          	return ((pTwi->TWI_SR & TWI_SR_TXRDY) == TWI_SR_TXRDY);
    271          }
    272          
    273          /**
    274           * \brief Check if current transmission is complet.
    275           * \param twi  Pointer to an Twi instance.
    276           * \return  1 if the current transmission is complete (the STOP has been sent);
    277           * otherwise returns 0.
    278           */
    279          uint8_t twi_is_transfer_complete(Twi * pTwi)
    280          {
    281          	assert(pTwi != NULL);
    282          	return ((pTwi->TWI_SR & TWI_SR_TXCOMP) == TWI_SR_TXCOMP);
    283          }
    284          
    285          /**
    286           * \brief Enables the selected interrupts sources on a TWI peripheral.
    287           * \param twi  Pointer to an Twi instance.
    288           * \param sources  Bitwise OR of selected interrupt sources.
    289           */
    290          void twi_enable_it(Twi * pTwi, uint32_t sources)
    291          {
    292          	assert(pTwi != NULL);
    293          	assert((sources & 0xFFFFF088) == 0);
    294          	pTwi->TWI_IER = sources;
    295          }
    296          
    297          /**
    298           * \brief Disables the selected interrupts sources on a TWI peripheral.
    299           * \param twi  Pointer to an Twi instance.
    300           * \param sources  Bitwise OR of selected interrupt sources.
    301           */
    302          void twi_disable_it(Twi * pTwi, uint32_t sources)
    303          {
    304          	assert(pTwi != NULL);
    305          	assert((sources & 0xFFFFF088) == 0);
    306          	pTwi->TWI_IDR = sources;
    307          }
    308          
    309          /**
    310           * \brief Get the current status register of the given TWI peripheral.
    311           * \note This resets the internal value of the status register, so further
    312           * read may yield different values.
    313           * \param twi  Pointer to an Twi instance.
    314           * \return  TWI status register.
    315           */
    316          uint32_t twi_get_status(Twi * pTwi)
    317          {
    318          	assert(pTwi != NULL);
    319          	return pTwi->TWI_SR;
    320          }
    321          
    322          /**
    323           * \brief Returns the current status register of the given TWI peripheral, but
    324           * masking interrupt sources which are not currently enabled.
    325           * \note This resets the internal value of the status register, so further
    326           * read may yield different values.
    327           * \param twi  Pointer to an Twi instance.
    328           */
    329          uint32_t twi_get_masked_status(Twi * pTwi)
    330          {
    331          	uint32_t status;
    332          	assert(pTwi != NULL);
    333          	status = pTwi->TWI_SR;
    334          	status &= pTwi->TWI_IMR;
    335          	return status;
    336          }
    337          
    338          /**
    339           * \brief  Sends a STOP condition. STOP Condition is sent just after completing
    340           *  the current byte transmission in master read mode.
    341           * \param twi  Pointer to an Twi instance.
    342           */
    343          void twi_send_stop_condition(Twi * pTwi)
    344          {
    345          	assert(pTwi != NULL);
    346          	pTwi->TWI_CR |= TWI_CR_STOP;
    347          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GET_TWI_ID_FROM_ADDR
       8   twi_byte_sent
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      40   twi_configure_master
        40   -> GET_TWI_ID_FROM_ADDR
        40   -> __aeabi_assert
        40   -> __iar_EmptyStepPoint
        40   -> pmc_get_peripheral_max_clock
        40 __aeabi_uidiv
      16   twi_configure_slave
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   twi_disable_it
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   twi_enable_it
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   twi_get_masked_status
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   twi_get_status
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_is_byte_received
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_is_transfer_complete
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_read_byte
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_send_stop_condition
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      24   twi_start_read
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   twi_start_write
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> twi_write_byte
       8   twi_stop
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   twi_write_byte
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       8  ?_0
      64  ?_1
      24  ?_2
      12  ?_3
      48  ?_4
      16  ?_5
      24  ?_6
      32  ?_7
      12  ?_8
      28  ?_9
      92  GET_TWI_ID_FROM_ADDR
      48  _id_h64_matrix
      52  twi_byte_sent
     288  twi_configure_master
     196  twi_configure_slave
      84  twi_disable_it
      84  twi_enable_it
      60  twi_get_masked_status
      44  twi_get_status
      52  twi_is_byte_received
      48  twi_is_transfer_complete
      48  twi_read_byte
      52  twi_send_stop_condition
     204  twi_start_read
     212  twi_start_write
      48  twi_stop
      56  twi_write_byte

 
   316 bytes in section .rodata
 1 676 bytes in section .text
 
 1 676 bytes of CODE  memory
   316 bytes of CONST memory

Errors: none
Warnings: 1
